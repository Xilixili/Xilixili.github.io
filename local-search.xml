<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tarjan算法</title>
    <link href="/2020/04/26/Tarjan%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/26/Tarjan%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><p><img src="https://img-blog.csdnimg.cn/20200426155322525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10010;int dfn[MAXN],low[MAXN],Stack[MAXN];vector&lt;int&gt; graph[MAXN];//遍历深度以及栈顶指针(指向最后一个元素)int deep=0,top=-1;//标记元素是否在栈中int tag[MAXN];//强连通分量个数int cnt=0;//为不同的强连通分量上色区分int color[MAXN];void tarjan(int u){    dfn[u]=low[u]=++deep;    Stack[++top]=u;    tag[u]=1;    for(int i=0;i&lt;graph[u].size();i++){        int v=graph[u][i];        //if(v==fa) continue;统计强连通分量个数不需要这个        if(dfn[v]==0){            tarjan(v);            low[u]=min(low[u],low[v]);        }        //在栈中才进行更新        else if(tag[v]==1){            low[u]=min(low[u],dfn[v]);        }    }    //cout&lt;&lt;u&lt;&lt;&quot;:&quot;&lt;&lt;dfn[u]&lt;&lt;&quot; &quot;&lt;&lt;low[u]&lt;&lt;endl;    //已经出现了一个强连通分量    if(dfn[u]==low[u]){        cnt++;        //将同一个连通分量中的结点全部出栈        while(tag[u]==1){            tag[Stack[top]]=0;//置标记            color[Stack[top]]=cnt;            top--;        }    }}int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    memset(dfn,0,sizeof(dfn));    memset(tag,0,sizeof(tag));    fill(low,low+n+1,INT_MAX);    for(int i=0;i&lt;m;i++){        int from,to;        cin&gt;&gt;from&gt;&gt;to;        graph[from].push_back(to);    }    tarjan(1);    cout&lt;&lt;cnt&lt;&lt;endl;    for(int i=1;i&lt;=n;i++){        cout&lt;&lt;i&lt;&lt;&quot; color &quot;&lt;&lt;color[i]&lt;&lt;endl;    }}//测试用例/*6 81 21 32 43 43 54 14 65 6*/*/</code></pre><h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><p><img src="https://img-blog.csdnimg.cn/20200425214222817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>思路一：依次删除每个割点，然后DFS<br>思路二：Tarjan算法</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10010;int deep=0,child=0,root=1,cnt=0;vector&lt;int&gt; graph[MAXN];int dfn[MAXN],low[MAXN],tag[MAXN];vector&lt;int&gt; ans;/*访问过  当前是根结点  当前不是根结点 且 通过儿子能访问到更早访问过的结点没访问过且此边不指向父亲节点*///low找到更早的结点一定是不能违背dfs的遍历顺序的//比如你已经访问过的一条边肯定是不能逆向访问的//fa为当前结点的父节点void tarjan(int u,int fa){    dfn[u]=low[u]=++deep;    for(int i=0;i&lt;graph[u].size();i++){        int v=graph[u][i];        if(v==fa) continue;        if(dfn[v]==0){//没有遍历过            tarjan(v,u);            low[u]=min(low[u],low[v]);//转换1            //对于根结点是否为割点的判定，记录子树个数            if(u==root) child++;            //其他结点u若符合该条件，u就是割点            //这里改为low[v]&gt;dfn[u] ,则(u,v)是一条割边            else if(dfn[u]&lt;=low[v]){//理解:不能访问到比自己更先遍历的结点,等于则是刚好成环的那种情况                tag[u]=1;            }        }        else if{//遍历过且不是指向父亲            low[u]=min(low[u],dfn[v]);        }    }}int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    memset(dfn,0,sizeof(dfn));    fill(low,low+n,INT_MAX);    memset(tag,0,sizeof(tag));    for(int i=0;i&lt;m;i++){        int from,to;        cin&gt;&gt;from&gt;&gt;to;        graph[from].push_back(to);        graph[to].push_back(from);    }    tarjan(root,0);    if(child&gt;=2) tag[root]=1;    for(int i=0;i&lt;n;i++){        if(tag[i]){            cnt++; ans.push_back(i);        }    }    cout&lt;&lt;cnt&lt;&lt;endl;    for(int i=0;i&lt;ans.size();i++){        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>Tarjan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2020/04/25/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/25/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int nextval[1000];//这里面所有的i和j都是序号void get_nextval(string T){    //j表示前缀的结尾，i表示后缀的结尾    int i=1,j=0;    nextval[1]=0;    while(i&lt;T.size()){        if(j==0||T[i]==T[j]){            i++; j++;            if(T[i]!=T[j]) nextval[i]=j;//j==0            else nextval[i]=nextval[j];//T[i]!=T[j]        }        else{            j=nextval[j];        }    }}int Index_KMP(string S,string T){    //i是指向主串的指针，j是模式串的指针    int i=1,j=1;    while(i&lt;=S.size()&amp;&amp;j&lt;=T.size()){        if(j==0||S[i]==T[j]){//持续比较后继字符            i++; j++;        }        else{            j=nextval[j];//模式串向右移动        }    }    //如果j指针已经超出了模式串的末尾，则返回匹配成功的起始点    if(j&gt;T.size()) return i-T.size();    else return 0;}int main(){    string S,T;    cin&gt;&gt;S&gt;&gt;T;    get_nextval(T);    cout&lt;&lt;Index_KMP(S,T)&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题最终总结</title>
    <link href="/2020/04/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>常见的背包问题有<br>1、组合问题：   dp[i] += dp[i-num]<br>2、True、False问题：dp[i] = dp[i] or dp[i-num]<br>3、最大最小问题：dp[i] = min(dp[i], dp[i-num]+1)<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;dp[i] = max(dp[i], dp[i-num]+1)</p><p><font color=red><strong>注意dp的初始化!!!</strong></font></p><h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><h2 id="1-采药问题"><a href="#1-采药问题" class="headerlink" title="1.采药问题"></a>1.采药问题</h2><p><strong>题目描述</strong><br>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><p><strong>输入格式</strong><br>第一行有2个整数T(1≤T≤1000)和M(1≤M≤100)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。<br>接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><p><strong>输出格式</strong><br>1个整数，表示在规定的时间内可以采到的草药的最大总价值。</p><p>输入输出样例<br><strong>输入</strong></p><blockquote><p>70 3<br>71 100<br>69 1<br>1 2</p></blockquote><p><strong>输出</strong> </p><blockquote><p>3</p></blockquote><p><strong>分析</strong><br>普通的0-1背包，求最大的收益</p><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000;int w[MAXN],v[MAXN];int dp[MAXN];int main(){    int n,m;//容量为n,物品有m个    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=1;i&lt;=m;i++){//上到下,关于第i个物品选与不选        for(int j=n;j&gt;=w[i];j--){//右到左，关于选与不选对应的收益            dp[j]=max(dp[j-w[i]]+v[i],dp[j]);        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="2-装箱问题"><a href="#2-装箱问题" class="headerlink" title="2.装箱问题"></a>2.装箱问题</h2><p><strong>题目描述</strong><br>有一个箱子容量为V（200000≤V≤20000），同时有n个物品（300&lt;n≤30），每个物品有一个体积（正整数）。<br>要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p><p><strong>输入格式</strong><br>1个整数，表示箱子容量<br>1个整数，表示有n个物品<br>接下来n行，分别表示这n个物品的各自体积</p><p><strong>输出格式</strong><br>1个整数，表示箱子剩余空间。</p><p><strong>输入</strong></p><blockquote><p>24 6<br>8<br>3<br>12<br>7<br>9<br>7</p></blockquote><p><strong>输出</strong> </p><blockquote><p>0</p></blockquote><p><strong>分析</strong><br>注意分析什么是模板中的变量的转换，比如什么是背包容量，什么是价值，什么是重量，这道题转化为求装入若干个物品使其体积和最大</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=50;int w[MAXN],v[MAXN];int dp[30005];int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;w[i];        v[i]=w[i];//这个题的物品重量等同于价值    }    for(int i=1;i&lt;=m;i++){        for(int j=n;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;n-dp[n]&lt;&lt;endl;}</code></pre><h2 id="3-最大约数和"><a href="#3-最大约数和" class="headerlink" title="3.最大约数和"></a>3.最大约数和</h2><p><strong>题目描述</strong><br>选取和不超过S的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。</p><p><strong>输入格式</strong><br>输入一个正整数S。</p><p><strong>输出格式</strong><br>输出最大的约数之和。</p><p>输入</p><blockquote><p>11</p></blockquote><p>输出</p><blockquote><p>9</p></blockquote><p><strong>说明/提示</strong><br>取数字4和6，可以得到最大值(1+2)+(1+2+3)=9。</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=2000;int v[MAXN];int dp[10000];int main(){    int n,m;    cin&gt;&gt;m;    n=m;    for(int i=1;i&lt;=m;i++){        for(int j=1;j&lt;i;j++){            if(i%j==0) v[i]+=j;        }        //cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;v[i]&lt;&lt;endl;    }    for(int i=1;i&lt;=m;i++){        for(int j=n;j&gt;=i;j--){            dp[j]=max(dp[j],dp[j-i]+v[i]);//数字本身为重量,数字的约数之和为价值        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="4-精卫填海"><a href="#4-精卫填海" class="headerlink" title="4.精卫填海"></a>4.精卫填海</h2><p><strong>题目描述</strong><br>发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》<br>精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？<br>事实上，东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。</p><p><strong>输入格式</strong><br>输入文件的第一行是三个整数：v、n、c。<br>从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。</p><p><strong>输出格式</strong><br>输出文件只有一行，如果精卫能把东海填平，则输出她把东海填平后剩下的最大的体力，否则输出’Impossible’（不带引号）。</p><p><strong>输入</strong></p><blockquote><p>100 2 10<br>50 5<br>50 5</p></blockquote><p><strong>输出</strong></p><blockquote><p>0</p></blockquote><p><strong>输入</strong></p><blockquote><p>10 2 1<br>50 5<br>10 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>Impossible</p></blockquote><p><strong>分析</strong><br>这道题稍微有点不同，这道题是算背包容量能剩下多少，所以在计算出各个dp后，要背包容量从1开始递增看是否能够满足，然后输出剩下的最大体力.</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=10005;int w[MAXN]; int v[MAXN];int dp[20000];int main(){    int s,m,n;//s为剩下没填的体积,m为物品件数,n为背包容量    cin&gt;&gt;s&gt;&gt;m&gt;&gt;n;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;v[i]&gt;&gt;w[i];    }    for(int i=1;i&lt;=m;i++){        for(int j=n;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);//计算当前剩余体力能搬的最大体积数        }    }    for(int i=1;i&lt;=n;i++){//遍历各个背包容量        if(dp[i]&gt;=s) {cout&lt;&lt;n-i&lt;&lt;endl; return 0;}    }    //if(dp[n]&gt;=s) cout&lt;&lt;dp[n]-s&lt;&lt;endl; //错误，因为在之前就可能已经满足了，没求到剩下的最大体力    cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="5-集合-Subset-Sums-组合数"><a href="#5-集合-Subset-Sums-组合数" class="headerlink" title="5.集合 Subset Sums(组合数)"></a>5.集合 Subset Sums(组合数)</h2><p><strong>题目描述</strong><br>对于从 1∼n 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 n=3，对于{1,2,3} 能划分成两个子集合，每个子集合的所有数字和是相等的：{3} 和 {1,2} 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）如果n=7，有四种方法能划分集合 {1,2,3,4,5,6,7}，每一种分法的子集合各数字和是相等的:</p><p>{1,6,7} 和 {2,3,4,5}<br>{2,5,7} 和 {1,3,4,6}<br>{3,4,7} 和 {1,2,5,6}<br>{1,2,4,7} 和 {3,5,6}</p><p>给出 n，你的程序应该输出划分方案总数。</p><p><strong>输入格式</strong><br>输入文件只有一行，且只有一个整数 n</p><p><strong>输出格式</strong><br>输出划分方案总数。</p><p><strong>输入</strong></p><blockquote><p>7</p></blockquote><p><strong>输出</strong></p><blockquote><p>4</p></blockquote><p><strong>分析</strong><br>方法类的背包问题，注意背包容量是总的和的一半，而最终求的是划分而不是集合，所以要除以2</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=100;long long dp[1000]={1};//方法种类的背包问题，初始化为1int main(){    int m,n;    cin&gt;&gt;m;    n=m;//n为物品数    if((1+m)*m/2%2==0) m=(1+m)*m/2;//总的和，其一半是背包的容量    else{        cout&lt;&lt;0; return 0;    }    for(int i=1;i&lt;=n;i++){        for(int j=m/2;j&gt;=i;j--){            dp[j]=dp[j]+dp[j-i];//选与不选        }    }    cout&lt;&lt;dp[m/2]/2&lt;&lt;endl;//因为求的是划分数而不是和为m/2的集合数}</code></pre><h2 id="6-目标和"><a href="#6-目标和" class="headerlink" title="6.目标和"></a>6.目标和</h2><p><img src="https://img-blog.csdnimg.cn/20200419174249875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>设P为正数集的和,N为负数集合的和,S为所有元素和,T为目标和<br>∵P+N=S<br>&ensp;&ensp;P-N=T<br>∴2P=S+T<br>所以只要找到在序列找到和为(S+T)/2的所有方案就行,此时转化成了0-1背包的组合数问题</p><pre><code class="cpp">class Solution {public:    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {        int n=nums.size();        int sum=0;        for(int i=0;i&lt;n;i++){            sum+=nums[i];        }        long long temp=(long long)sum+(long long)S;        if(temp%2==1||S-sum&gt;0) return 0;        int target=(sum+S)/2;        //初始化        vector&lt;int&gt; dp(10010,0);        dp[0]=1;;        //cout&lt;&lt;dp[S]&lt;&lt;endl;        for(int i=0;i&lt;n;i++){            for(int j=target;j&gt;=nums[i];j--){                //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;j-nums[i]&lt;&lt;endl;                dp[j]=dp[j]+dp[j-nums[i]];                //cout&lt;&lt;dp[j]&lt;&lt;endl;            }        }        return dp[target];    }};</code></pre><h2 id="7-分割等和子集-true-amp-false"><a href="#7-分割等和子集-true-amp-false" class="headerlink" title="7.分割等和子集(true&amp;false)"></a>7.分割等和子集(true&amp;false)</h2><p><img src="https://img-blog.csdnimg.cn/20200419170458826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    long long dp[10010];    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum=0;        for(int i=0;i&lt;nums.size();i++){            sum+=nums[i];        }        if(sum%2==1) return false;        int target=sum/2;        //初始化,注意初始化的方法        vector&lt;bool&gt; dp(target,false);        dp[0]=true;        cout&lt;&lt;dp[0]&lt;&lt;endl;        for(int i=0;i&lt;nums.size();i++){            for(int j=target;j&gt;=nums[i];j--){                dp[j]=dp[j]||dp[j-nums[i]];                //cout&lt;&lt;dp[j]&lt;&lt;endl;            }        }        return dp[target];    }};</code></pre><h2 id="8-一和零-双weight"><a href="#8-一和零-双weight" class="headerlink" title="8.一和零(双weight)"></a>8.一和零(双weight)</h2><p><img src="https://img-blog.csdnimg.cn/20200414182723147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注:这里的weight是二维的(对于每一个串都有自己0,1的weight)</p><pre><code class="cpp">    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {        //dp[i][j]表示i个0，j个1能够拼出的数组中的最大的字符串数量        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1));        vector&lt;vector&lt;int&gt;&gt; weight(strs.size(),vector&lt;int&gt;(2,0));        //cout&lt;&lt;dp[1][1]&lt;&lt;endl;        for(int i=0;i&lt;strs.size();i++){            for(int j=0;j&lt;strs[i].size();j++){                if(strs[i][j]==&#39;0&#39;) weight[i][0]++;                else weight[i][1]++;            }            //cout&lt;&lt;weight[i][0]&lt;&lt;&quot; &quot;&lt;&lt;weight[i][1]&lt;&lt;endl;        }        for(int k=0;k&lt;strs.size();k++){//从上到下每个物品选与不选            //cout&lt;&lt;weight[k][0]&lt;&lt;&quot; &quot;&lt;&lt;weight[k][1]&lt;&lt;endl;            for(int i=m;i&gt;=weight[k][0];i--){//遍历0的背包容量                for(int j=n;j&gt;=weight[k][1];j--){//遍历1的背包容量                    dp[i][j]=max(dp[i][j],dp[i-weight[k][0]][j-weight[k][1]]+1);                    //cout&lt;&lt;dp[i][j]&lt;&lt;endl;                }            }        }        return dp[m][n];    }</code></pre><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="1-疯狂的采药"><a href="#1-疯狂的采药" class="headerlink" title="1.疯狂的采药"></a>1.疯狂的采药</h2><p><strong>题目描述</strong><br>LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是LiYuxiang，你能完成这个任务吗？<br>此题和原题的不同点：<br>1.每种草药可以无限制地疯狂采摘。<br>2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p><p><strong>输入格式</strong><br>输入第一行有两个整数T（1 &lt;= T &lt;= 100000）和M（1 &lt;= M &lt;= 10000），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间（包括1和10000）的整数，分别表示采摘某种草药的时间和这种草药的价值。</p><p><strong>输出格式</strong><br>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><p><strong>输入</strong></p><blockquote><p>70 3<br>71 100<br>69 1<br>1 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>140</p></blockquote><p><strong>分析</strong><br>完全背包要修改j的遍历方式，需要反着来</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=10005;int w[MAXN],v[MAXN];int dp[100005];int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=1;i&lt;=m;i++){        for(int j=w[i];j&lt;=n;j++){//完全背包和0-1背包这里是反着的            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="2-神奇的四次方数"><a href="#2-神奇的四次方数" class="headerlink" title="2.神奇的四次方数"></a>2.神奇的四次方数</h2><p><strong>题目描述</strong><br>将一个整数m分解为n个四次方数的和的形式，要求n最小。例如，m=706,706=5^4+3^4,则n=2。</p><p><strong>输入格式</strong><br>一行，一个整数m。</p><p><strong>输出格式</strong><br>一行，一个整数n。</p><p><strong>输入</strong></p><blockquote><p>706</p></blockquote><p><strong>输出</strong></p><blockquote><p>2</p></blockquote><p><strong>分析</strong><br>这道题因为求的是最小，所以要将dp初始化为一个比较大的数，并且dp[0]=0；<br>相当于给一个初始值，含义为容量为0时最少选择0个数.</p><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;math.h&gt;using namespace std;const int MAXN=100;int w[MAXN];//每个的w都是1int dp[1000001];int main(){    //下面这两步一定要写    memset(dp,63,sizeof(dp));    //给了一个初始值，不然结果会是一个很大的数，其含义代表容量为0时最少选择0个数    dp[0]=0;    int n,m;//n为背包容量    cin&gt;&gt;n;    for(int i=1;pow(i,4)&lt;=n;i++){        w[i]=i*i*i*i;        m=i;//m表示物品的数目    }    for(int i=1;i&lt;=m;i++){        for(int j=w[i];j&lt;=n;j++){//v[i]是1            dp[j]=min(dp[j],dp[j-w[i]]+1);//            cout&lt;&lt;dp[j]&lt;&lt;endl;        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="3-零钱兑换-II-组合数"><a href="#3-零钱兑换-II-组合数" class="headerlink" title="3.零钱兑换 II(组合数)"></a>3.零钱兑换 II(组合数)</h2><p><img src="https://img-blog.csdnimg.cn/20200419161911317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>是求组合数，因为{1,2},{2,1}是同一个<br>求组合数模板是<strong>先遍历物品，再遍历背包</strong></p><pre><code class="cpp">class Solution {public:    int dp[10010];    int change(int amount, vector&lt;int&gt;&amp; coins) {        memset(dp,0,sizeof(dp));        dp[0]=1;        for(int i=0;i&lt;coins.size();i++){            for(int j=coins[i];j&lt;=amount;j++){                dp[j]=dp[j]+dp[j-coins[i]];            }        }        return dp[amount];    }};</code></pre><h2 id="4-组合总和-Ⅳ-排列数-反向嵌套"><a href="#4-组合总和-Ⅳ-排列数-反向嵌套" class="headerlink" title="4.组合总和 Ⅳ(排列数,反向嵌套)"></a>4.组合总和 Ⅳ(排列数,反向嵌套)</h2><p><img src="https://img-blog.csdnimg.cn/20200419154823970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>是求排列数，因为{1,2},{2,1}不是同一个<br>求组合数模板是<strong>先遍历背包，再遍历物品</strong></p><pre><code class="cpp">class Solution {public:    int combinationSum4(vector&lt;int&gt;&amp; nums, int target)     {        if(nums.size() == 0)            return 0;        vector&lt;unsigned int&gt; dp(target + 1, 0);        dp[0] = 1;//组成0的方案只能是全部都不选择，所以方案数为1.        for(int i = 0; i &lt;= target; i++)        {            for(int j = 0; j &lt; nums.size(); j++)            {                if(i - nums[j] &gt;= 0)                    dp[i] += dp[i - nums[j]];            }        }        return dp[target];    }};</code></pre><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="1-通天之分组背包"><a href="#1-通天之分组背包" class="headerlink" title="1.通天之分组背包"></a>1.通天之分组背包</h2><p><strong>题目描述</strong><br>自01背包问世之后，小A对此深感兴趣。一天，小A去远游，却发现他的背包不同于01背包，他的物品大致可分为k组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。</p><p><strong>输入格式</strong><br>两个数m,n，表示一共有n件物品，总重量为m<br>接下来n行，每行3个数ai,bi,ci，表示物品的重量，利用价值，所属组数</p><p><strong>输出格式</strong><br>一个数，最大的利用价值</p><p><strong>输入</strong></p><blockquote><p>45 3<br>10 10 1<br>10 5 1<br>50 400 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>10</p></blockquote><p><strong>分析</strong><br>分组背包采用结构体数组，其下标代表组数，内部的w，v数组存的是组内的元素情况，总组数要在输入中算出，第二次遍历也是先遍历所有组，其本质相当于0-1背包的问题</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=2000;struct group{    int group_size;//组的大小    int w[MAXN],v[MAXN];}G[1000];//下标代表组号int dp[10000];int main(){    int n,m,s=0;//s代表组数    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int a,b,c;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        s=max(c,s);//统计总的组数        G[c].group_size++;//c组内的成员增加        int ci=G[c].group_size;        G[c].w[ci]=a;        G[c].v[ci]=a;    }    for(int i=1;i&lt;=s;i++){//从上到下遍历所有组        for(int j=n;j&gt;=0;j--){            for(int k=1;k&lt;=G[i].group_size;k++){//组内成员竞争，注意j不会变化                if(j-G[i].w[k]&gt;=0){//注意                    dp[j]=max(dp[j],dp[j-G[i].w[k]]+G[i].v[k]);                }            }        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="2-金明的预算方案"><a href="#2-金明的预算方案" class="headerlink" title="2.金明的预算方案"></a>2.金明的预算方案</h2><p><strong>题目描述</strong><br>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>主件 附件</p><p>电脑 打印机，扫描仪</p><p>书柜 图书</p><p>书桌 台灯，文具</p><p>工作椅 无</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分5等：用整数1−5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br>请你帮助金明设计一个满足要求的购物单。</p><p><strong>输入格式</strong><br>第11行，为两个正整数，用一个空格隔开：</p><p>n m（其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第j行给出了编号为j−1的物品的基本数据，每行有3个非负整数</p><p>v p q（其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1-5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）</p><p><strong>输出格式</strong><br>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。</p><p><strong>输入</strong></p><blockquote><p>1000 5<br>800 2 0<br>400 5 1<br>300 5 1<br>400 3 0<br>500 2 0</p></blockquote><p><strong>输出</strong></p><blockquote><p>2200</p></blockquote><p><strong>分析</strong><br>先转化为分组问题，假设有主(①)，从(②)，从(③)<br>所以得到一个组内四个相斥的成员：<br>①、①②、①③、①③</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=100;struct group{    int group_size;    int w[MAXN],v[MAXN];}G[2000];int dp[32005];//因为每个主件可以有0个、1个或2个附件,所以对于组内只有四种相互排斥的情况，所以可以转化为分组背包int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int v,p,q;        cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;        if(q==0){//是这组的第一个,i就代表了组号            G[i].group_size=1;            G[i].w[1]=v;            G[i].v[1]=p*v;        }        else{            if(G[q].group_size==1){//一主一从,q代表所从属的组                G[q].group_size=2;                G[q].w[2]=G[q].w[1]+v;//一个主，从一号                G[q].v[2]=G[q].v[1]+p*v;            }            else{                G[q].group_size=4;//                G[q].w[3]=G[q].w[1]+v;//一个主，从二号                G[q].v[3]=G[q].v[1]+p*v;                G[q].w[4]=G[q].w[2]+v;//一个主，从一号，从二号                G[q].v[4]=G[q].v[2]+p*v;            }        }    }    for(int i=1;i&lt;=m;i++){//遍历所有组        for(int j=n;j&gt;=0;j--){            for(int k=1;k&lt;=G[i].group_size;k++){//组内成员竞争                if(j&gt;=G[i].w[k]){//                    dp[j]=max(dp[j],dp[j-G[i].w[k]]+G[i].v[k]);                    //cout&lt;&lt;dp[j]&lt;&lt;endl;                }            }        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票问题总结</title>
    <link href="/2020/04/16/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/16/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>注意:这里面dp[①][②][③]的理解<br>①第几天<br>②还剩几次交易机会<br>③1：当前持股；   0：当前不持股<br>1.<strong>dp的含义是当前这个状态下能达到的最大的收益</strong></p><p>2.因为是状态转移，所以已经满足了不会连续买入</p><p>3.也因为是状态转移，所以情况多了后，初始化为0位造成影响，比如dp[i][0][0]这个时候是没有持股，并且没有再买入的机会，这个时候若直接用max(dp[i-1][0][0],dp[i-1][0][1]+prices[i]);会是0+prices[i]就会造成误判，所以要<strong>初始化为int_min</strong></p><p>4.只买一次max(dp[i-1][1],<strong>-prices[i]</strong>);<br> &nbsp;&nbsp;&nbsp;无穷次max(dp[i-1][1],<strong>dp[i-1][0]-prices[i]</strong>);</p><h2 id="1-买卖股票的最佳时机"><a href="#1-买卖股票的最佳时机" class="headerlink" title="1.买卖股票的最佳时机"></a>1.买卖股票的最佳时机</h2><p><img src="https://img-blog.csdnimg.cn/20200416150639901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        int dp[1000010][2];        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                dp[i][0]=0;                dp[i][1]=-prices[i];            }            else{                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);                //写成-prices[i]保证了计算出来的利润只包含了一次的买卖                dp[i][1]=max(dp[i-1][1],-prices[i]);                //cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][0]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][1]&lt;&lt;endl;            }        }        for(int i=0;i&lt;prices.size();i++){            //对卖出所赚的钱进行比较            max_profit=max(max_profit,dp[i][0]);        }        return max_profit;    }};</code></pre><h2 id="2-买卖股票的最佳时机-II"><a href="#2-买卖股票的最佳时机-II" class="headerlink" title="2.买卖股票的最佳时机 II"></a>2.买卖股票的最佳时机 II</h2><p><img src="https://img-blog.csdnimg.cn/20200416152331656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        int dp[100010][2];//[天数][是否持有]        if(prices.size()==0) return 0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                //初始化                                dp[i][0]=0;                dp[i][1]=-prices[i];            }            else{                //状态变换                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);                //因为可以交易无限次，所以这里写成dp[i-1][0]-prices[i]                dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);            }        }        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);    }};</code></pre><h2 id="3-买卖股票的最佳时机-III"><a href="#3-买卖股票的最佳时机-III" class="headerlink" title="3.买卖股票的最佳时机 III"></a>3.买卖股票的最佳时机 III</h2><p><img src="https://img-blog.csdnimg.cn/20200416162655992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(prices.size()==0) return 0;        //注意:应该将初始dp值设为int_min,不然有的第二次卖出是用一个空的状态(0)+prices[i](实际上在这之前根本没买)        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(prices.size(),vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(2,INT_MIN)));        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                dp[i][2][0]=0;                dp[i][1][1]=-prices[i];            }            else{                //每当买入才进行一次k--，所以在持股到卖出的这个过程中不用考虑k的变化                //没有买入                //dp[i][2][0]=0;                //第一次卖出                dp[i][1][0]=max(dp[i-1][1][0],dp[i-1][1][1]+prices[i]);                //第二次卖出                if(i&gt;2) dp[i][0][0]=max(dp[i-1][0][0],dp[i-1][0][1]+prices[i]);                //第一次买入                dp[i][1][1]=max(dp[i-1][1][1],-prices[i]);                //第二次买入                if(i&gt;=2) dp[i][0][1]=max(dp[i-1][0][1],dp[i-1][1][0]-prices[i]);            }            //cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][1][0]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][0][0]&lt;&lt;&quot;       &quot;&lt;&lt;dp[i][1][1]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][0][1]&lt;&lt;endl;        }        //交易一次和交易两次        max_profit=max(dp[prices.size()-1][0][0],dp[prices.size()-1][1][0]);        //不交易        max_profit=max(max_profit,0);        return max_profit;    }};</code></pre><p>若是允许k次交易</p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(prices.size()==0) return 0;        //注意:应该将初始dp值设为int_min,不然有的第二次卖出是用一个空的状态(0)+prices[i](实际上在这之前根本没买)        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(prices.size(),vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(2,0)));        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            //注意这个初始化!!            for(int j=1;j&gt;=0;j--){                if(i==0){                    dp[i][j][0]=0;                    dp[i][j][1]=-prices[i];                }                else{                    dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);                    dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j+1][0]-prices[i]);                }            }        }        //交易一次和交易两次        max_profit=max(dp[prices.size()-1][0][0],dp[prices.size()-1][1][0]);        //不交易        max_profit=max(max_profit,0);        return max_profit;    }};</code></pre><h2 id="4-最佳买卖股票时机含冷冻期"><a href="#4-最佳买卖股票时机含冷冻期" class="headerlink" title="4.最佳买卖股票时机含冷冻期"></a>4.最佳买卖股票时机含冷冻期</h2><p><img src="https://img-blog.csdnimg.cn/20200416174642900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(prices.size()==0) return 0;        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(),vector&lt;int&gt;(2,0));        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                dp[i][0]=0;                dp[i][1]=-prices[i];            }            else{                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);                if(i&gt;=2) dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i]);                //若在第二个之前持有股票那么就只可能在0处买或在1处买                else dp[i][1]=max(dp[i-1][1],-prices[i]);            }        }        return dp[prices.size()-1][0];    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度计算</title>
    <link href="/2020/04/16/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/04/16/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="高进度加法"><a href="#高进度加法" class="headerlink" title="高进度加法"></a>高进度加法</h2><pre><code class="cpp">void add(string aa,string bb){    la=aa.size();    lb=bb.size();    for(int i=0;i&lt;la;i++){        a[la-i]=aa[i]-&#39;0&#39;;    }    for(int i=0;i&lt;lb;i++){        b[lb-i]=bb[i]-&#39;0&#39;;    }    lc=max(la,lb);    for(int i=1;i&lt;=lc;i++){        c[i]+=(a[i]+b[i])%10;        c[i+1]=(a[i]+b[i])/10;    }    if(c[lc+1]) lc++;    for(int i=lc;i&gt;=1;i--){        cout&lt;&lt;c[i];    }}</code></pre><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><pre><code class="cpp">//相等返回0，大于返回1，小于返回-1int compare(string s1,string s2){    if(s1.size()&gt;s2.size()) return 1;    else if(s1.size()&lt;s2.size()) return -1;    else return s1.compare(s2);//位数相同用compare函数进行比较}void sub(string aa,string bb){    //比较大小    if(compare(aa,bb)==-1){        swap(aa,bb);        cout&lt;&lt;&quot;-&quot;;    }    else if(compare(aa,bb)==0){        cout&lt;&lt;0; return;    }    la=aa.size();    lb=bb.size();    //string-&gt;int数组,低位排在前面    for(int i=0;i&lt;la;i++){        a[la-i]=aa[i]-&#39;0&#39;;    }    for(int i=0;i&lt;lb;i++){        b[lb-i]=bb[i]-&#39;0&#39;;    }    //计算    for(int i=1;i&lt;=la;i++){        if(a[i]&lt;b[i]){            a[i]+=10;            a[i+1]--;        }        c[i]=a[i]-b[i];    }    //去除多余的0,la&gt;1防止去掉全0的情况    while(c[la]==0&amp;&amp;la&gt;1) la--;    for(int i=la;i&gt;=1;i--){        cout&lt;&lt;c[i];    }    }</code></pre><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><pre><code class="cpp">void mul(string a,string b){    la=a.size();    lb=b.size();    //string-&gt;int数组,低位排在前面    for(int i=0;i&lt;la;i++){        a[la-i]=x[i]-&#39;0&#39;;    }    for(int i=0;i&lt;lb;i++){        b[lb-i]=y[i]-&#39;0&#39;;    }    //乘法计算    for(int i=1;i&lt;=la;i++){//从1开始        for(int j=1;j&lt;=lb;j++){            //别忘了+号，同一个结果为是多个乘积叠加的            c[i+j-1]+=a[i]*b[j];            c[i+j]+=c[i+j-1]/10;            c[i+j-1]%=10;        }    }    //计算结果的长度(消去没有用的)，方便打印    lc=la+lb;    while(c[lc]==0&amp;&amp;lc&gt;1){        lc--;    }    //反向输出    for(int i=lc;i&gt;=1;i--){        cout&lt;&lt;c[i];    }}</code></pre><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><pre><code class="cpp">//高精度除单精度string div(string a,int b)//高精度a除以单精度b{    string r,ans;    int d=0;    if(a==&quot;0&quot;) return a;//特判    for(int i=0;i&lt;a.size();i++)    {                        //上一步余数*10相当与此时的被除数            r+=(d*10+a[i]-&#39;0&#39;)/b+&#39;0&#39;;//求出商            d=(d*10+(a[i]-&#39;0&#39;))%b;//求出余数    }    int p=0;    for(int i=0;i&lt;r.size();i++)    if(r[i]!=&#39;0&#39;) {p=i;break;}    return r.substr(p);}int main(){    string a;    int b;    while(cin&gt;&gt;a&gt;&gt;b)    {        cout&lt;&lt;div(a,b)&lt;&lt;endl;    }    return 0;}</code></pre><h2 id="高精度取模"><a href="#高精度取模" class="headerlink" title="高精度取模"></a>高精度取模</h2><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int mod(string a,int b)//高精度a除以单精度b{    int d=0;    for(int i=0;i&lt;a.size();i++)  d=(d*10+(a[i]-&#39;0&#39;))%b;  //求出余数    return d;}int main(){    string a;    int b;    while(cin&gt;&gt;a&gt;&gt;b)    {        cout&lt;&lt;mod(a,b)&lt;&lt;endl;    }    return 0;</code></pre><h2 id="高精度阶乘"><a href="#高精度阶乘" class="headerlink" title="高精度阶乘"></a>高精度阶乘</h2><pre><code class="cpp">const int L=100005;int a[L];string fac(int n){    string ans;    if(n==0) return &quot;1&quot;;    fill(a,a+L,0);    int s=0,m=n;    while(m) a[++s]=m%10,m/=10;    for(int i=n-1;i&gt;=2;i--)    {        int w=0;        for(int j=1;j&lt;=s;j++) a[j]=a[j]*i+w,w=a[j]/10,a[j]=a[j]%10;        while(w) a[++s]=w%10,w/=10;    }    while(!a[s]) s--;    while(s&gt;=1) ans+=a[s--]+&#39;0&#39;;    return ans;}int main(){    int n;    while(cin&gt;&gt;n) cout&lt;&lt;fac(n)&lt;&lt;endl;    return 0;}</code></pre><h2 id="大数进制转换"><a href="#大数进制转换" class="headerlink" title="大数进制转换"></a>大数进制转换</h2><p><img src="https://img-blog.csdnimg.cn/20200416120150116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1020char map[40]=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;int main(){    int m,n,i,j,sum,len,point,answer;    char ans[N],str[N];    int a[N];    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF)    {        memset(ans,0,sizeof(ans));        memset(a,0,sizeof(a));        scanf(&quot;%s&quot;,str);        len=strlen(str);        if(len==1&amp;&amp;str[0]==&#39;0&#39;)        {            printf(&quot;0\n&quot;);            continue;        }        for(i=0;str[i]!=&#39;\0&#39;;i++)        {            if(str[i]&gt;=&#39;A&#39;&amp;&amp;str[i]&lt;=&#39;Z&#39;)                a[i]=str[i]-&#39;A&#39;+10;            else a[i]=str[i]-&#39;0&#39;;        }        j=0;        while(1)        {            answer=0;            for(i=0;i&lt;len;i++)            if(a[i]!=0)            {                answer=1;                break;            }            if(answer==0)            break;            sum=0;            for(i=0;i&lt;len;i++)            {                sum=sum*m+a[i];                sum=sum%n;            }            ans[j++]=map[sum];            point=0;            for(i=0;i&lt;len;i++)            {                a[i]+=point*m;                point=a[i]%n;                a[i]/=n;            }        }        for(j--;j&gt;=0;j--)        printf(&quot;%c&quot;,ans[j]);        printf(&quot;\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>高精度计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS和DFS</title>
    <link href="/2020/04/15/BFS%E5%92%8CDFS/"/>
    <url>/2020/04/15/BFS%E5%92%8CDFS/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="填涂颜色"><a href="#填涂颜色" class="headerlink" title="填涂颜色"></a>填涂颜色</h2><p><strong>题目描述</strong><br>由数字00组成的方阵中，有一任意形状闭合圈，闭合圈由数字11构成，围圈时只走上下左右44个方向。现要求把闭合圈内的所有空间都填写成22.例如：6 \times 66×6的方阵（n=6n=6），涂色前和涂色后的方阵如下：<br><img src="https://img-blog.csdnimg.cn/20200305115131657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>输入格式</strong><br>每组测试数据第一行一个整数n(1≤n≤30)<br>接下来n行，由0和1组成的n×n的方阵。<br>方阵内只有一个闭合圈，圈内至少有一个0。</p><p><strong>输出格式</strong><br>已经填好数字22的完整方阵。</p><p><strong>输入</strong></p><blockquote><p>6<br>0 0 0 0 0 0<br>0 0 1 1 1 1<br>0 1 1 0 0 1<br>1 1 0 0 0 1<br>1 0 0 0 0 1<br>1 1 1 1 1 1</p></blockquote><p><strong>输出</strong></p><blockquote><p>0 0 0 0 0 0<br>0 0 1 1 1 1<br>0 1 1 2 2 1<br>1 1 2 2 2 1<br>1 2 2 2 2 1<br>1 1 1 1 1 1</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int MAXN=100;int Map[MAXN][MAXN];int vis[MAXN][MAXN];//访问标记，为0表示没被访问//能走的四个方向int way[4][2]={{0,1},{0,-1},{1,0},{-1,0}};struct position{    int x,y;    position(int x,int y):x(x),y(y){};};queue&lt;position&gt; q;int main(){    int n;    cin&gt;&gt;n;    //最开始应该在外面再加一圈零(从1开始输入),因为(0,0)这个点若是1就完蛋    //所以要注意遍历初始点的选取    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            cin&gt;&gt;Map[i][j];        }    }    q.push(position(0,0));//初始点进队列    vis[0][0]=1;    while(!q.empty()){        position current=q.front();        for(int i=0;i&lt;4;i++){            //沿着每个方向变化后的横纵坐标            int x=current.x+way[i][0];            int y=current.y+way[i][1];            //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;            //加了Map[x][y]==0的条件，将1围成的圈外部的0全部置已访问            if(x&gt;=0&amp;&amp;x&lt;=n+1&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n+1&amp;&amp;Map[x][y]==0&amp;&amp;vis[x][y]==0){                q.push(position(x,y));                vis[x][y]=1;            }        }        q.pop();    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(Map[i][j]==0&amp;&amp;vis[i][j]==0){                cout&lt;&lt;2&lt;&lt;&quot; &quot;;            }            else  cout&lt;&lt;Map[i][j]&lt;&lt;&quot; &quot;;        }        cout&lt;&lt;endl;    }}</code></pre><h2 id="马的遍历"><a href="#马的遍历" class="headerlink" title="马的遍历"></a>马的遍历</h2><p><strong>题目描述</strong><br>有一个n*m的棋盘(1&lt;n,m&lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步</p><p><strong>输入格式</strong><br>一行四个数据，棋盘的大小和马的坐标</p><p><strong>输出格式</strong><br>一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）</p><p><strong>输入</strong></p><blockquote><p>3 3 1 1</p></blockquote><p><strong>输出</strong></p><blockquote><p>0    3    2<br>3    -1   1<br>2    1    4</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=500;int Map[MAXN][MAXN];int vis[MAXN][MAXN];struct position{    int x,y;    int steps;    position(int x,int y,int steps):x(x),y(y),steps(steps){};};//马跳的8个方向int way[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};queue&lt;position&gt; q;int main(){    int n,m,x1,y1;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x1&gt;&gt;y1;    q.push(position(x1-1,y1-1,0));//初始点    vis[x1-1][y1-1]=1;//这一步别忘了    while(!q.empty()){        position current=q.front();        for(int i=0;i&lt;8;i++){            int x=current.x+way[i][0];            int y=current.y+way[i][1];            if(x&gt;=0&amp;&amp;x&lt;=n-1&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n-1&amp;&amp;vis[x][y]==0){                q.push(position(x,y,current.steps+1));                Map[x][y]=current.steps+1;                vis[x][y]=1;            }        }        q.pop();    }    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            if(vis[i][j]!=0) printf(&quot;%-5d&quot;,Map[i][j]);            else printf(&quot;%-5d&quot;,-1);        }        cout&lt;&lt;endl;    }}</code></pre><h2 id="奇怪的电梯"><a href="#奇怪的电梯" class="headerlink" title="奇怪的电梯"></a>奇怪的电梯</h2><p><strong>题目描述</strong><br>呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第ii层楼(1≤i≤N)上有一个数字Ki(0≤Ki≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3, 3 ,1 ,2 ,5代表了Ki(K1=3,K2=3,…)，从1楼开始。在1楼，按“上”可以到4楼，按“下”是不起作用的，因为没有−2楼。那么，从A楼到B楼至少要按几次按钮呢？</p><p><strong>输入格式</strong><br>共二行。<br>第一行为3个用空格隔开的正整数，表示N,A,B(1≤N≤200, 1≤A,B≤N)。<br>第二行为N个用空格隔开的非负整数，表示Ki</p><p><strong>输出格式</strong><br>一行，即最少按键次数,若无法到达，则输出−1。</p><p>输入</p><blockquote><p>5 1 5<br>3 3 1 2 5</p></blockquote><p>输出</p><blockquote><p>3</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct sta{    int f;    int steps;    sta(int f,int steps):f(f),steps(steps){};};const int MAXN=300;int way[MAXN];//记录可以移动的步数int vis[MAXN];queue&lt;sta&gt; q;int main(){    int n,a,b;//a为起点,b为终点    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;way[i];    }    q.push(sta(a,0));    vis[a]=1;    while(!q.empty()){        sta current=q.front();        //cout&lt;&lt;current.f&lt;&lt;endl;        if(current.f==b){//出口            cout&lt;&lt;current.steps&lt;&lt;endl;            return 0;        }        int down=current.f-way[current.f];//向下        if(down&gt;=1&amp;&amp;vis[down]==0){            q.push(sta(down,current.steps+1));            vis[down]=1;        }        int up=current.f+way[current.f];//向下        if(up&lt;=n&amp;&amp;vis[up]==0){            q.push(sta(up,current.steps+1));            vis[up]=1;        }        q.pop();    }    cout&lt;&lt;-1&lt;&lt;endl;}</code></pre><h2 id="01迷宫"><a href="#01迷宫" class="headerlink" title="01迷宫"></a>01迷宫</h2><p><strong>题目描述</strong><br>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。<br>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p><p><strong>输入格式</strong><br>第1行为两个正整数n,m。<br>下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。<br>接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。</p><p><strong>输出格式</strong><br>m行，对于每个询问输出相应答案。</p><p><strong>输入</strong></p><blockquote><p>2 2<br>01<br>10<br>1 1<br>2 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>4<br>4</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int MAXN=2000;struct position{    int x,y;    position(int x,int y):x(x),y(y){};};int Map[MAXN][MAXN];int vis[MAXN][MAXN];int ans[10000000];//存的是各个颜色区域的结点数int color=0,n,m;int way[4][2]={{0,1},{0,-1},{1,0},{-1,0}};queue&lt;position&gt; q;void bfs(int x1,int y1){    int cnt=0;//用来对当前颜色的区域来计数    q.push(position(x1,y1));    vis[x1][y1]=color;    while(!q.empty()){        position current=q.front();        //cout&lt;&lt;current.x&lt;&lt;&quot; &quot;&lt;&lt;current.y&lt;&lt;endl;        for(int k=0;k&lt;4;k++){            int x=current.x+way[k][0];            int y=current.y+way[k][1];            if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n&amp;&amp;vis[x][y]==0&amp;&amp;Map[x][y]!=Map[current.x][current.y]){                q.push(position(x,y));                vis[x][y]=color;            }        }        cnt++;        q.pop();    }    //cout&lt;&lt;color&lt;&lt;endl;    ans[color]=cnt;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            char c;            cin&gt;&gt;c;            Map[i][j]=c-&#39;0&#39;;            //cout&lt;&lt;Map[i][j]&lt;&lt;endl;        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(vis[i][j]==0){                color++;//每一个color来区分一块互相可以到达的区域                //cout&lt;&lt;color&lt;&lt;endl;                bfs(i,j);//注意函数中不能出现i,j            }        }    }    for(int i=1;i&lt;=m;i++){        int xx,yy;        cin&gt;&gt;xx&gt;&gt;yy;        cout&lt;&lt;ans[vis[xx][yy]]&lt;&lt;endl;    }}</code></pre><h2 id="墙与门"><a href="#墙与门" class="headerlink" title="墙与门"></a>墙与门</h2><p><img src="https://img-blog.csdnimg.cn/20200415115105402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注:这是一道多源bfs的题，将终点看做第0层，然后逐层遍历</p><pre><code class="cpp">int way[4][2]={{1,0},{0,1},{-1,0},{0,-1}};    void wallsAndGates(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) {        int m=rooms.size();        if(m==0) return;        int n=rooms[0].size();        vector&lt;vector&lt;int&gt;&gt; vis(m,vector&lt;int&gt;(n,0));        queue&lt;pair&lt;int,int&gt;&gt; q;        //将第0层的所有结点push进队列        for(int i=0;i&lt;m;i++){            for(int j=0;j&lt;n;j++){                if(rooms[i][j]==0){                    vis[i][j]=1;                    q.push({i,j});                }            }        }        //q一直保存当前层以及下一层的结点(除了在最开始只保存第0层的结点)        int step=0;        while(!q.empty()){            int k=q.size();            step++;            while(k--){                for(int i=0;i&lt;4;i++){                    int xd=q.front().first+way[i][0];                    int yd=q.front().second+way[i][1];                    if(xd&gt;=0&amp;&amp;xd&lt;m&amp;&amp;yd&gt;=0&amp;&amp;yd&lt;n&amp;&amp;vis[xd][yd]==0&amp;&amp;rooms[xd][yd]!=-1){                        vis[xd][yd]=1;                        rooms[xd][yd]=step;                        q.push({xd,yd});                    }                }                q.pop();            }        }    }</code></pre><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p><strong>题目描述</strong><br>一个如下的6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。<br><img src="https://img-blog.csdnimg.cn/20200305121201768.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>上面的布局可以用序列2 4 6 1 3 5 来描述，第 i 个数字表示在第 i 行的相应位置有一个棋子，如下：<br>行号 1 2 3 4 5 6<br>列号 2 4 6 1 3 5<br>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br>并把它们以上面的序列方法输出，解按字典顺序排列。<br>请输出前 3 个解。最后一行是解的总个数。</p><p><strong>输入格式</strong><br>一行一个正整数 nn，表示棋盘是 n \times nn×n 大小的。</p><p><strong>输出格式</strong><br>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。</p><p><strong>输入</strong></p><blockquote><p>6</p></blockquote><p><strong>输出</strong></p><blockquote><p>2 4 6 1 3 5<br>3 6 2 5 1 4<br>4 1 5 2 6 3<br>4</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int ans[13];//作为每次深搜出来的序列的结果int vis[13];int u[40];//正对角线int v[40];//副对角线int n;int Count=0;void print(){    for(int i=1;i&lt;=n;i++){        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;    }    cout&lt;&lt;endl;}void dfs(int x){//dfs中的参数是行号    if(x&gt;n){        Count++;        if(Count&lt;=3) print();        return ;    }    for(int i=1;i&lt;=n;i++){//i表示尝试列号        if(!vis[i]&amp;&amp;!u[x-i+n]&amp;&amp;!v[x+i]){//vis能保证不在同一列,u表示不在同一主对角(+n为了不为负数),v表示不在同一副对角            //i-ans[j]为列差,x-j为行差            vis[i]=1;            u[x-i+n]=1;            v[x+i]=1;            ans[x]=i;            dfs(x+1);            //为了回溯            vis[i]=0;            u[x-i+n]=0;            v[x+i]=0;        }    }}int main(){    cin&gt;&gt;n;    dfs(1);    cout&lt;&lt;Count&lt;&lt;endl;}</code></pre><h2 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h2><p><strong>题目背景</strong><br>给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p><p><strong>题目描述</strong><br>无</p><p><strong>输入格式</strong><br>第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。</p><p><strong>输出格式</strong><br>给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。</p><p><strong>输入</strong></p><blockquote><p>2 2 1<br>1 1 2 2<br>1 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>1</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;using namespace std;int n,m,t,sx,sy,fx,fy,Count=0;int Map[10][10];//相当于vis数组int way[4][2]={{0,1},{0,-1},{1,0},{-1,0}};void dfs(int x,int y){    if(x==fx&amp;&amp;y==fy){        Count++;        return;    }    for(int i=0;i&lt;4;i++){        int dx=x+way[i][0];        int dy=y+way[i][1];        if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=n&amp;&amp;!Map[dx][dy]){            Map[dx][dy]=1;            dfs(dx,dy);            Map[dx][dy]=0;        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;    while(t--){        int x,y;        cin&gt;&gt;x&gt;&gt;y;        Map[x][y]=1;    }    Map[sx][sy]=1;    dfs(sx,sy);    cout&lt;&lt;Count&lt;&lt;endl;}</code></pre><h2 id="单词方阵"><a href="#单词方阵" class="headerlink" title="单词方阵"></a>单词方阵</h2><p><strong>题目描述</strong><br>给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：<br><img src="https://img-blog.csdnimg.cn/20200305121648322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>输入格式<br>第一行输入一个数nn。(7 \le n \le 1007≤n≤100)。</p><p>第二行开始输入n \times nn×n的字母矩阵。</p><p>输出格式<br>突出显示单词的n \times nn×n矩阵。</p><p><strong>输入</strong></p><blockquote><p>8<br>qyizhong<br>gydthkjy<br>nwidghji<br>orbzsfgz<br>hhgrhwth<br>zzzzzozo<br>iwdfrgng<br>yyyygggg</p></blockquote><p><strong>输出</strong></p><blockquote><p><em>yizhong<br>gy<strong>**</strong><br>n<em>i****</em><br>o<strong>z**</strong><br>h<strong><em>h</em></strong><br>z<strong>**o</strong><br>i*****n</em><br>y<strong>**</strong>g</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;using namespace std;char Map[300][300];int vis[300][300];int way[8][2]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};string yz=&quot;yizhong&quot;;//是从i开始比较int n;void dfs(int x,int y){    for(int i=0;i&lt;8;i++){//8个方向        bool flag=true;        for(int j=1;j&lt;=6;j++){//需要比较的6，也相当于走的步数            int dx=x+j*way[i][0];            int dy=y+j*way[i][1];            if(!(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=n)||yz[j]!=Map[dx][dy]){                flag=false;            }        }        if(flag){            for(int j=0;j&lt;7;j++){                int dx=x+j*way[i][0];                int dy=y+j*way[i][1];                vis[dx][dy]=1;            }        }    }}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            cin&gt;&gt;Map[i][j];        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(Map[i][j]==&#39;y&#39;){                dfs(i,j);            }        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(vis[i][j]==1) cout&lt;&lt;Map[i][j];            else cout&lt;&lt;&#39;*&#39;;        }        cout&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>BFS和DFS最终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="/2020/04/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2020/04/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2><p>1、删除的结点无左右子节点，那么直接将其父节点指向NULL；<br>2、删除的结点只有1个子节点，分左右两种情况，直接将其父节点指向删除节点的子节点；<br>3、删除节点有2个子节点，这是最麻烦的情况了，最好是画个图理解，具体而言：</p><pre><code class="cpp">    TreeNode* deleteNode(TreeNode* root, int key) {        if(root==NULL) return NULL;        if(root-&gt;val==key){            //情况一和情况二            if(root-&gt;left==NULL) return root-&gt;right;            if(root-&gt;right==NULL) return root-&gt;left;            //情况三:此时需要找到最近的一个大于当前结点值的元素            TreeNode* RminNode=FindMin(root-&gt;right);            root-&gt;val=RminNode-&gt;val;            root-&gt;right=deleteNode(root-&gt;right,RminNode-&gt;val);        }        else if(key&lt;root-&gt;val){            root-&gt;left=deleteNode(root-&gt;left,key);        }        else if(key&gt;root-&gt;val){            root-&gt;right=deleteNode(root-&gt;right,key);        }        return root;    }    TreeNode* FindMin(TreeNode* root){        if(root-&gt;left) return FindMin(root-&gt;left);        else return root;    }};</code></pre><h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>利用中序求出有序的序列，然后基于这个序列来找</p><pre><code class="cpp">int Max_time=0,Max_number,n=0;    vector&lt;int&gt; v;    map&lt;int,int&gt; m;    vector&lt;int&gt; findMode(TreeNode* root) {        InOrder(root);        map&lt;int,int&gt;::iterator it;        for(it=m.begin();it!=m.end();it++){            if(it-&gt;second&gt;Max_time){                Max_time=it-&gt;second;                Max_number=it-&gt;first;            }        }        for(it=m.begin();it!=m.end();it++){            if(it-&gt;second==Max_time){                v.push_back(it-&gt;first);            }        }        return v;    }    void InOrder(TreeNode* root){        if(root==NULL) return ;        InOrder(root-&gt;left);        if(m.find(root-&gt;val)!=m.end()) m[root-&gt;val]++;//已经存在map中了        else m.insert(pair&lt;int,int&gt;(root-&gt;val,1));        InOrder(root-&gt;right);    }</code></pre><h2 id="根据二叉树创建字符串"><a href="#根据二叉树创建字符串" class="headerlink" title="根据二叉树创建字符串"></a>根据二叉树创建字符串</h2><p><img src="https://img-blog.csdnimg.cn/20200413160034387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>利用先序遍历，注意下按照递归的思想去加括号，注意只有右子树存在也要加两对括号</p><pre><code class="cpp">    string ans=&quot;&quot;;    string tree2str(TreeNode* t) {        PreOrder(t);        return ans;    }    void PreOrder(TreeNode* root){//pos代表当前根结点的位置        if(root==NULL) return;        ostringstream os;        os&lt;&lt;root-&gt;val;        ans+=os.str();        if(root-&gt;right){//右子树存在，则左右都要有括号            ans+=&#39;(&#39;;            PreOrder(root-&gt;left);            ans+=&#39;)&#39;;            ans+=&#39;(&#39;;            PreOrder(root-&gt;right);            ans+=&#39;)&#39;;        }        else if(root-&gt;left){//只有左子树存在,右子树的括号不用写            ans+=&#39;(&#39;;            PreOrder(root-&gt;left);            ans+=&#39;)&#39;;        }    }</code></pre><h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><p><img src="https://img-blog.csdnimg.cn/20200413163023186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>就是一个计算和的递归就行，很简单</p><pre><code class="cpp">    int ans=0;    int findTilt(TreeNode* root) {        SumTree(root);        return ans;    }    int SumTree(TreeNode* root){        if(root==NULL) return 0;        int lsum=SumTree(root-&gt;left);        int rsum=SumTree(root-&gt;right);        ans+=abs(lsum-rsum);        return root-&gt;val+lsum+rsum;    }</code></pre><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p><img src="https://img-blog.csdnimg.cn/20200413163829449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>用双指针(left,right)+递归实现,注意传参的类型！！</p><pre><code class="cpp">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {        return solve(nums.begin(),nums.end());    }    TreeNode* solve(vector&lt;int&gt;::iterator left, vector&lt;int&gt;::iterator right){        if(left == right) return NULL;        auto it = max_element(left,right);        TreeNode* node = new TreeNode(*it);        node-&gt;left = solve(left,it);        node-&gt;right = solve(it+1,right);        return node;    }</code></pre><h2 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h2><p><img src="https://img-blog.csdnimg.cn/20200413172420264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这里递归就是先拆分，得到最底层的值后再合并，<br>拆分就是分成左右子树，最终就是start&gt;end 返回{NULL}。<br>合并的时候要用两个for循环来实现不同的排列。。。<br>注:若只是求种数，可以用卡塔兰数计算<br><img src="https://img-blog.csdnimg.cn/2020041317455984.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">vector&lt;TreeNode*&gt; generateTrees(int n) {        vector&lt;TreeNode*&gt; res;        if(n==0) return res;        return generateTreesCore(1, n);    }    vector&lt;TreeNode*&gt; generateTreesCore(int start, int end){        vector&lt;TreeNode*&gt; res;        if(start&gt;end){            return {NULL};        }        else{            for(int i = start;i&lt;=end;++i){//表示以i为节点构建树                vector&lt;TreeNode*&gt; left = generateTreesCore(start, i-1);//构建左子树                vector&lt;TreeNode*&gt; right = generateTreesCore(i+1, end);//构建右子树                //此时左右子树都有值.要把他们合并在一起。                for(auto r: right){                    for(auto l: left){                        TreeNode* temp = new TreeNode(i);//把每个节点构建出来。                        temp-&gt;left = l;                        temp-&gt;right = r;                        res.push_back(temp);                    }                }            }        }        return res;    }</code></pre><h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h2><p><img src="https://img-blog.csdnimg.cn/20200413175800603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">     vector&lt;int&gt; order;    void recoverTree(TreeNode* root) {        InOrder(root);        //先得到正确的序列        sort(order.begin(),order.end());        recover(root,order);    }    void InOrder(TreeNode* root){        if(root==NULL) return ;        InOrder(root-&gt;left);        order.push_back(root-&gt;val);        InOrder(root-&gt;right);    }    void recover(TreeNode* root,vector&lt;int&gt;&amp; rec){        if(root ==NULL){            return;        }        recover(root-&gt;left,rec);        //        if(root-&gt;val == rec[0]){            rec.erase(rec.begin());        }else{            //若不同则修改为相同            root-&gt;val = rec[0];            rec.erase(rec.begin());        };        recover(root-&gt;right,rec);    }</code></pre><h2 id="二叉树的锯齿形层次遍历"><a href="#二叉树的锯齿形层次遍历" class="headerlink" title="二叉树的锯齿形层次遍历"></a>二叉树的锯齿形层次遍历</h2><pre><code class="cpp">//q1记录正序，q2记录反序    queue&lt;TreeNode*&gt; q1;    queue&lt;TreeNode*&gt; q2;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {        if(root==NULL) return ans;        q1.push(root);        q2.push(root);        TreeNode* pre_last1=root;        TreeNode* last1=root;        TreeNode* pre_last2=root;        TreeNode* last2=root;        int level=0;        vector&lt;int&gt; temp;        while(!q1.empty()&amp;&amp;!q2.empty()){            TreeNode* p1=q1.front();            q1.pop();            TreeNode* p2=q2.front();            q2.pop();            if(p1-&gt;left){                last1=p1-&gt;left;                q1.push(p1-&gt;left);            }            if(p1-&gt;right){                last1=p1-&gt;right;                q1.push(p1-&gt;right);            }            if(p2-&gt;right){                last2=p2-&gt;right;                q2.push(p2-&gt;right);            }            if(p2-&gt;left){                last2=p2-&gt;left;                q2.push(p2-&gt;left);            }            if(level==0) temp.push_back(p1-&gt;val);            else temp.push_back(p2-&gt;val);            //两个同时到达当前行的最后一个            if(p1==pre_last1){                pre_last1=last1;                pre_last2=last2;                if(level==0){                    ans.push_back(temp);                    temp.clear();                    level=1;                }                else{                    ans.push_back(temp);                    temp.clear();                    level=1-level;                }            }        }        return ans;    }</code></pre><h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p><img src="https://img-blog.csdnimg.cn/20200413200247524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">    int target;    bool flag=false;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {        if(root==NULL) return ans;        target=sum;        vector&lt;int&gt; temp;        temp.push_back(root-&gt;val);        dfs(root,0,temp);        return ans;    }    void dfs(TreeNode* root,int sum,vector&lt;int&gt;&amp; temp){        int cur_sum=sum+root-&gt;val;        //cout&lt;&lt;cur_sum&lt;&lt;endl;        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL){            if(sum+root-&gt;val==target){                ans.push_back(temp);                flag=true;                return ;            }        }            if(root-&gt;left){                temp.push_back(root-&gt;left-&gt;val);                dfs(root-&gt;left,cur_sum,temp);                temp.pop_back();            }            if(root-&gt;right){                temp.push_back(root-&gt;right-&gt;val);                dfs(root-&gt;right,cur_sum,temp);                temp.pop_back();            }    }</code></pre><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p><img src="https://img-blog.csdnimg.cn/20200413200600549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">public:    int maxh;    int maxPathSum(TreeNode* root) {        //if(root==NULL) return 0;        maxh=root-&gt;val;        max_path(root);        return maxh;    }    int max_path(TreeNode* root){        if(root==NULL) return 0;        int cur=root-&gt;val;        int l=max_path(root-&gt;left)+cur;        int r=max_path(root-&gt;right)+cur;        //cout&lt;&lt;&quot;root&quot;&lt;&lt;root-&gt;val&lt;&lt;endl;        //cout&lt;&lt;&quot;left:&quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;&quot;right&quot;&lt;&lt;r&lt;&lt;endl;        if(l&gt;maxh) maxh=l;        if(r&gt;maxh) maxh=r;        if(l+r-cur&gt;maxh) maxh=l+r-cur;        //加上这个是因为有的防止每次计算最大路径都必须包括叶结点(对于已经小于0的分支可以直接抛弃)        if(l&lt;0&amp;&amp;r&lt;0) return 0;        else return max(l,r);    }</code></pre><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><img src="https://img-blog.csdnimg.cn/20200413201038318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">/*两个节点p,q分为两种情况：p和q在相同子树中p和q在不同子树中从根节点遍历，递归向左右子树查询节点信息递归终止条件：如果当前节点为空或等于p或q，则返回当前节点递归遍历左右子树，如果左右子树查到节点都不为空，则表明p和q分别在左右子树中，因此，当前节点即为最近公共祖先；如果左右子树其中一个不为空，则返回非空节点。*/    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        if(root==NULL||root==p||root==q) return root;         TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q);        TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q);        if(left&amp;&amp;right) return root;        if(left==NULL) return right;        else return left;    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>max_element和min_element</title>
    <link href="/2020/04/13/max_element%E5%92%8Cmin_element/"/>
    <url>/2020/04/13/max_element%E5%92%8Cmin_element/</url>
    
    <content type="html"><![CDATA[<p>auto min_values=min_element(v.begin(),v.end())<br>auto max_values=max_element(v.begin(),v.end())<br>会分别返回一个指向输入序列的最小元素以及最大元素的迭代器(里面存的是对应的物理地址)；<br>1.取 * 可以去除具体的最大以及最小值<br>2.不取 * 减去起始地址就能知道索引的位置</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){int n[]={1,4,5,7,22,3,8,5};int len=sizeof(n)/sizeof(int);//返回索引cout&lt;&lt;max_element(n,n+len)-n&lt;&lt;endl;//返回值cout&lt;&lt;*max_element(n,n+len)&lt;&lt;endl;return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换函数(atoi系列&amp;&amp;stringstream)</title>
    <link href="/2020/04/13/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <url>/2020/04/13/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="atoi，atol，atof-amp-amp-c-str"><a href="#atoi，atol，atof-amp-amp-c-str" class="headerlink" title="(atoi，atol，atof)&amp;&amp;c_str()"></a>(atoi，atol，atof)&amp;&amp;c_str()</h2><p>atoi:  char* → int<br>atol: char* → long<br>atof: char* → double<br>注意要用c_str将string转化成c语言中的char*类型</p><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>具体来说就是C++标准库中的<sstream>提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，即单纯性、类型安全和可扩展性。在本文中，我将展示怎样使用这些库来实现安全和自动的类型转换。还有是如果你打算在多次转换中使用同一个stringstream对象，记住再每次转换前要使用clear()方法。下面就是我的一个小实验。</p><pre><code class="cpp">#include &quot;stdafx.h&quot;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;/************************************************************************//* 使用stringstream对象简化类型转换                                     *//*C++标准库中的&lt;sstream&gt;提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，     *//*即单纯性、类型安全和可扩展性。在本文中，我将展示怎样使用这些库来实现  *//*安全和自动的类型转换。                                                *//*如果你打算在多次转换中使用同一个stringstream对象，                    *//*记住再每次转换前要使用clear()方法；                                   *//************************************************************************/int _tmain(int argc, _TCHAR* argv[]){    //stringstream通常是用来做数据转换的。    //1.int 与 string的转换    std::stringstream m_sstream;    std::string result;    int i=1000;    m_sstream&lt;&lt;i;    m_sstream&gt;&gt;result;    std::cout&lt;&lt;result&lt;&lt;&quot;\n&quot;;     //2.int 与 char[]的转换    m_sstream.clear();    char res[8];    m_sstream&lt;&lt;8888;    m_sstream&gt;&gt;res;    std::cout&lt;&lt;res&lt;&lt;&quot;\n&quot;;     //3.string 与 int的转换(并且可以按照空格进行读取)    m_sstream.clear();    int first,second;    m_sstream&lt;&lt;&quot;666&quot;;    m_sstream&gt;&gt;first;    std::cout&lt;&lt;first&lt;&lt;std::endl;     //4.bool 与 int的转换    m_sstream.clear();    m_sstream&lt;&lt;true;    m_sstream&gt;&gt;second;    std::cout&lt;&lt;second&lt;&lt;std::endl;    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP模板</title>
    <link href="/2020/03/23/KMP%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/03/23/KMP%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>KMP是一种字符串匹配算法，可以求出一个字符串在另一个字符串中出现的次数。时间复杂度为O(N+M)</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>算法分为预处理next数组和查询两步进行。</p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>next数组表示从起始位置到当前位置最长的前缀和后缀的长度<br>那么，在处理时，我们就拿当前位置和原来匹配的最长前缀的后一位比较：</p><p>如果相同，那么长度+1,next[j−1]+1</p><p>如果不相同，那么根据此数组的性质，显而易见，你的相等的部分只能向前找也就是说，你的这个位置的next值会减小也就是去原来的最长相等前缀去找<br>所以，我们可以得到next数组的求解方法：每一次检查上一次最长前缀的后一个位置如果相等则next[j]=next[i]+1,否则令i=next[i−1]+1，继续循环匹配<br>其实这就是自己匹配自己的过程。这是最难理解的地方，多手算几遍就好了</p><h3 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h3><p>本算法难在于next预处理，如果你已经懂了，就很简单了<br>我们设定两个指针i，j，指向两个字符串。<br>如果i==j那么i++，j++如果失配，就令i=next[i−1]+1</p><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;char str1[1000005],str2[1000005];//str1是被匹配字符串，str2是匹配字符串int Next[1000005];vector &lt;int&gt; Ans;inline void init(char *str){ //计算next数组    int len,t;    len = strlen(str);    Next[0] = -1;    for(int i = 1;i &lt; len;i++){        t = Next[i-1];        while(str[t+1] != str[i] &amp;&amp; t &gt;= 0)            t = Next[t];        if(str[t+1] == str[i])            Next[i] = t+1;        else            Next[i] = -1;    }}void kmp(char *str1,char *str2){ //kmp查找    init(str2);    int len1 = strlen(str1);    int len2 = strlen(str2);    int i = 0,j = 0;    while(j &lt; len1){        if(str2[i] == str1[j]){  //相同            i++;j++;            if(i == len2){                Ans.push_back(j-len2+1);                i = Next[i-1]+1;            }        }        else{  //失配，根据next数组寻找下一个位置            if(i == 0)                j++;            else                i = Next[i-1] + 1;        }    }}int main(){    cin &gt;&gt; str1 &gt;&gt; str2;    int l = strlen(str2);    kmp(str1,str2);    for(int i = 0;i &lt; Ans.size();i++)        printf(&quot;%d%c&quot;,Ans[i],&#39;\n&#39;);    for(int i = 0;i &lt; l;i++){ //洛谷题目需要的输出next数组        printf(&quot;%d &quot;,Next[i] + 1);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>KMP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs技巧与优化</title>
    <link href="/2020/03/21/%E6%B7%B1%E6%90%9C%E6%8A%80%E5%B7%A7%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2020/03/21/%E6%B7%B1%E6%90%9C%E6%8A%80%E5%B7%A7%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一-DFS的实现"><a href="#一-DFS的实现" class="headerlink" title="一. DFS的实现"></a>一. DFS的实现</h1><pre><code class="cpp">int dfs(int t){    if(满足输出条件) //dfs出口    {        输出解;    }    else    {        for(int i=1;i&lt;=尝试方法数;i++)            if(满足进一步搜索条件)            {                为进一步搜索所需要的状态打上标记; //记忆化                dfs(t+1);                恢复到打标记前的状态; //也就是说：回溯一步            }    }}</code></pre><p><strong>【需要注意的地方】</strong><br>1.第一个if是符合输出解的条件，第二个if是符合进一步搜索的条件。</p><p>2.下一步搜索时，不是使用return search(t+1)，直接search(t+1)。</p><p>3.for循环之后的if可以是多个。</p><p>4.for循环边界，例如：</p><p>方向是四个，那么边界肯定就是4；（注意，数组一般从0开始）<br>素数环需要尝试1至20，那么边界就是20。</p><h1 id="二-剪枝技巧的实现"><a href="#二-剪枝技巧的实现" class="headerlink" title="二. 剪枝技巧的实现"></a>二. 剪枝技巧的实现</h1><h2 id="1-可行性剪枝。"><a href="#1-可行性剪枝。" class="headerlink" title="1.可行性剪枝。"></a>1.可行性剪枝。</h2><p>如果当前条件不合法就不再继续搜索，直接return。又称“上下界剪枝”，一般的搜索都会加上。</p><pre><code class="cpp">dfs(int x){    if(x&gt;n)return;    if(!check1(x))return;    ....    return;}</code></pre><h2 id="2-最优性剪枝。"><a href="#2-最优性剪枝。" class="headerlink" title="2.最优性剪枝。"></a>2.最优性剪枝。</h2><p> 如果当前条件所花费的代价已经超过了当前搜到的最优解，那么剩下的搜索就可以剪掉。</p><p>我们利用某个函数估计出此时条件下答案的当前最值，继续下一步判断。</p><pre><code class="cpp">long long ans=987474477434487ll;... Dfs(int x,...){    if(x... &amp;&amp; ...){ ans=....; return ...;}    if(check2(x)&gt;=ans) return ...;    //最优性剪枝     for(int i=1;...;++i){        vis[...]=1;         dfs(...);        vis[...]=0;    }}</code></pre><p>一般实现：在搜索取和最大值时，如果后面的全部取最大仍然不比当前答案大就可以返回。</p><p>在搜和最小时同理，可以预处理后缀最大/最小和进行快速查询。</p><h2 id="3-记忆化搜索。"><a href="#3-记忆化搜索。" class="headerlink" title="3.记忆化搜索。"></a>3.记忆化搜索。</h2><p>如果对于相同情况下必定答案相同，就可以把这个情况的答案值存储下来，以后再次搜到可以直接调用。</p><p>注意不能搜出环来，不同情况间不能互相依赖。或者是排除等效冗余的情况。</p><pre><code class="cpp">long long ans=987474477434487ll;... Dfs(int x,...){        if(x... &amp;&amp; ...){ ans=....; return ...;}        if(vis[x]!=0) return f[x]; vis[x]=1; //记忆化剪枝        for(int i=1;...;++i){            vis[...]=1;             dfs(...);            vis[...]=0;            f[x]=...;        }}</code></pre><h2 id="4-搜索顺序剪枝"><a href="#4-搜索顺序剪枝" class="headerlink" title="4.搜索顺序剪枝"></a>4.搜索顺序剪枝</h2><p>在一些迷宫题，网格题，或者其他搜索中可以贪心的题，搜索顺序显得十分重要。</p><p>在迷宫、网格类的题目中，以左上-&gt;右下为例，右下左上就明显比左上右下优秀。</p><p>在一些推断搜索题中，从已知信息最多的地方开始搜索显然更加优秀。</p><p>在一些题中，先搜某个值大的，再搜某个值小的(比如树的度数，产生答案的预计(A*))，速度明显更快。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="codevs1288-埃及分数"><a href="#codevs1288-埃及分数" class="headerlink" title="codevs1288 埃及分数"></a>codevs1288 埃及分数</h2><p>在古埃及，人们使用单位分数的和(形如1/a的, a是自然数)表示一切有理数。</p><p>如：2/3=1/2+1/6,但不允许2/3=1/3+1/3,因为加数中有相同的。</p><p>对于一个分数a/b,表示方法有很多种，但是哪种最好呢？</p><p>首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越 好。</p><p>如：19/45=1/3 + 1/12 + 1/180 19/45=1/3 + 1/15 + 1/45 19/45=1/3 + 1/18 + 1/30,</p><p>19/45=1/4 + 1/6 + 1/180 19/45=1/5 + 1/6 + 1/18. 最好的是最后一种，因为1/18最大。</p><p>给出a,b(0&lt;a&lt;b&lt;1000),编程计算最好的表达方式。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define LL long long intusing namespace std;LL a,b,depth,FLAG=1,zZ[101010],Ans[101010],Maxx=10101000;LL gcd(LL a,LL b){return b&gt;0?gcd(b,a%b):a;} //辗转相除法求最大公约数 void dfs(LL now,LL a,LL b,LL last,LL depth){    if(now==depth-1){        if(a!=1)return;        if(b&lt;Maxx &amp;&amp; b&gt;last){                zZ[now+1]=b;FLAG=0;Maxx=b;                for(LL i=1;i&lt;=now+1;++i){Ans[i]=zZ[i];}        }        return;    }    if(a*(last+1)&gt;=b*(depth-now) || last&gt;Maxx || a==0)return; //第一个是可行性剪枝，是个十字相乘式，建议移项看    for(LL i=last+1,K=(depth-now)*b/a;i&lt;K;++i)    {        LL newa=a*i-b,newb=b*i,G=gcd(newb,newa);        newa/=G,newb/=G;zZ[now+1]=i;        dfs(now+1,newa,newb,i,depth);zZ[now+1]=0;    }}int main() {    scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);    if(a==1){printf(&quot;%lld&quot;,b);return 0;}    for(int i=2;FLAG;++i)dfs(0,a,b,(b/a),i);                        //迭代搜索，i为深度     for(int i=1;Ans[i]!=0;++i)printf(&quot;%lld &quot;,Ans[i]);    return 0;}</code></pre><p>这道题可行性和最优性剪枝都要加，最后一个是因为要除a，是零就得剪掉。搜索顺序是按分母从小到大枚举的。</p><h2 id="poj1011-Sticks"><a href="#poj1011-Sticks" class="headerlink" title="poj1011 Sticks"></a>poj1011 Sticks</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;/*【Sticks】题意：给出n根小棒的长度stick[i]，已知这n根小棒原本由若干根长度相同的长木棒（原棒）分解而来。求出原棒的最小可能长度。思路：dfs+剪枝。蛮经典的题目，重点在于dfs剪枝的设计。先说先具体的实现：求出总长度sum和小棒最长的长度max，则原棒可能的长度必在max~sum之间，然后从小到大枚举max~sum之间能被sum整除的长度len，用dfs求出所有的小棒能否拼凑成这个长度，如果可以，第一个len就是答案。下面就是关键的了，就是这道题dfs的实现和剪枝的设计：1.以一个小棒为开头，用dfs看看能否把这个小棒拼凑成len长，用vis[i]记录下用过的小棒，然后继续以另外一个小棒为开头，以此类推。2.小棒的长度从大到小排序。3.如果当前最长的小棒不能拼成len长，那么就返回前一步,不用再继续搜索这一种情况。4.最重要的，就是比如说17,9,9,9,9,8,8,5,2……17与第一个9组合之后dfs发现不能拼成len，那么17就不和后面9组合了，而直接和8开始组合。  */const int Max = 65;int n, len, stick[Max];bool flag, vis[Max];bool cmp(int a,int b) { return a&gt;b; }void dfs(int dep, int now_len, int u){   // dep为当前已被用过的小棒数，u为当前要处理的小棒。    if(flag) return;    if(now_len == 0){   //  当前长度为0，寻找下一个当前最长小棒。        int k = 0;        while(vis[k]) k ++;  //  寻找第一个当前最长小棒。        vis[k] = true;        dfs(dep + 1, stick[k], k + 1);        vis[k] = false;        return;    }    if(now_len == len){  //  当前长度为len，即又拼凑成了一根原棒。        if(dep == n) flag = true;   //  完成的标志：所有的n根小棒都有拼到了。        else dfs(dep, 0, 0);        return;    }    for(int i = u; i &lt; n; i ++)        if(!vis[i] &amp;&amp; now_len + stick[i] &lt;= len){            if(!vis[i-1] &amp;&amp; stick[i] == stick[i-1]) continue;  //  不重复搜索：最重要的剪枝。            vis[i] = true;            dfs(dep + 1, now_len + stick[i], i + 1);            vis[i] = false;        }}int main(){    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n != 0){        int sum = 0;        flag = false;        for(int i = 0; i &lt; n; i ++){            scanf(&quot;%d&quot;, &amp;stick[i]);            sum += stick[i];        }        sort(stick,stick+n,cmp); //从大到小排序。        for(len = stick[0]; len &lt; sum; len ++)            if(sum % len == 0){  //  枚举能被sum整除的长度。                memset(vis, 0, sizeof(vis));                dfs(0, 0, 0);                if(flag) break;            }        printf(&quot;%d\n&quot;, len);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>dfs优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中缀转后缀与后缀表达式计算</title>
    <link href="/2020/03/12/%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/03/12/%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="中缀表达式直接计算-带括号"><a href="#中缀表达式直接计算-带括号" class="headerlink" title="中缀表达式直接计算(带括号)"></a>中缀表达式直接计算(带括号)</h2><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;//中缀表达式求值string mid;stack&lt;double&gt; data_stack;stack&lt;char&gt; op_stack;int Priority(char op){    if(op==&#39;+&#39;||op==&#39;-&#39;) return 1;    else if(op==&#39;*&#39;||op==&#39;/&#39;) return 2;    else if(op==&#39;(&#39;) return 0;//注意}double Calculate(double a,double b,char op){    if(op==&#39;+&#39;) return a+b;    else if(op==&#39;-&#39;) return a-b;    else if(op==&#39;*&#39;) return a*b;    else if(op==&#39;/&#39;) return a/b;}double getNumber(string str,int&amp; pos){//pos是共享的    double ans=0.0;    while(isdigit(str[pos])){        ans=ans*10+(double)(str[pos++]-&#39;0&#39;);    }    pos--;    return ans;}//1+2*3int main(){    cin&gt;&gt;mid;    for(int i=0;i&lt;mid.size();i++){        if(isdigit(mid[i])){            //cout&lt;&lt;(double)(mid[i]-&#39;0&#39;)&lt;&lt;endl;            //cout&lt;&lt;&quot;data &quot;&lt;&lt;data_stack.size()&lt;&lt;endl;            double number=getNumber(mid,i);            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;number&lt;&lt;endl;            data_stack.push(number);        }        else if(mid[i]==&#39;(&#39;){            op_stack.push(mid[i]);        }        else if(mid[i]==&#39;)&#39;){            while(op_stack.top()!=&#39;(&#39;){                char op=op_stack.top();  op_stack.pop();                double b=data_stack.top(); data_stack.pop();                double a=data_stack.top(); data_stack.pop();                double temp=Calculate(a,b,op);                data_stack.push(temp);            }            op_stack.pop();        }        else{            //cout&lt;&lt;&quot;op &quot;&lt;&lt;mid[i]&lt;&lt;endl;            while((!op_stack.empty())&amp;&amp;Priority(op_stack.top())&gt;=Priority(mid[i])){//顺序不能变，一定是先判栈空                char op=op_stack.top();  op_stack.pop();                double b=data_stack.top(); data_stack.pop();                double a=data_stack.top(); data_stack.pop();                double temp=Calculate(a,b,op);                //cout&lt;&lt;a&lt;&lt;op&lt;&lt;b&lt;&lt;&quot;结果&quot;&lt;&lt;temp&lt;&lt;endl;                data_stack.push(temp);            }            op_stack.push(mid[i]);        }    }    while(!op_stack.empty()){//别忘了将op清空        char op=op_stack.top();  op_stack.pop();        double b=data_stack.top(); data_stack.pop();        double a=data_stack.top(); data_stack.pop();        double temp=Calculate(a,b,op);        data_stack.push(temp);    }    cout&lt;&lt;data_stack.top()&lt;&lt;endl;}</code></pre><h2 id="中缀转后缀与后缀表达式计算-带括号"><a href="#中缀转后缀与后缀表达式计算-带括号" class="headerlink" title="中缀转后缀与后缀表达式计算(带括号)"></a>中缀转后缀与后缀表达式计算(带括号)</h2><p>PS:后缀表达式中两两之间一定要用空格隔开，不然getNumber函数就不起作用了</p><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;//中缀转后缀+后缀求值string post=&quot;&quot;,mid;stack&lt;char&gt; op_stack;stack&lt;double&gt; data_stack;int Priority(char op){    if(op==&#39;+&#39;||op==&#39;-&#39;) return 1;    else if(op==&#39;*&#39;||op==&#39;/&#39;) return 2;    else if(op==&#39;(&#39;) return 0;}double Calculate(double a,double b,char op){    if(op==&#39;+&#39;) return a+b;    else if(op==&#39;-&#39;) return a-b;    else if(op==&#39;*&#39;) return a*b;    else if(op==&#39;/&#39;) return a/b;}double getNumber(string str,int&amp; pos){//pos是共享的    double ans=0.0;    while(isdigit(str[pos])){        ans=ans*10+(double)(str[pos++]-&#39;0&#39;);    }    pos--;//不然会越过一个位置    return ans;}//9+(3-1)*3+10/2，转换的话不会用到getnumber得到多位的整数void Transform(){    for(int i=0;i&lt;mid.size();i++){        //cout&lt;&lt;post&lt;&lt;endl;        if(isdigit(mid[i])){//这里得到完整数直接写就行!!!            while(isdigit(mid[i])){                post=post+mid[i++];            }            i--;//不然会把下一个覆盖掉            post=post+&quot; &quot;;        }        else if(mid[i]==&#39; &#39;){            continue;        }        else if(mid[i]==&#39;(&#39;){            op_stack.push(mid[i]);        }        else if(mid[i]==&#39;)&#39;){            while(op_stack.top()!=&#39;(&#39;){                char op=op_stack.top();                op_stack.pop();                post=post+op+&quot; &quot;;            }            op_stack.pop();//将&#39;(&#39;pop出来        }        else{//为操作符            //cout&lt;&lt;&quot;操作符 &quot;&lt;&lt;mid[i]&lt;&lt;endl;            if(op_stack.empty()){                op_stack.push(mid[i]);                continue;            }            else{                //别忘了判栈空                while(!op_stack.empty()&amp;&amp;Priority(op_stack.top())&gt;=Priority(mid[i])){                    //cout&lt;&lt;op_stack.top()&lt;&lt;&quot;pop 出来&quot;&lt;&lt;endl;                    char op=op_stack.top();                    op_stack.pop();                    post=post+op+&quot; &quot;;                }                op_stack.push(mid[i]);            }        }    }    while(!op_stack.empty()){        char op=op_stack.top();        op_stack.pop();        post=post+op;    }}int  main(){    cin&gt;&gt;mid;    Transform();    cout&lt;&lt;&quot;后缀表达式:&quot;&lt;&lt;post&lt;&lt;endl;    for(int pos=0;pos&lt;post.size();pos++){        if(isdigit(post[pos])){            double number=getNumber(post,pos);            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;number;            data_stack.push(number);        }        else if(post[pos]==&#39; &#39;) continue;        else{            char op=post[pos];            double b=data_stack.top(); data_stack.pop();            double a=data_stack.top(); data_stack.pop();            double temp=Calculate(a,b,op);            //cout&lt;&lt;&quot;运算后 &quot;&lt;&lt;temp&lt;&lt;endl;            data_stack.push(temp);        }    }    cout&lt;&lt;&quot;运算结果:&quot;&lt;&lt;data_stack.top()&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>中缀后缀表达式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>中缀后缀表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形数据结构总结</title>
    <link href="/2020/03/11/%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/11/%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前序-中序-后序知二推一"><a href="#前序-中序-后序知二推一" class="headerlink" title="前序,中序,后序知二推一"></a>前序,中序,后序知二推一</h1><h2 id="求先序序列"><a href="#求先序序列" class="headerlink" title="求先序序列"></a>求先序序列</h2><p><strong>题目描述</strong><br>给出一棵二叉树的中序与后序排列,求出它的先序排列，(约定树结点用不同的大写字母表示,长度≤8)。</p><p><strong>输入格式</strong><br>2行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。</p><p><strong>输出格式</strong><br>1行，表示一棵二叉树的先序。</p><p><strong>输入</strong></p><blockquote><p>BADC<br>BDCA</p></blockquote><p><strong>输出</strong></p><blockquote><p>ABCD</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string in;string post;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};TreeNode* Tree[10000];TreeNode* CreatTree(int s1,int t1,int s2,int t2){    char c=post[t1];//后序的最后一个    if(s1==t1){//叶子结点        Tree[c-&#39;A&#39;]=new TreeNode(c);        return Tree[c-&#39;A&#39;];    }    Tree[c-&#39;A&#39;]=new TreeNode(c);    int pos=in.find(c);//在中序中找到对应的顶点以及左右长度    int llen=pos-s2;    int rlen=t2-pos;    //别忘了判左右长度    if(llen) Tree[c-&#39;A&#39;]-&gt;left=CreatTree(s1,s1+llen-1,s2,s2+llen-1);    if(rlen) Tree[c-&#39;A&#39;]-&gt;right=CreatTree(s1+llen,t1-1,s2+llen+1,t2);    return Tree[c-&#39;A&#39;];}void PreOrder(TreeNode* root){    if(root==NULL) return ;    cout&lt;&lt;root-&gt;data;    PreOrder(root-&gt;left);    PreOrder(root-&gt;right);}int main(){    cin&gt;&gt;in&gt;&gt;post;    TreeNode* root=CreatTree(0,post.size()-1,0,in.size()-1);    PreOrder(root);}</code></pre><h2 id="求可能中序序列"><a href="#求可能中序序列" class="headerlink" title="求可能中序序列"></a>求可能中序序列</h2><p><strong>题目描述</strong><br>已知前序和后序遍历的结果求出一种可能得中序遍历的结果,二叉树的结点名以大写字母(A,B,C…)表示，最多26个结点<br><strong>输入格式</strong><br>第一行为前序遍历结果<br>第二行为后序遍历结果<br><strong>输出格式</strong><br>一个字符串，表示一个可能的中序遍历<br><strong>输入</strong></p><blockquote><p>ABDCE<br>DBECA</p></blockquote><p><strong>输出</strong></p><blockquote><p>DBAEC</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string pre,post;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};TreeNode* PrePostCreat(string pre,string post){    TreeNode* root=new TreeNode(pre[0]);    if(pre.size()==0) return NULL;//返回    int pos=post.find(pre[1]);//先序顶点在后序的位置//    cout&lt;&lt;pre.substr(1,pos+1)&lt;&lt;&quot;   &quot;&lt;&lt;post.substr(0,pos+1)&lt;&lt;endl;//    cout&lt;&lt;pre.substr(pos+2)&lt;&lt;&quot;   &quot;&lt;&lt;post.substr(pos+1,post.size()-pos-2)&lt;&lt;endl;    root-&gt;left=PrePostCreat(pre.substr(1,pos+1),post.substr(0,pos+1));    root-&gt;right=PrePostCreat(pre.substr(pos+2),post.substr(pos+1,post.size()-pos-2));    return root;}void InOrder(TreeNode* T){    if(T==NULL) return ;    InOrder(T-&gt;left);    cout&lt;&lt;T-&gt;data;    InOrder(T-&gt;right);}int main(){    cin&gt;&gt;pre&gt;&gt;post;    TreeNode* root=PrePostCreat(pre,post);    InOrder(root);}</code></pre><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="构造二叉排序树"><a href="#构造二叉排序树" class="headerlink" title="构造二叉排序树"></a>构造二叉排序树</h2><p><strong>题目描述</strong><br>已知二叉排序树用二叉链表存储，结点的关键字为 1正整数。从键盘输入结点的关键字（以 0表示结束）建立一棵二叉排序树，并输出其后序遍历序列</p><pre><code class="clike">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;struct TreeNode{    int data;    TreeNode* left;    TreeNode* right;    TreeNode(int data):data(data),left(NULL),right(NULL){}};//x插入到以root为根结点的排序树中，从根结点不断的向下比TreeNode* Insert(TreeNode* root,int n){    if(root==NULL) root=new TreeNode(n);    else if(n&lt;root-&gt;data) root-&gt;left=Insert(root-&gt;left,n);    else if(n&gt;root-&gt;data) root-&gt;right=Insert(root-&gt;right,n);    return root;}void PostOrder(TreeNode* root){    if(root==NULL) return  ;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;}int main(){    int n;    TreeNode* root=NULL;    while(cin&gt;&gt;n){        if(n==0) break;        else root=Insert(root,n);    }    PostOrder(root);}</code></pre><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><strong>题目描述</strong><br>判断两序列是否为同一二叉搜索树序列</p><p><strong>输入描述:</strong><br>开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。<br><strong>输出描述:</strong><br>如果序列相同则输出YES，否则输出NO</p><p><strong>输入</strong></p><blockquote><p>2<br>567432<br>543267<br>576342`<br>0</p></blockquote><p>输出</p><blockquote><p>YES<br>NO</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;//前序遍历和中序遍历可以唯一确定一棵二叉树，//而对二叉排序树而言，相同元素的二叉排序树中//序遍历一定相同，而不同元素二叉排序树使用前//序遍历就可以发现不相同，所以只需要前序遍历//两个二叉树，比较一下就可以判断using namespace std;string pre,in;struct TreeNode{    char data;    TreeNode* leftchild;    TreeNode* rightchild;    TreeNode(char c):data(c),leftchild(NULL),rightchild(NULL){}};TreeNode* Insert(TreeNode* root,char x){    if(root==NULL){        root=new TreeNode(x);    }    else if(x&lt;root-&gt;data){        root-&gt;leftchild=Insert(root-&gt;leftchild,x);    }    else if(x&gt;root-&gt;data){        root-&gt;rightchild=Insert(root-&gt;rightchild,x);    }    return root;}string preorder(TreeNode* root){    if(root==NULL) return &quot;#&quot;;    return root-&gt;data+preorder(root-&gt;leftchild)+preorder(root-&gt;rightchild);}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        string s; TreeNode* root=NULL;        cin&gt;&gt;s;        //构建初始的排序树        for(int i=0;i&lt;s.size();i++){            root=Insert(root,s[i]);        }        string pre=preorder(root);        //构建用来比较的排序树        for(int i=0;i&lt;n;i++){            string str; TreeNode* T=NULL;            cin&gt;&gt;str;            for(int j=0;j&lt;str.size();j++){                T=Insert(T,str[j]);            }            string pre1=preorder(T);        //进行比较            if(pre1==pre) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre><h2 id="二叉排序树最大路径"><a href="#二叉排序树最大路径" class="headerlink" title="二叉排序树最大路径"></a>二叉排序树最大路径</h2><p><strong>题目描述</strong><br>求二叉排序树中的最大路径</p><p><strong>输入</strong></p><blockquote><p>16<br>30 45 2 69 36 14 52 23 31 90 57 32 33 34 91 92</p></blockquote><p><strong>输出</strong></p><blockquote><p>11</p></blockquote><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;struct TreeNode{    int data;    TreeNode* left;    TreeNode* right;    TreeNode(int data):data(data),left(NULL),right(NULL){}};int Max=0;int a[100];//测试数据//30 45 2 69 36 14 52 23 31 90 57 32 33 34 91 92TreeNode* CreatTree(TreeNode* root,int data){    if(root==NULL){        TreeNode* T=new TreeNode(data);        return T;    }    if(data&lt;root-&gt;data) root-&gt;left=CreatTree(root-&gt;left,data);    else if(data&gt;root-&gt;data) root-&gt;right=CreatTree(root-&gt;right,data);    return root;}int MaxPath(TreeNode* root){    if(root==NULL) return 0;    int lh,rh,sum;    //包括自己在内的长度    lh=MaxPath(root-&gt;left)+1;    rh=MaxPath(root-&gt;right)+1;    //cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;lh&lt;&lt;&quot; &quot;&lt;&lt;rh&lt;&lt;endl;    sum=lh+rh-1;    Max=max(Max,sum);    return lh&gt;rh?lh:rh;}void PreOrder(TreeNode* T){    if(T==NULL) return ;    cout&lt;&lt;T-&gt;data;    PreOrder(T-&gt;left);    PreOrder(T-&gt;right);}int main(){    int n;    cin&gt;&gt;n;    TreeNode* root=NULL;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];        root=CreatTree(root,a[i]);    }    MaxPath(root);    cout&lt;&lt;endl;    cout&lt;&lt;Max;}</code></pre><h1 id="huffman树"><a href="#huffman树" class="headerlink" title="huffman树"></a>huffman树</h1><h2 id="huffman编码"><a href="#huffman编码" class="headerlink" title="huffman编码"></a>huffman编码</h2><p><strong>题目描述</strong><br>哈弗曼树问题：在”7.in”中<br>有几个数，和为1，进行哈弗曼编码，并把编码结果输出到”7.out”中。</p><p><strong>输入</strong></p><blockquote><p>0.1 0.15 0.2 0.25 0.3</p></blockquote><p><strong>输出</strong></p><blockquote><p>000<br>001<br>01<br>10<br>11</p></blockquote><p>PS:这道题我写了特别久，主要是优先队列存指针的问题，西八，太难了。</p><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;const int eps=1e-6;struct HfNode{    double weight;    HfNode* left;    HfNode* right;    string code;    HfNode(double weight):weight(weight),left(NULL),right(NULL),code(&quot;&quot;){}    bool operator &gt;(const HfNode&amp; e)const{        return weight&gt;e.weight;    }};HfNode* Tree[10000];void Huffman(HfNode* T){//遍历huffman树设编码    //cout&lt;&lt;T.code&lt;&lt;endl;    if(T-&gt;left!=NULL) {T-&gt;left-&gt;code=T-&gt;code+&quot;1&quot;;  Huffman(T-&gt;left);}    if(T-&gt;right!=NULL) {T-&gt;right-&gt;code=T-&gt;code+&quot;0&quot;;  Huffman(T-&gt;right);}    if(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL) cout&lt;&lt;T-&gt;weight&lt;&lt;&quot; &quot;&lt;&lt;T-&gt;code&lt;&lt;endl;//叶子结点    return ;}//重要：std::priority_queue 存放的是自定义类型的指针时,解决方法是使用Compare//类似于sort中定义的cmpclass Compare{public:    bool operator () (HfNode* &amp;a,HfNode* &amp;b) const{        return a-&gt;weight&gt;b-&gt;weight;    }};int main(){    priority_queue &lt;HfNode*,vector&lt;HfNode*&gt;,Compare &gt; q;    ifstream infile(&quot;in.txt&quot;);    double n; string s;    getline(infile,s);    stringstream in(s);//这个在double会出现问题    while(in&gt;&gt;n){        HfNode* node=new HfNode(n);//在前面加new返回指针，不加new就是node的类型        q.push(node);    }    int point;    while(q.size()&gt;1){//建huffman树        //分配空间        HfNode* a=(HfNode*)malloc(sizeof(HfNode));        HfNode* b=(HfNode*)malloc(sizeof(HfNode));        HfNode* c=(HfNode*)malloc(sizeof(HfNode));        a=q.top(); q.pop();        b=q.top(); q.pop();        double x=a-&gt;weight+b-&gt;weight;        c=new HfNode(x);        c-&gt;left=a; c-&gt;right=b;        //cout&lt;&lt;c-&gt;left-&gt;weight&lt;&lt;&quot; &quot;&lt;&lt;c-&gt;right-&gt;weight&lt;&lt;endl;        q.push(c);    }    Huffman(q.top());}</code></pre><h1 id="其余题型"><a href="#其余题型" class="headerlink" title="其余题型"></a>其余题型</h1><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p><strong>题目描述</strong><br>输出树的层次遍历的奇数层的所有结点。<br><strong>输入</strong></p><blockquote><p>A B C<br>B E<br>C F G</p></blockquote><p><strong>输出</strong></p><blockquote><p>第 1 层结点：A<br>第 3 层结点：E,F,G</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#include&lt;queue&gt;using namespace std;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    int deep;    TreeNode(char data,int deep):data(data),deep(deep),left(NULL),right(NULL){}};const int MAXN=100;TreeNode* Tree[MAXN];//建树时一定要用这个，方便用内容去找到结点;vector&lt;char&gt; v;void Level_Order(TreeNode* T){    queue&lt;TreeNode*&gt; q;    q.push(T);    while(!q.empty()){        TreeNode* p=q.front();        q.pop();        if(p-&gt;deep%2==1) cout&lt;&lt;&quot;第&quot;&lt;&lt;p-&gt;deep&lt;&lt;&quot;层:&quot;&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;endl;        if(p-&gt;left){            q.push(p-&gt;left);        }        if(p-&gt;right){            q.push(p-&gt;right);        }    }}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    int i=1;    while(getline(infile,s)){        v.clear();        char c;        stringstream in(s);        while(in&gt;&gt;c){            v.push_back(c);        }        if(!Tree[v[0]-&#39;A&#39;]) Tree[v[0]-&#39;A&#39;]=new TreeNode(v[0],1);        int deep=Tree[v[0]-&#39;A&#39;]-&gt;deep;        for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]-&#39;A&#39;&lt;&lt;&quot; &quot;&lt;&lt;endl;        if(v.size()==3){//参照这样的方法建树            if(!Tree[v[1]-&#39;A&#39;]){//可以这样判断数组该处有没有值                Tree[v[1]-&#39;A&#39;]=new TreeNode(v[1],deep+1);            }            if(!Tree[v[2]-&#39;A&#39;]){                Tree[v[2]-&#39;A&#39;]=new TreeNode(v[2],deep+1);            }            Tree[v[0]-&#39;A&#39;]-&gt;left=Tree[v[1]-&#39;A&#39;];            Tree[v[0]-&#39;A&#39;]-&gt;right=Tree[v[2]-&#39;A&#39;];        }        else if(v.size()==2){            if(!Tree[v[1]-&#39;A&#39;]){                Tree[v[1]-&#39;A&#39;]=new TreeNode(v[1],deep+1);            }            Tree[v[0]-&#39;A&#39;]-&gt;left=Tree[v[1]-&#39;A&#39;];        }        i++;    }    Level_Order(Tree[0]);    //cout&lt;&lt;Tree[0]-&gt;left-&gt;left-&gt;data&lt;&lt;endl;//用这种方法来测试树是否建立成功}</code></pre><h2 id="FBI树"><a href="#FBI树" class="headerlink" title="FBI树"></a>FBI树</h2><p><strong>题目描述</strong><br>我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。FBI树是一种二叉树，它的结点类型也包括FF结点，BB结点和I结点三种。由一个长度为 2 ^N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：</p><ol><li>T的根结点为R，其类型与串S的类型相同；</li><li>若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。</li></ol><p>现在给定一个长度为2^N 的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。</p><p><strong>输入格式</strong><br>第一行是一个整数N(0≤N≤10)，</p><p>第二行是一个长度为2^N的“01”串。</p><p><strong>输出格式</strong><br>一个字符串，即FBI树的后序遍历序列。</p><p><strong>输入</strong></p><blockquote><p>3<br>10001011</p></blockquote><p><strong>输出</strong></p><blockquote><p>IBFBBBFIBFIIIFF</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;int n;string str;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};TreeNode* Tree[100000];int p=0;TreeNode* CreatTree(int Start,int End){    string s=str.substr(Start,End-Start+1);    //cout&lt;&lt;s&lt;&lt;endl;    TreeNode* T=(TreeNode*)malloc(sizeof(TreeNode*));//为了防止指针被覆盖    if(s.find(&quot;0&quot;)!=string::npos&amp;&amp;s.find(&quot;1&quot;)!=string::npos){        //cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;&quot;F&quot;&lt;&lt;endl;        Tree[p]=new TreeNode(&#39;F&#39;);        T=Tree[p];    }    else if(s.find(&quot;0&quot;)!=string::npos&amp;&amp;s.find(&quot;1&quot;)==string::npos){        //cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;&quot;B&quot;&lt;&lt;endl;        Tree[p]=new TreeNode(&#39;B&#39;);        T=Tree[p];    }    else if(s.find(&quot;0&quot;)==string::npos&amp;&amp;s.find(&quot;1&quot;)!=string::npos){        //cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;&quot;I&quot;&lt;&lt;endl;        Tree[p]=new TreeNode(&#39;I&#39;);        T=Tree[p];    }    p++;    if(s.size()==1){        return T;    }    else{        T-&gt;left=CreatTree(Start,Start+(End-Start)/2);        T-&gt;right=CreatTree(End-(End-Start)/2,End);    }    return T;}void PostOrder(TreeNode* root){    if(root==NULL) return ;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=pow(2,n);i++){        char c;        cin&gt;&gt;c;        str=str+c;    }    //cout&lt;&lt;str&lt;&lt;endl;    TreeNode* root=CreatTree(0,str.size()-1);    PostOrder(Tree[0]);}</code></pre><h2 id="新二叉树"><a href="#新二叉树" class="headerlink" title="新二叉树"></a>新二叉树</h2><p><strong>题目描述</strong><br>输入一串二叉树，输出其前序遍历。</p><p><strong>输入格式</strong><br>第一行为二叉树的节点数 n。(1≤n≤26)<br>后面 n 行，每一个字母为节点，后两个字母分别为其左右儿子。空节点用 * 表示</p><p><strong>输出格式</strong><br>二叉树的前序遍历。</p><p><strong>输入</strong></p><blockquote><p>6<br>abc<br>bdi<br>cj*<br>d**<br>i**<br>j**</p></blockquote><p><strong>输出</strong></p><blockquote><p>abdicj</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;using namespace std;int n;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){};};TreeNode* Tree[10000];void PreOrder(TreeNode* root){    if(root==NULL) return ;    cout&lt;&lt;root-&gt;data;    PreOrder(root-&gt;left);    PreOrder(root-&gt;right);}int main(){    cin&gt;&gt;n;    string s;    char T=0; int i=n;//因为Tree[0]不一定是根结点!!!!    while(n--){        cin&gt;&gt;s;        if(i==n+1) T=s[0];//记录根结点        //别忘了每一个结点都要判断是否已经存在        if(!Tree[s[0]-&#39;a&#39;]) Tree[s[0]-&#39;a&#39;]=new TreeNode(s[0]);        if(s[1]!=&#39;*&#39;){            if(!Tree[s[1]-&#39;a&#39;]) Tree[s[1]-&#39;a&#39;]=new TreeNode(s[1]);            Tree[s[0]-&#39;a&#39;]-&gt;left=Tree[s[1]-&#39;a&#39;];        }        if(s[2]!=&#39;*&#39;){            if(!Tree[s[2]-&#39;a&#39;]) Tree[s[2]-&#39;a&#39;]=new TreeNode(s[2]);            Tree[s[0]-&#39;a&#39;]-&gt;right=Tree[s[2]-&#39;a&#39;];        }    }    PreOrder(Tree[T-&#39;a&#39;]);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂最终总结</title>
    <link href="/2020/03/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="原理（两种理解）"><a href="#原理（两种理解）" class="headerlink" title="原理（两种理解）"></a>原理（两种理解）</h2><p><img src="https://img-blog.csdnimg.cn/20200309165655161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200309165758513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这jjj">)<img src="https://img-blog.csdnimg.cn/20200309170236327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309170526572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200309170609480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309170641994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309170705631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>题目描述</strong><br>给你三个整数 b,p,k,求 $b^p$mod k 。</p><p><strong>输入格式</strong><br>一行三个整数 b,p,kb,p,k</p><p><strong>输出格式</strong><br>输出 $b^p$ mod k=s<br>s 为运算结果</p><p><strong>输入</strong></p><blockquote><p>2 10 9</p></blockquote><p><strong>输出</strong></p><blockquote><p>2^10 mod 9=7</p></blockquote><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;long long QuickPower(long long base,long long n,long long k){    long long ans=1;    while(n!=0){        if(n&amp;1){            ans*=base;            ans%=k;        }        base*=base;        base%=k;        n&gt;&gt;=1;    }    return ans;}int main(){    long long base,n,k;    cin&gt;&gt;base&gt;&gt;n&gt;&gt;k;    //别忘了对最终的答案取模    printf(&quot;%lld^%lld mod %lld=%lld&quot;,base,n,k,QuickPower(base,n,k)%k);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>快速幂最终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_12</title>
    <link href="/2020/02/27/USTC%E6%9C%BA%E8%AF%95_12/"/>
    <url>/2020/02/27/USTC%E6%9C%BA%E8%AF%95_12/</url>
    
    <content type="html"><![CDATA[<p>1.字符串处理：从   string.in文件里读入两个字符串，字符串除了数字还可能包括    ‘—‘、’E’、’e’、’．’，相加之后输出到文件 string.out中，如果是浮点型，要求用科学计数法表示（最多包含 10个有效数字）。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;#include&lt;math.h&gt;using namespace std;int main(){    ifstream infile(&quot;in.txt&quot;);    string s1,s2;    double x,y;    getline(infile,s1);    getline(infile,s2);    if(s1.find(&#39;e&#39;)!=string::npos||s1.find(&#39;E&#39;)!=string::npos){        if(s1.find(&#39;e&#39;)!=string::npos){            int pos=s1.find(&#39;e&#39;);            double a=atof((char*)s1.substr(0,pos).data());//底数            double b=atof((char*)s1.substr(pos+1).data());//次数            x=a*pow(10,b);        }        else{            int pos=s1.find(&#39;E&#39;);            double a=atof((char*)s1.substr(0,pos).data());//底数            double b=atof((char*)s1.substr(pos+1).data());//次数            x=a*pow(10,b);        }    }    else{        x=atof((char*)s1.data());    }    if(s2.find(&#39;e&#39;)!=string::npos||s2.find(&#39;E&#39;)!=string::npos){        if(s2.find(&#39;e&#39;)!=string::npos){            int pos=s2.find(&#39;e&#39;);            double a=atof((char*)s2.substr(0,pos).data());//底数            double b=atof((char*)s2.substr(pos+1).data());//次数            y=a*pow(10,b);        }        else{            int pos=s2.find(&#39;e&#39;);            double a=atof((char*)s2.substr(0,pos).data());//底数            double b=atof((char*)s2.substr(pos+1).data());//次数            y=a*pow(10,b);        }    }    else{        y=atol((char*)s2.data());    }    printf(&quot;%e&quot;,x+y);    infile.close();}</code></pre><p>2.最大公约数：从    number.in文件中读入   n个数，求出这   n个数的最小值、最大值以及它们两的最大公约数，输出到文件 number.out中。number.in中第一行为     n，接下来为  n个大于零的整数。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;#include &lt;sstream&gt;using namespace std;const int MAXN=100;int a[MAXN];//若是最小公倍数则是两数乘积除以它们的最大公约数int gcd(int a,int b){//    if(b==0) return a;    else return gcd(b,a%b);}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    int n=atoi((char*)s.data());    getline(infile,s);    stringstream stringin(s);//实现按空格读取,需要导入sstream文件    int i=0;    while(stringin&gt;&gt;a[i]){        i++;    }    sort(a,a+n);    int Min=a[0],Max=a[n-1];    cout&lt;&lt;Min&lt;&lt;&quot; &quot;&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;gcd(Min,Max);}</code></pre><p>3.任务调度：从   task.in文件中读入任务调度序列，输出    n个任务适合的一种调度方式到 task.out中。每行第一个表示前序任务，括号中的任务为若干个后序任务，表示只有在前序任务完成的情况下，后序任务才能开始。若后序为 NULL则表示无后继任务。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];int indegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=0;i&lt;n;i++){        if(indegree[i]==0) q.push(i);    }    while(!q.empty()){        int T=q.top();        topology.push_back(T);        q.pop();        for(int i=0;i&lt;graph[T].size();i++){            int v=graph[T][i];            indegree[v]--;            if(indegree[v]==0) q.push(v);        }    }    return topology;}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    memset(indegree,0,sizeof(indegree));    int Count=0;    while(getline(infile,s)){        Count++;        int pos=s.find(&quot;Task&quot;);        int T=atoi((char*)s.substr(pos+4,1).data());        s=s.substr(pos+5);        while(s.find(&quot;Task&quot;)!=string::npos){            int pos1=s.find(&quot;Task&quot;);            int p=atoi((char*)s.substr(pos1+4,1).data());            indegree[p]++;            graph[T].push_back(p);            s=s.substr(pos1+5);        }    }    vector&lt;int&gt; v=TopologicalSort(Count);    for(int i=0;i&lt;v.size();i++){        cout&lt;&lt;&quot;Task&quot;&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre><p>4.火车票订购：火车经过   X站，火车最大载客人数为   m，有 n个订票请求，请求订购从 a站到  b站的  k张票，若能满足订购要求则输出   1，否则输出 0。数据从 ticket.in中输入，第一行有四个数，分别为 n，m。接下来有  n行，每行三个数分别为   a，b，k。结果输出到文件 ticket.out中</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;sstream&gt;using namespace std;const int MAXN=100;int station[MAXN];int n,m;int result[MAXN];bool jugde(int a,int b,int k){    bool flag=true;    for(int i=a;i&lt;=b;i++){        if(station[i]+k&gt;m){            flag=false;            break;        }    }    return flag;}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    stringstream stringin(s);    stringin&gt;&gt;n; stringin&gt;&gt;m;    int j=0;    for(int i=0;i&lt;n;i++){        int a,b,k;        getline(infile,s);        stringstream stringin1(s);        stringin1&gt;&gt;a; stringin1&gt;&gt;b; stringin1&gt;&gt;k;        if(jugde(a,b,k)){            for(int i=a;i&lt;=b;i++){                station[i]+=k;            }            result[j++]=1;        }        else{            result[j++]=0;        }    }    infile.close();    ofstream outfile(&quot;out.txt&quot;);    for(int i=0;i&lt;n;i++){        outfile&lt;&lt;result[i]&lt;&lt;endl;    }    outfile.close();}</code></pre><p>5.最短路径：有   n个城市   m条道路（n&lt;1000,   m&lt;10000)，每条道路有个长度，请找到从起点 s到终点  t的最短距离，并且输出经过的城市的名，如果有多条，输出字典序最小的那条；若从 s到   t没有路径，则输出“can’t   arrive”。从 road.in中读入数据，第一行有四个数，分别为 n，m，s，t。接下来 m行，每行三个数，分别为两个城市名和距离。输出结果到 road.out中。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;queue&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;cstdio&gt;using namespace std;const int INF=INT_MAX;//struct Edge{    int to;    int length;    Edge(int to,int length):to(to),length(length){}};const int MAXN=100;vector&lt;Edge&gt; graph[MAXN];int dis[MAXN];//存的最小距离int path[MAXN];//path[j]=i表示从i到j最短路的路径struct Point{    int number;    int distance;//到源点距离    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; e) const{        return distance&lt;e.distance;    }};void Dijkstra(int s){    priority_queue&lt;Point&gt; q;//若是逆向从时要对Point中的&gt;进行重载    dis[s]=0;    q.push(Point(s,dis[s]));    while(!q.empty()){        int u=q.top().number;//距离源点最近的点        q.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){//所以初始化应该是无穷                dis[v]=dis[u]+d;                q.push(Point(v,dis[v]));                path[v]=u;//由u到v是最短            }        }    }    return ;}int main(){    int n,m,s,t;    ifstream infile(&quot;in.txt&quot;);    string str;    getline(infile,str);    stringstream in(str);    in&gt;&gt;n; in&gt;&gt;m; in&gt;&gt;s; in&gt;&gt;t;    memset(graph,0,sizeof(graph));    //对int数组用fill初始化    fill(dis,dis+MAXN,INF);//注意初始化的范围    fill(path,path+MAXN,-1);    //cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl;    for(int i=0;i&lt;m;i++){        int a,b,l;        getline(infile,str);        stringstream in(str);        in&gt;&gt;a; in&gt;&gt;b; in&gt;&gt;l;        graph[a].push_back(Edge(b,l));        graph[b].push_back(Edge(a,l));    }    Dijkstra(s);    cout&lt;&lt;dis[t]&lt;&lt;endl;    vector&lt;int&gt; v;    while(path[t]!=-1){        v.push_back(t);        t=path[t];    }    v.push_back(s);    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_11</title>
    <link href="/2020/02/25/USTC%E6%9C%BA%E8%AF%95_11/"/>
    <url>/2020/02/25/USTC%E6%9C%BA%E8%AF%95_11/</url>
    
    <content type="html"><![CDATA[<p>1.给两个十进制数，先异或，然后输出其二进制形式</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;int main(){    int x,y;    cin&gt;&gt;x&gt;&gt;y;    int n=x^y;    while(n!=0){        v.push_back(n%2);        n/=2;    }    for(int i=v.size()-1;i&gt;=0;i--) cout&lt;&lt;v[i];}</code></pre><p>2.一共有十二个球，其颜色有红、黄、黑三种，红黄黑分别有想  x，y，k个，现在从其中取出八个球，共有多少种取法，输出到文件中？（x，y，k是从键盘输入，痛颜色的球不区分）</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;const int MAXN=1000;struct E{    int x,y,k;}E[MAXN];int main(){    int x,y,k;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;    int Count=0;    for(int i=1;i&lt;=x;i++){        for(int j=1;j&lt;=y;j++){            for(int m=1;m&lt;=k;m++){                if(i+j+m==8){                    E[Count].x=i;                    E[Count].y=j;                    E[Count].k=m;                    Count++;                }            }        }    }    cout&lt;&lt;&quot;共&quot;&lt;&lt;Count&lt;&lt;&quot;种取法&quot;;    for(int i=0;i&lt;Count;i++){        cout&lt;&lt;E[i].x&lt;&lt;&quot;红球 &quot;&lt;&lt;E[i].y&lt;&lt;&quot;黄球 &quot;&lt;&lt;E[i].k&lt;&lt;&quot;黑球&quot;&lt;&lt;endl;    }}</code></pre><p>3.在in.txt中查看是否有模式  abcde。若有，输出“找到 abc<em>d?e匹配”；若无，则输出“没有找到  abc</em>d?e匹配”</p><pre><code class="c">不会做...</code></pre><p>4.给你一个二叉树，每个节点有编号，给你一个序列，每个节点给了左孩子和右孩子的编号，让你输出这个二叉树的后序遍历结果。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;const int MAXN=100;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};struct TreeNode* Tree[MAXN];void PostOrder(TreeNode* root){    if(root==NULL) return;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data;}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    TreeNode* T=NULL;    while(getline(infile,s)){        int pos=s.find(&quot; &quot;);        char a=s.substr(0,pos)[0];        s=s.substr(pos+1);        pos=s.find(&quot; &quot;);        char b=s.substr(0,pos)[0];        s=s.substr(pos+1);        pos=s.find(&quot; &quot;);        char c=s.substr(0,pos)[0];        cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;        TreeNode* Tl=NULL;        TreeNode* Tr=NULL;        if(Tree[a-&#39;0&#39;]) T=Tree[a-&#39;0&#39;];        else{            T=new TreeNode(a);            Tree[a-&#39;0&#39;]=T;        }        if(Tree[b-&#39;0&#39;]) Tl=Tree[b-&#39;0&#39;];        else{            Tl=new TreeNode(b);            Tree[b-&#39;0&#39;]=Tl;        }        if(Tree[c-&#39;0&#39;]) Tr=Tree[c-&#39;0&#39;];        else{            Tr=new TreeNode(c);            Tree[c-&#39;0&#39;]=Tr;        }        if(b!=&#39;0&#39;) T-&gt;left=Tl;        else T-&gt;left=NULL;        if(c!=&#39;0&#39;) T-&gt;right=Tr;        else T-&gt;right=NULL;    }    T=Tree[1];    PostOrder(T);    infile.close();}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_10</title>
    <link href="/2020/02/25/USTC%E6%9C%BA%E8%AF%95_10/"/>
    <url>/2020/02/25/USTC%E6%9C%BA%E8%AF%95_10/</url>
    
    <content type="html"><![CDATA[<p>1.input.txt文件里面有一段文章，由字符串和一些特殊字符构成。先把  input文件中的内容读入缓冲区，在从缓冲区中取字符，进行如下操作：</p><ul><li>如果是字符，空格，输出</li><li>如果是’!’，删除前面一个字符</li><li>如果是’*’，删除前面 1行字符串</li><li>如果是’&gt;’，讲前面一个单词的首字符，进行大小写转化</li><li>如果是数字，则不作任何操作</li></ul><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;using namespace std;vector&lt;string&gt; v;int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    while(getline(infile,s)){        v.push_back(s);    }    for(int i=0;i&lt;v.size();i++){        s=v[i];        if(s.find(&#39;!&#39;)!=string::npos){            int pos=s.find(&quot;!&quot;);            v[i]=s.substr(0,pos-1)+s.substr(pos);        }        if(s.find(&#39;*&#39;)!=string::npos){            if(i==0) cout&lt;&lt;&quot;已在第一行无法删除&quot;;            else{                v.erase(v.begin()+i-1,v.begin()+i);                i--;            }        }        if(s.find(&#39;&gt;&#39;)!=string::npos){            int pos=s.find(&#39;&gt;&#39;);            string s1=s.substr(0,pos);//&gt;前面的字符串            s1=s1.substr(0,s1.find_last_of(&quot; &quot;));            int pos1=s1.find(&quot; &quot;);//&gt;的前一个单词前面的空格位置            string c=s.substr(pos1+1,1);            if(c[0]&gt;&#39;a&#39;&amp;&amp;c[0]&lt;&#39;z&#39;) c[0]=c[0]-32;            else c[0]=c[0]+32;            //cout&lt;&lt;&quot;字母&quot;&lt;&lt;c&lt;&lt;endl;            s.replace(pos1+1,1,(char*)c.data());            v[i]=s;        }    }    for(int i=0;i&lt;v.size();i++){        cout&lt;&lt;v[i]&lt;&lt;endl;    }    infile.close();}</code></pre><p>2.从键盘输入 N，建立  N*N矩阵，每个元素是一个字符串，为每个元素赋值。然后求出按字典序排列最大的元素所在的行列</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=100;struct M{//为了排序方便，将矩阵化成一维处理    char s[MAXN];    int i,j;    bool operator &lt;(const M &amp;e) const{        if(strcmp(s,e.s)&lt;0) return true;        else return false;    }}M[MAXN];int main(){    int N;    cin&gt;&gt;N;    int k=0;//M中的下标    for(int i=0;i&lt;N;i++){        for(int j=0;j&lt;N;j++){            scanf(&quot;%s&quot;,M[k].s);            M[k].i=i;            M[k].j=j;            k++;        }    }    sort(M,M+N*N);    cout&lt;&lt;M[N*N-1].i+1&lt;&lt;&quot; &quot;&lt;&lt;M[N*N-1].j+1&lt;&lt;endl;}</code></pre><p>3.已知二叉排序树用二叉链表存储，结点的关键字为  1正整数。从键盘输入结点的关键字（以 0表示结束）建立一棵二叉排序树，并输出其后序遍历序列</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;struct TreeNode{    int data;    TreeNode* left;    TreeNode* right;    TreeNode(int data):data(data),left(NULL),right(NULL){}};//x插入到以root为根结点的排序树中，从根结点不断的向下比TreeNode* Insert(TreeNode* root,int n){    if(root==NULL) root=new TreeNode(n);    else if(n&lt;root-&gt;data) root-&gt;left=Insert(root-&gt;left,n);    else if(n&gt;root-&gt;data) root-&gt;right=Insert(root-&gt;right,n);    return root;}void PostOrder(TreeNode* root){    if(root==NULL) return  ;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;}int main(){    int n;    TreeNode* root=NULL;    while(cin&gt;&gt;n){        if(n==0) break;        else root=Insert(root,n);    }    PostOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_09</title>
    <link href="/2020/02/24/USTC%E6%9C%BA%E8%AF%95_09/"/>
    <url>/2020/02/24/USTC%E6%9C%BA%E8%AF%95_09/</url>
    
    <content type="html"><![CDATA[<p>1.处理：比如输入4，转化为16位二进制数   0000 0000 0000 0100，4个一组，相异或，变为0001，然后把0001转化为十进制的1输出</p><pre><code class="c">// 1.cpp : Defines the entry point for the console application.//#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;math.h&gt;using namespace std;queue&lt;int&gt; q;int main(){    int x;    cin&gt;&gt;x;    while(x!=0){        int a,b;        a=x%2;//当前最后一位        x/=2;        b=x%2;        a=a^b;//1 2位异或        x/=2;        b=x%2;        a=a^b;//1 2 3位异或        x/=2;        b=x%2;        a=a^b;//1 2 3 4位异或        q.push(a);    }    int i=0,answer=0;    while(!q.empty()){        answer+=q.front()*pow(2,i++);        q.pop();    }    cout&lt;&lt;answer&lt;&lt;endl;}</code></pre><p>2.将n个数由小到大排序，如果  n是奇数，输出正中间的数；如果n是偶数，输出<br>正中间的两个数</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000;int arr[MAXN];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;arr[i];    }    sort(arr,arr+n);    if(n%2==0){        cout&lt;&lt;arr[n/2-1]&lt;&lt;&quot; &quot;&lt;&lt;arr[n/2];    }    else cout&lt;&lt;arr[n/2];}</code></pre><p>3.文件读入类ABC00DE00…的二叉树先序序列，0表示叶子<br>输出：中序输出深度&lt;=depth/2的节点，其中depth是你所建立的树的深度</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//数据:ABC00D00E00int depth=0;string pre;int i=0;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};TreeNode* buildTree(){//仅用带null符号的先序序列构建树    if(i&gt;pre.size()-1) return NULL;    char c=pre[i++];    if(c==&#39;0&#39;) return NULL;    TreeNode* T=new TreeNode(c);    T-&gt;left=buildTree();    T-&gt;right=buildTree();    return T;}void PostOrder(TreeNode* T,int deep){//计算深度    if(T==NULL)return ;    if(deep&gt;depth) depth=deep;    PostOrder(T-&gt;left,deep+1);    PostOrder(T-&gt;right,deep+1);}void PostOrder1(TreeNode* T,int deep){    if(T==NULL)return ;    if(deep&gt;depth) depth=deep;    PostOrder(T-&gt;left,deep+1);    PostOrder(T-&gt;right,deep+1);    if(deep&lt;=depth/2){        cout&lt;&lt;T-&gt;data;    }    return ;}int main(){    ifstream infile(&quot;in.txt&quot;);    getline(infile,pre);    infile.close();    cout&lt;&lt;pre&lt;&lt;endl;    TreeNode* root=buildTree();    PostOrder(root,1);    //cout&lt;&lt;&quot;deep:&quot;&lt;&lt;depth&lt;&lt;endl;    PostOrder1(root,1);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_08下</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8B/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.输入十进制正整数将其转换成任意的进制</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;int main(){    int n,m;    cin&gt;&gt;n;    cout&lt;&lt;&quot;进制:&quot;;    cin&gt;&gt;m;    while(n!=0){        v.push_back(n%m);        n/=m;    }    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i];    }}</code></pre><p>2.从文件读入 2个矩阵，转置后相加再输出</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;const int n=3;const int m=2;int matrix1[n][m];int matrix2[n][m];int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    for(int i=0;i&lt;m;i++){        getline(infile,s);        for(int j=0;j&lt;n;j++){            if(s.find(&quot; &quot;)!=string::npos){                int pos=s.find(&quot; &quot;);                matrix1[j][i]=atoi((char*)s.substr(0,pos).data());//转置                s=s.substr(pos+1);            }            else{                matrix1[j][i]=atoi((char*)s.data());            }        }    }    for(int i=0;i&lt;n;i++){        getline(infile,s);        for(int j=0;j&lt;m;j++){            if(s.find(&quot; &quot;)!=string::npos){                int pos=s.find(&quot; &quot;);                matrix2[i][j]=atoi((char*)s.substr(0,pos).data());                s=s.substr(pos+1);            }            else{                matrix2[i][j]=atoi((char*)s.data());            }        }    }    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            cout&lt;&lt;matrix1[i][j]+matrix2[i][j]&lt;&lt;&quot; &quot;;        }        cout&lt;&lt;endl;    }}</code></pre><p>3.读入一个文件，第一行是字符串集合个数，第二行到第五行是这四个集合，从中<br>找到，字符串集合中出现两次的字符串，然后标识出第几个集合（行数）</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt; m;void Count1(string key){    if(m.find(key)==m.end()){//没找到这个key        m.insert(pair&lt;string,int&gt;(key,1));    }    else{//已经存在这个key        m[key]=m[key]+1;    }}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=0;i&lt;n;i++){        getline(infile,s);        while(s.size()&gt;0){            if(s.find(&quot; &quot;)!=string::npos){//                int pos=s.find(&quot; &quot;);                string key=s.substr(0,pos);                Count1(key);                s=s.substr(pos+1);            }            else{                string key=s;                Count1(key);                s=s.substr(s.size());//为了能跳出循环            }        }    }    map&lt;string,int&gt;::iterator it;    for(it=m.begin();it!=m.end();it++){//        if(it-&gt;second==2){            ifstream in(&quot;in.txt&quot;);            string s; int i=0;            getline(in,s);            while(getline(in,s)){                i++;                if(s.find(it-&gt;first)!=string::npos){                    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;i; break;                }            }            in.close();            cout&lt;&lt;endl;        }    }}</code></pre><p>4.给一个先序(中序)遍历序列，按层次输出该树的结点</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;string pre;string in;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};void LevelOrder(TreeNode* T){    queue&lt;TreeNode*&gt; q;    q.push(T);    while(!q.empty()){        TreeNode* p=q.front();        cout&lt;&lt;p-&gt;data;        q.pop();        if(p-&gt;left) q.push(p-&gt;left);        if(p-&gt;right) q.push(p-&gt;right);    }    return ;}TreeNode* build(int l1,int h1,int l2,int h2){//前序中序建树    char c=pre[l1];    TreeNode* T=new TreeNode(c);    int i;    for(i=l2;in[i]!=c;i++) ;    int llen=i-l2;    int rlen=h2-i;    if(llen) T-&gt;left=build(l1+1,l1+llen,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=build(h1-rlen+1,h1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}int main(){    cin&gt;&gt;pre&gt;&gt;in;    TreeNode* root=build(0,pre.size()-1,0,in.size()-1);    LevelOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_08上</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8A/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>1.一个十进制正整数转换成二进制有多少个1</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int main(){    int x;    cin&gt;&gt;x;    int Count=0;    while(x!=0){        if(x%2==1) Count++;        x/=2;    }    cout&lt;&lt;Count;}</code></pre><p>2.约瑟夫环问题</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;using namespace std;int main(){    queue&lt;int&gt; q;    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=1;i&lt;=n;i++){        q.push(i);    }    int m=4;    while(!q.empty()){        for(int i=1;i&lt;m;i++){            int k=q.front();            q.pop();            q.push(k);        }        cout&lt;&lt;q.front();        q.pop();    }}</code></pre><p>3.从文件读入 2个矩阵，输出矩阵相乘后的矩阵</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;int matrix1[3][3];int matrix2[3][2];int matrix3[3][2];int main(){    ifstream infile(&quot;in.txt&quot;);    ofstream outfile(&quot;out.txt&quot;);    string s;    for(int i=0;i&lt;3;i++){        getline(infile,s);        int j;        for(j=0;j&lt;2;j++){            int pos=s.find(&quot; &quot;);            matrix1[i][j]=atoi((char*)s.substr(0,pos).data());            s=s.substr(pos+1);        }        matrix1[i][j]=atoi((char*)s.data());    }    for(int i=0;i&lt;3;i++){        getline(infile,s);        int j;        for(j=0;j&lt;1;j++){            int pos=s.find(&quot; &quot;);            matrix2[i][j]=atoi((char*)s.substr(0,pos).data());            s=s.substr(pos+1);        }        matrix2[i][j]=atoi((char*)s.data());    }    infile.close();    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;2;j++){//前两个for为最终矩阵的每一个位置            int temp=0;            for(int k=0;k&lt;3;k++){                temp+=matrix1[i][k]*matrix2[k][j];//            }            matrix3[i][j]=temp;        }    }    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;2;j++){            outfile&lt;&lt;matrix3[i][j]&lt;&lt;&quot; &quot;;        }        outfile&lt;&lt;endl;    }}</code></pre><p>4.符串问题。从文件中读入几行英文句子。输出单词，行号，并按单词字典索<br>引。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt; m;//写成计数了，不过字典索引也不难，懒得改了void Count(string key){    if(m.find(key)==m.end()){//没找到这个key        m.insert(pair&lt;string,int&gt;(key,1));    }    else{//已经存在这个key        cout&lt;&lt;&quot;存在&quot;&lt;&lt;key&lt;&lt;&quot;:&quot;&lt;&lt;m[key]&lt;&lt;endl;        m[key]=m[key]+1;    }}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=0;i&lt;n;i++){        getline(infile,s);        while(s.size()&gt;0){            cout&lt;&lt;s&lt;&lt;endl;            if(s.find(&quot; &quot;)!=string::npos){//                int pos=s.find(&quot; &quot;);                string key=s.substr(0,pos);                Count(key);                s=s.substr(pos+1);            }            else{                string key=s;                Count(key);                s=s.substr(s.size());//为了能跳出循环            }        }    }    map&lt;string,int&gt;::iterator it;    for(it=m.begin();it!=m.end();it++){//        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_07下</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8B/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.输入字符串，倒序输出，例如：输入 I come from China.输出 China from come I.（单词不需倒序，只是句子倒了）</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main(){    string s;    getline(cin,s);    vector&lt;string&gt; v;    while(s.find(&#39; &#39;)!=string::npos){        int pos=s.find(&#39; &#39;);        v.push_back(s.substr(0,pos));        s=s.substr(pos+1);    }    v.push_back(s);    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre><p>2.输入一个数判断是不是完数，是输出 yes，不是输出  no</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int fenjie(int x){    int sum=0;    for(int i=1;i&lt;=x/2;i++){        if(x%i==0) sum+=i;    }    return sum;}int main(){    int x;    cin&gt;&gt;x;    if(fenjie(x)==x) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;}</code></pre><p>3.件读取一个文件，做无向图的广度遍历输出，文件的第一行是图的节点个<br>数，后面是边的信息，0 0表示结束</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;const int MAXN=100;int visit[MAXN];vector&lt;int&gt; G[MAXN];void BFS(int x){//传过来的起始点    queue&lt;int&gt; q;    q.push(x);    visit[x]=true;    while(!q.empty()){//队列        int current=q.front();        cout&lt;&lt;current&lt;&lt;&quot; &quot;;        q.pop();        for(int i=0;i&lt;G[current].size();i++){            if(!visit[G[current][i]]){                //cout&lt;&lt;&quot;没访问&quot;&lt;&lt;G[current][i]&lt;&lt;&quot; &quot;;                q.push(G[current][i]);                visit[G[current][i]]=true;            }        }        //cout&lt;&lt;endl;    }}int main(){    //memset(visit,false,sizeof(visit));//在cstring中    ifstream infile(&quot;in.txt&quot;);//在fstream中    string line;//std::string类似通常的字符数组    string n;    getline(infile,n);    while(getline(infile,line)){        int pos=line.find(&quot; &quot;);        //atoi中要将string转化为char*        int a=atoi((char*)line.substr(0,pos).data());        int b=atoi((char*)line.substr(pos+1).data());        //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;        G[a].push_back(b);        G[b].push_back(a);    }    BFS(1);}</code></pre><p>4.没有括号只有加减乘除的表达式求值，表达式从文件读入，计算的结果<br>输出到文件上。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100;char out[MAXN];//存储逆波兰式stack&lt;char&gt; s1;//生成逆波兰式stack&lt;double&gt; s2;//计算逆波兰式int Priority(char c){    if(c==&#39;*&#39;||c==&#39;/&#39;) return 2;    else if(c==&#39;+&#39;||c==&#39;-&#39;)return 1;    else if(c==&#39;#&#39;) return 3;    else return 0;}bool isop(char c){    return c==&#39;+&#39;||c==&#39;-&#39;||c==&#39;*&#39;||c==&#39;/&#39;;}double cal(double x,double y,char op){    if(op==&#39;+&#39;)return x+y;    else if(op==&#39;-&#39;) return x-y;    else if(op==&#39;*&#39;) return x*y;    else if(op==&#39;/&#39;) return x/y;}void RePolish(string s){    int j=0;//指向out    for(int i=0;i&lt;s.size();i++){        //if(!s1.empty()) cout&lt;&lt;&quot;栈顶：&quot;&lt;&lt;s1.top();        if(isdigit(s[i])){            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;s[i];            out[j++]=s[i];        }        else if(isop(s[i])){            //cout&lt;&lt;&quot;操作符:&quot;&lt;&lt;s[i];            if(s1.empty()) s1.push(s[i]);            else if(Priority(s[i])&gt;Priority(s1.top())){                s1.push(s[i]);            }            else{                while(!s1.empty()&amp;&amp;Priority(s[i])&lt;=Priority(s1.top())){//这里是&lt;=，先进的优先级更高                    out[j++]=s1.top();                    //cout&lt;&lt;&quot;此时栈顶&quot;&lt;&lt;s1.top();                    s1.pop();                }                s1.push(s[i]);            }        }    }    while(!s1.empty()){        out[j++]=s1.top();        s1.pop();    }    return ;}void Calculate(){//根据逆波兰式求值    for(int i=0;i&lt;strlen(out);i++){        if(isdigit(out[i])) s2.push((double)out[i]-&#39;0&#39;);        else if(isop(out[i])){            double b=(double)s2.top(); s2.pop();            double a=(double)s2.top(); s2.pop();            s2.push(cal(a,b,out[i]));        }    }    cout&lt;&lt;s2.top();}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    RePolish(s);    for(int i=0;i&lt;strlen(out);i++){//char*要用strlen而不是.size        cout&lt;&lt;out[i];    }    cout&lt;&lt;endl;    Calculate();}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准c++中string类函数介绍</title>
    <link href="/2020/02/22/%E6%A0%87%E5%87%86c++%E4%B8%ADstring%E7%B1%BB%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/02/22/%E6%A0%87%E5%87%86c++%E4%B8%ADstring%E7%B1%BB%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>注意不是CString<br>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必 担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。</p><p>好了，进入正题………<br>首先，为了在我们的程序中使用string类型，我们必须包含头文件 <string>。</p><p>如下：<br>#include <string> //注意这里不是string.h string.h是C字符串头文件<br>#include <string><br>using namespace std;</p><p><strong>1．声明一个C++字符串</strong><br>声明一个字符串变量很简单：<br>string Str;<br>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：<br>a)      string s;    //生成一个空字符串s<br>b)      string s(str) //拷贝构造函数 生成str的复制品<br>c)      string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值<br>d)      string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值<br>e)      string s(cstr) //将C字符串作为s的初值<br>f)      string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。<br>g)      string s(num,c) //生成一个字符串，包含num个c字符<br>h)      string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值<br>i)      s.~string() //销毁所有字符，释放内存<br>都很简单，我就不解释了。</p><p><strong>2．字符串操作函数</strong><br>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。<br>a) =,assign()     //赋以新值<br>b) swap()     //交换两个字符串的内容<br>c) +=,append(),push_back() //在尾部添加字符<br>d) insert() //插入字符<br>e) erase() //删除字符<br>f) clear() //删除全部字符<br>g) replace() //替换字符<br>h) + //串联字符串<br>i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()    //比较字符串<br>j) size(),length()    //返回字符数量<br>k) max_size() //返回字符的可能最大个数<br>l) empty()    //判断字符串是否为空，是空时返回ture，不是空时返回false<br>m) capacity() //返回重新分配之前的字符容量<br>n) reserve() //保留一定量内存以容纳一定数量的字符<br>o) [ ], at() //存取单一字符<br>p) &gt;&gt;,getline() //从stream读取某值<br>q) &lt;&lt;    //将谋值写入stream<br>r) copy() //将某值赋值为一个C_string<br>s) c_str() //将内容以C_string返回<br>t) data() //将内容以字符数组形式返回<br>u) substr() //返回某个子字符串<br>v)查找函数<br>w)begin() end() //提供类似STL的迭代器支持<br>x) rbegin() rend() //逆向迭代器<br>y) get_allocator() //返回配置器</p><p>下面详细介绍：</p><p><strong>2．1 C++字符串和C字符串的转换</strong><br>C ++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’/0’。c_str()返回一个以‘/0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string或 字符数组内。C++字符串并不以’/0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</p><p><strong>2．2 大小和容量函数</strong><br>一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定， 默认参数为0，这时候会对string进行非强制性缩减。</p><p>还有必要再重复一下C++字符串和C字符串转换的问 题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数Connect(char<em>,char</em>)），但别人的函数参 数用的是char<em>形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char</em>,要想作为上面提及的函数的参数，还必须拷贝到一个char<em>,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果 此函数对参数(也就是char</em>)的内容不修改的话，我们可以这样Connect((char<em>)UserID.c_str(), (char</em>)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char<em>上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char</em>上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</p><p><strong>2．3元素存取</strong><br>我们可以使用下标操作符[]和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用 at()的时候索引无效，会抛出out_of_range异常。</p><p>有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’/0’。其他的各种情况，a.length()索引都是无效的。举例如下：<br>const string Cstr(“const string”);<br>string Str(“string”);<br>Str[3];      //ok<br>Str.at(3);    //ok<br>Str[100]; //未定义的行为<br>Str.at(100);    //throw out_of_range<br>Str[Str.length()]    //未定义行为<br>Cstr[Cstr.length()] //返回 ‘/0’<br>Str.at(Str.length());//throw out_of_range<br>Cstr.at(Cstr.length()) ////throw out_of_range<br>我不赞成类似于下面的引用或指针赋值：<br>char&amp; r=s[2];<br>char* p= &amp;s[3];<br>因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</p><p><strong>2．4比较函数</strong><br>C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string (“aaaa”) &lt;string(aaaaa)。</p><p>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：<br>string s(“abcd”);<br>s.compare(“abcd”); //返回0<br>s.compare(“dcba”); //返回一个小于0的值<br>s.compare(“ab”); //返回大于0的值<br>s.compare(s); //相等<br>s.compare(0,2,s,2,2); //用”ab”和”cd”进行比较 小于零<br>s.compare(1,2,”bcx”,2); //用”bc”和”bc”比较。<br>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？靠，你重修吧！</p><p><strong>2．5 更改内容</strong><br>这在字符串的操作中占了很大一部分。<br>首先讲赋值，第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：<br>s.assign(str); //不说<br>s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串<br>s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给s<br>s.assign(“gaint”); //不说<br>s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘/0’赋给字符串<br>s.assign(5,’x’);//把五个x赋给字符串<br>把字符串清空的方法有三个：s=””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。<br>string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。<br>先说增加字符（这里说的增加是在尾巴上），函数有 +=、append()、push_back()。</p><p>举例如下：<br>s+=str;//加个字符串<br>s+=”my name is jiayp”;//加个C字符串<br>s+=’a’;//加个字符<br>s.append(str);<br>s.append(str,1,3);//不解释了 同前面的函数参数assign的解释<br>s.append(str,2,string::npos)//不解释了<br>s.append(“my name is jiayp”);<br>s.append(“nico”,5);<br>s.append(5,’x’);<br>s.push_back(‘a’);//这个函数只能增加单个字符对STL熟悉的理解起来很简单</p><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。<br>      s.insert(0,”my name”);<br>      s.insert(1,str);<br>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插 入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1, ‘j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指 出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</p><p>删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。</p><p>举例吧：<br>string s=”il8n”;<br>s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_string<br>s.erase(13);//从索引13开始往后全删除<br>s.erase(7,5);//从索引7开始往后删5个</p><p><strong>2．6提取子串和字符串连接</strong><br>题取子串的函数是：substr(),形式如下：<br>s.substr();//返回s的全部内容<br>s.substr(11);//从索引11往后的子串<br>s.substr(5,6);//从索引5开始6个字符<br>把两个字符串结合起来的函数是+。（谁不明白请致电120）</p><p><strong>2．7输入输出操作</strong><br>1．&gt;&gt; 从输入流读取一个string。<br>2．&lt;&lt; 把一个string写入输出流。<br>另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</p><p><strong>2．8搜索与查找</strong><br>查找函数很多，功能也很强大，包括了：<br>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。</p><p>最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)== string::npos)）。</p><p>string类的构造函数：<br>string(const char *s);    //用c字符串s初始化<br>string(int n,char c);     //用n个字符c初始化<br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常</p><p>string类的字符操作：<br>const char &amp;operator[](int n)const;<br>const char &amp;at(int n)const;<br>char &amp;operator[](int n);<br>char &amp;at(int n);<br>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br>const char *data()const;//返回一个非null终止的c字符数组<br>const char *c_str()const;//返回一个以null终止的c字符串<br>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p><p>string的特性描述:<br>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）<br>int max_size()const;    //返回string对象中可存放的最大字符串的长度<br>int size()const;        //返回当前字符串的大小<br>int length()const;       //返回当前字符串的长度<br>bool empty()const;        //当前字符串是否为空<br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p><p>string类的输入输出操作:<br>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p><p>string的赋值：<br>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(const char *s);//用c类型字符串s赋值<br>string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值<br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p><p>string的连接：<br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾<br>string &amp;append(const char *s);            //把c类型字符串s连接到当前字符串结尾<br>string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br>string &amp;append(const string &amp;s);    //同operator+=()<br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c<br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p><p>string的比较：<br>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br>int compare(const string &amp;s) const;//比较当前字符串和s的大小<br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小<br>int compare(const char *s) const;<br>int compare(int pos, int n,const char *s) const;<br>int compare(int pos, int n,const char *s, int pos2) const;<br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0<br>string的子串：<br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p><p>string的交换：<br>void swap(string &amp;s2);    //交换当前字符串与s2的值</p><p>string类的查找函数：<br>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br>int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>//查找成功时返回所在位置，失败返回string::npos的值<br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br>int rfind(const char *s, int pos = npos) const;<br>int rfind(const char *s, int pos, int n = npos) const;<br>int rfind(const string &amp;s,int pos = npos) const;<br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值<br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br>int find_first_of(const char *s, int pos = 0) const;<br>int find_first_of(const char *s, int pos, int n) const;<br>int find_first_of(const string &amp;s,int pos = 0) const;<br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos<br>int find_first_not_of(char c, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos,int n) const;<br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos<br>int find_last_of(char c, int pos = npos) const;<br>int find_last_of(const char *s, int pos = npos) const;<br>int find_last_of(const char *s, int pos, int n = npos) const;<br>int find_last_of(const string &amp;s,int pos = npos) const;<br>int find_last_not_of(char c, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos, int n) const;<br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p><p>string类的替换函数：<br>string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br>string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s<br>string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p><p>string类的插入函数：<br>string &amp;insert(int p0, const char *s);<br>string &amp;insert(int p0, const char *s, int n);<br>string &amp;insert(int p0,const string &amp;s);<br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br>void insert(iterator it, int n, char c);//在it处插入n个字符c</p><p>string类的删除函数<br>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p><p>string类的迭代器处理：<br>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。</p><p>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br>const_iterator begin()const;<br>iterator begin();                //返回string的起始位置<br>const_iterator end()const;<br>iterator end();                    //返回string的最后一个字符后面的位置<br>const_iterator rbegin()const;<br>iterator rbegin();                //返回string的最后一个字符的位置<br>const_iterator rend()const;<br>iterator rend();                    //返回string第一个字符位置的前面<br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p><p>字符串流处理：<br>通过定义ostringstream和istringstream变量实现，<sstream>头文件中<br>例如：<br>string input(“hello,this is a test”);<br>istringstream is(input);<br>string s1,s2,s3,s4;<br>is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br>ostringstream os;<br>os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br>cout&lt;&lt;os.str();</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_07上</title>
    <link href="/2020/02/22/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8A/"/>
    <url>/2020/02/22/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>1.编写程序，判断回文数</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int Reverse(int x){    int result=0;    while(x!=0){        result=result*10+x%10;        x/=10;    }    return result;}int main(){    int n;    while(cin&gt;&gt;n){        if(Reverse(n)==n) cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;    }}</code></pre><p>2.队列的循环报数问题</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){    int n;    cin&gt;&gt;n;    queue&lt;int&gt; q;o    for(int i=1;i&lt;=n;i++) q.push(i);    while(!q.empty()){        cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;;//报号1        q.pop();        if(!q.empty()){            q.push(q.front());//报号2            q.pop();        }    }}</code></pre><p>3.图的最小生成树</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1001;struct Edge{    int from;    int to;    int length;    bool operator&lt; (const Edge&amp; e) const{        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(x!=father[x]) father[x]=Find(father[x]);    return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[y]&lt;height[x]) father[y]=x;        else{            father[y]=x;            height[x]++;        }    }    return ;}int kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //即from与to上溯的根结点不一样        //也即加上edge[i]不会形成环        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        //用于给了两两之间的距离修路的问题        int edgeNumber=n*(n-1)/2;        for(int i=0;i&lt;edgeNumber;i++){            cin&gt;&gt;edge[i].from&gt;&gt;edge[i].to&gt;&gt;edge[i].length;        }        int answer=kruskal(n,edgeNumber);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre><p>4.后序中序得先序</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};string in;string post;TreeNode* postin(int l1,int h1,int l2,int h2){    char data=post[h1];    cout&lt;&lt;data&lt;&lt;endl;    TreeNode* T=new TreeNode(data);    int i;    for(i=l2;data!=in[i];i++);//这里i的开头是l2    int llen=i-l2;    int rlen=h2-i;    if(llen) T-&gt;left=postin(l1,l1+llen-1,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=postin(h1-rlen,h1-1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}void PreOrder(TreeNode* T){    if(T==NULL) return;    cout&lt;&lt;T-&gt;data;    PreOrder(T-&gt;left);    PreOrder(T-&gt;right);}int main(){    cin&gt;&gt;post&gt;&gt;in;    TreeNode* root=postin(0,post.size()-1,0,in.size()-1);    PreOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_06下</title>
    <link href="/2020/02/21/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8B/"/>
    <url>/2020/02/21/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.统计一个字符串当中有多少字母、数字、空格和其它字符；</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int count_zimu=0,count_shuzi=0,count_space=0,count_others=0;void Count(char c){    if(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) count_shuzi++;    else if((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) count_zimu++;    else if(c==&#39; &#39;) count_space++;    else count_others++;}int main(){    string s;3r    getline(cin,s);    for(int i=0;i&lt;s.size();i++){        Count(s[i]);    }    cout&lt;&lt;count_zimu&lt;&lt;&quot; &quot;&lt;&lt;count_shuzi&lt;&lt;&quot; &quot;&lt;&lt;count_space&lt;&lt;&quot; &quot;&lt;&lt;count_others&lt;&lt;endl;}</code></pre><p>2.给你一个 10进制数，要你输出  8进制数；</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(){    int n;    stack&lt;int&gt; result;    cin&gt;&gt;n;    while(n!=0){        result.push(n%8);        n/=8;    }    while(!result.empty()){        cout&lt;&lt;result.top();        result.pop();    }}</code></pre><p>3.给你一个数，要求你求出这个数与其反序数的和相加多少次才可以得到回<br>文字</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int Reverse(int x){//求逆序    int result=0;    while(x!=0){        result=result*10+x%10;        x/=10;    }    return result;}bool ishuiwen(int x){//判断回文    if(Reverse(x)==x) return true;    else return false;}int main(){    int time=0;    int n;    cin&gt;&gt;n;    while(!ishuiwen(n)){        n=n+Reverse(n);        time++;    }    cout&lt;&lt;time&lt;&lt;endl;}</code></pre><p>4.给你一个数列，求出最大子序列之和</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=100;int a[MAXN];int dp[MAXN];int main(){    int n;    cin&gt;&gt;n;    int Max=0;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];    }    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];        else dp[i]=max(a[i],dp[i-1]+a[i]);        if(dp[i]&gt;Max) Max=dp[i];    }    cout&lt;&lt;Max&lt;&lt;endl;}</code></pre><p>5.给你几个整数，求出最大的组合数</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100;vector&lt;string&gt; v;//使用字典序可以快速解决这道题bool compare(string x,string y){    return x&gt;y;}int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        string num;        cin&gt;&gt;num;        v.push_back(num);    }    sort(v.begin(),v.end(),compare);    for(int i=0;i&lt;n;i++){        cout&lt;&lt;v[i];    }}</code></pre><p>6.关于图的最大连通分量</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;#define maxn 10001using namespace std;vector&lt;int&gt;G[maxn];stack&lt;int&gt;s;int n,m;int dfn[maxn],used[maxn],vis[maxn],low[maxn],color[maxn],num[maxn],colornum=0,cnt=0,ans=0;void paint(int x){    s.pop();    color[x]=colornum;    num[colornum]++;    vis[x]=false;}void tarjan(int x){    dfn[x]=low[x]=++cnt;//依次深搜并且对dfn和low初始化    s.push(x);    vis[x]=used[x]=true;//置访问标记    for(int i=0;i&lt;G[x].size();i++){//遍历当前节点的所有边        int q=G[x][i];        if (!dfn[q]){//如果边没有被访问过，即没有被dfn初始化            tarjan(q);            low[x]=min(low[x],low[q]);        }        else if (vis[q]) low[x]=min(low[x],dfn[q]);//如果    }    if (low[x]==dfn[x]){//满足强连通分量的条件        colornum++;        while(s.top()!=x){            int t=s.top();            paint(t);        }        paint(x);    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int u,v;        cin&gt;&gt;u&gt;&gt;v;        G[u].push_back(v);    }    for(int i=1;i&lt;=n;i++){        if (!used[i]) tarjan(i);    }    for(int i=1;i&lt;=colornum;i++){        if (num[i]&gt;0) ans++;    }    cout&lt;&lt;ans;    return 0;}</code></pre><p>7.用二叉树，给你先序和中序遍历，输出后续遍历</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;string pre,post;struct TreeNode{    char c;    TreeNode* left;    TreeNode* right;    TreeNode(char c):c(c){}};TreeNode* PreInCreat(int l1,int h1,int l2,int h2){    TreeNode* T=new TreeNode(pre[l1]);//根结点    int i;    for(i=l2;post[i]!=T-&gt;c;i++) ;//根结点在中序序列中的划分    int llen=i-l2;//左子树长度    int rlen=h2-i;//右子树长度    //这里的上下限画个图就清楚了    if(llen) T-&gt;left=PreInCreat(l1+1,l1+llen,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=PreInCreat(h1-rlen+1,h1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}void PostOrder(TreeNode* T){    if(T==NULL) return;    else{        PostOrder(T-&gt;left);        PostOrder(T-&gt;right);        cout&lt;&lt;T-&gt;c;    }}int main(){    cin&gt;&gt;pre&gt;&gt;post;    TreeNode* root=PreInCreat(0,pre.size()-1,0,post.size()-1);    PostOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法中的常用代码</title>
    <link href="/2020/02/21/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/02/21/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><strong>并查集模板</strong><br>主要用于解决关于连通的一些问题</p><pre><code class="cpp">void Initial(){    for(int i=0;i&lt;MAXN;i++){        father[i]=i;//根结点指向自己        height[i]=0;        //inDegree[i]=0;        //visit[i]=false;    }}int Find(int x){    if(father[x]!=x) father[x]=Find(father[x]);//注意写法，路径压缩    return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;//前面两种情况树高并没有变        else{            father[y]=x;            height[x]++;        }    }    return ;}</code></pre><p><strong>邻接表</strong></p><pre><code class="cpp">struct Edge{    int to;    int length;    Edge(int t,int l):to{t},length(l){}};vector&lt;Edge&gt; graph[MAXN];</code></pre><p><strong>广度优先搜索</strong></p><pre><code class="cpp">struct Status{    int n,t;//t表示起点到n的时间    Status(int n,int t):n(n),t(t){}};bool visit[MAXN];int BFS(int n,int k){    queue&lt;Status&gt; myqueue;    myqueue.push(Status(n,0)); //初始状态    visit[n]=true;   //起始点已被访问    while(!myqueue.empty()){        Status current=myqueue.front();        myqueue.pop();        if(current.n==k) return current.t;  //查找成功        for(int i=0;i&lt;3;i++){       //转入三种不同的状态            Status next(current.n,current.t+1);            if(i==0) next.n+=1;            else if(i==1) next.n-=1;            else next.n*=2;            if(next.n&lt;0||next.n&gt;=MAXN||visit[next.n]) continue;//新状态不合法            myqueue.push(next);            visit[next.n]=true;//置访问标记        }    }}</code></pre><p><strong>深度优先搜索</strong></p><pre><code class="cpp">int side; //边长int m;  //树枝数目int sticks[MAXN];bool visit[MAXN];bool DFS(int sum,int number,int position){    if(number==3) return true;    int sample=0;       //剪枝(3)    for(int i=position;i&lt;m;i++){        if(visit[i]||sum+sticks[i]&gt;side||sticks[i]==sample) continue;        visit[i]=true;        if(sum+sticks[i]==side){    //能凑成一条边            if(DFS(0,number+1,0)) return true;            else sample=sticks[i];  //记录失败的棍子的长度        }        else{            if(DFS(sum+sticks[i],number,i+1)) return true;            else sample=sticks[i];  //记录失败的棍子的长度        }        visit[i]=false;    }    return false;}</code></pre><p><strong>最小生成树</strong></p><pre><code class="cpp">int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}</code></pre><p><strong>最短路径</strong></p><pre><code class="cpp">struct Point{//结点    int number;    int distance;    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; p) const{//重载小于        return distance&gt;p.distance;    }};int dis[MAXN];void Dijkstra(int s){    priority_queue&lt;Point&gt; pqueue;    dis[s]=0;    pqueue.push(Point(s,dis[s]));    while(!pqueue.empty()){        int u=pqueue.top().number;//离源点最近的点        pqueue.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;//u为顶点的编号，i为边的序号            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){                dis[v]=dis[u]+d;                pqueue.push(Point(v,dis[v]));            }        }    }    return ;}</code></pre><p><strong>拓扑排序</strong></p><pre><code class="cpp">int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}</code></pre><p><strong>关键路径</strong><br>基于拓扑顺序去遍历的</p><pre><code class="cpp">void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_06上</title>
    <link href="/2020/02/18/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8A/"/>
    <url>/2020/02/18/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>2.给出四个[年,月],判断此月有多少天.题目给出了闰年判断方法的伪代码.</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int months[2][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},//平年    {0,31,29,31,30,31,30,31,31,30,31,30,31}//闰年};bool isrein(int year){    return (year%400==0)||(year%4==0&amp;&amp;year%100!=0);}int main(){    int year,month;    while(cin&gt;&gt;year&gt;&gt;month){        if(isrein(year)) cout&lt;&lt;months[1][month];        else cout&lt;&lt;months[0][month];    }}</code></pre><p>3.给出一些标识符,判断合法标识符有多少个.(与 C语言中标识符定义一致.)</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;bool first(char c){    return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)||(c==&#39;_&#39;);}bool others(char c){    return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)||isdigit(c)||(c==&#39;_&#39;);}int main(){    int n;    while(cin&gt;&gt;n){        vector&lt;string&gt; v;        int Count=0;        for(int i=0;i&lt;n;i++){            string s;            cin&gt;&gt;s;            v.push_back(s);        }        for(int i=0;i&lt;v.size();i++){            string s1=v[i];            if(first(s1[0])){                bool flag=true;                for(int j=1;j&lt;s1.size();j++){                    if(!others(s1[j])) flag=false;                }                if(flag) Count++;            }            else continue;        }        cout&lt;&lt;Count&lt;&lt;endl;    }}</code></pre><p>4.第四道,给出无向图连接矩阵,求各个连通分量</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;const int MAXN=1000;int father[MAXN];int height[MAXN];//以该节点为根的树的高度using namespace std;void Initial(){    for(int i=0;i&lt;MAXN;i++){        father[i]=i;        height[i]=0;        //inDegree[i]=0;        //visit[i]=false;    }}int FindRoot(int x){    if(father[x]!=x) father[x]=FindRoot(father[x]);//注意写法    return father[x];}void Union(int x,int y){    x=FindRoot(x);    y=FindRoot(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;//前面两种情况树高并没有变        else{            father[y]=x;            height[x]++;        }    }    return ;}int main(){    FILE *fp1,*fp2;//1.定义指针    fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;);//2.指向文件    fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;);    int n;    fscanf(fp1,&quot;%d&quot;,&amp;n);//3.进行读写    Initial();    while(!feof(fp1)){        int a,b;        fscanf(fp1,&quot;%d&quot;,&amp;a);        fscanf(fp1,&quot;%d&quot;,&amp;b);        Union(a,b);    }    vector&lt;int&gt; roots;    for(int i=1;i&lt;=n;i++){//因为序号是从1开始        if(FindRoot(i)==i){            roots.push_back(i);        }    }}</code></pre><p>5.给出一个整数分解成尽可能多的连续整数的和</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int main(){    int n;    while(cin&gt;&gt;n){        int maxi=0,maxj=0;        bool flag=false;        for(int i=1;i&lt;=n/2;i++){            int sum=0;            for(int j=2;j&lt;n;j++){//j表示从i开始往后连续的长度                sum=(i+i+j-1)*j/2;                if(sum&gt;n) break;                else if(sum==n){                    flag=true;                    if(j&gt;maxj){                        maxi=i;                        maxj=j;                    }                }            }        }        if(flag){            for(int i=maxi;maxj&gt;0;maxj--,i++){                cout&lt;&lt;i&lt;&lt;&quot; &quot;;            }            cout&lt;&lt;endl;        }        else cout&lt;&lt;&quot;分解失败&quot;&lt;&lt;endl;    }}</code></pre><p>6.给出带括号的四则运算表达式,要求给出逆波兰式</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;stack&lt;char&gt; Stack;char output[500];int outLen;int Priority(char c){//判断运算符优先级    if(c==&#39;*&#39;||c==&#39;/&#39;) return 2;    else if(c==&#39;+&#39;||c==&#39;-&#39;) return 1;    else return 0;//&#39;(&#39;}bool isOperator(char op)                //判断是不是操作符{    return (op==&#39;+&#39; || op==&#39;-&#39; || op==&#39;*&#39; || op==&#39;/&#39;);}void rePolish(string s,int len){//输出逆波兰式    memset(output,&#39;\0&#39;,sizeof(output));    outLen=0;    for(int i=0;i&lt;len;++i){        //操作数        if(isdigit(s[i])){            cout&lt;&lt;&quot;shu:&quot;&lt;&lt;s[i]&lt;&lt;endl;            output[outLen++] = s[i];            while (i+1&lt;len&amp;&amp;isdigit(s[i+1])){                output[outLen++] = s[i+1];                ++i;            }            output[outLen++] = &#39; &#39;;        //空格隔开        }        //运算符        else if (isOperator(s[i])){            cout&lt;&lt;&quot;fu:&quot;&lt;&lt;s[i]&lt;&lt;endl;            if(!Stack.empty()&amp;&amp;Priority(Stack.top())&gt;=Priority(s[i])){                while(Priority(Stack.top())&gt;=Priority(s[i])){                    output[outLen++]=Stack.top();                    output[outLen++] = &#39; &#39;;                    Stack.pop();                }            }            else Stack.push(s[i]);//栈为空，或者栈顶优先级更小        }        //&#39;(&#39;        else if (s[i]==&#39;(&#39;){            cout&lt;&lt;&quot;(:&quot;&lt;&lt;s[i]&lt;&lt;endl;            Stack.push(s[i]);        }        //&#39;)&#39;        else if (s[i]==&#39;)&#39;){            cout&lt;&lt;&quot;):&quot;&lt;&lt;s[i]&lt;&lt;endl;            while (Stack.top()!=&#39;(&#39;){                output[outLen++] = Stack.top();                output[outLen++] = &#39; &#39;;                Stack.pop();            }            Stack.pop();// 此时Stack.top()=&#39;(&#39;,跳过)        }        else continue;    }    while (!Stack.empty()){//输入完毕，栈中剩余的所有操作符出栈        output[outLen++] = Stack.top();        output[outLen++] = &#39; &#39;;        Stack.pop();    }}int main(){    string s;    while (getline(cin,s)){        cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;s.size();        Stack.push(&#39;#&#39;);        rePolish(s,s.size());        output[outLen-1] = &#39;\0&#39;;        printf(&quot;%s\n&quot;,output);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划状态转移公式</title>
    <link href="/2020/02/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/02/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>最大连续子序列和</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最大连续子序列和</td><td align="left">在一个给定的序列中，找出一个连续的子序列，使得这个子序列的和最大</td><td align="left">dp[i]表示以A[i]作为末尾的连续序列最大和&#124;dp[i]=max(A[i],dp[i-1]+A[i])</td><td align="left"></td></tr></tbody></table><p>转移情况：<br>①最大和的连续序列只有一个元素，即A[i]本身，为A[i]<br>②最大和的连续序列有多个元素，即从A[j]开始到A[i]，为dp[i-1]+A[i]</p><pre><code class="cpp">int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}</code></pre><p><strong>最长递增子序列</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最长递增子序列</td><td align="left">在一个给定的序列中，找出一个的最长的递增子序列（不必连续）</td><td align="left">dp[i]表示以A[i]作为末尾的最长递增子序列长度</td><td align="left">dp[i]=max(1,dp[j]+1 | j&lt;i&amp;&amp;A[j]&lt;A[i])</td></tr></tbody></table><p>转移情况：<br>①A[i]之前的元素都比A[i]大，即最长递增子序列只有A[i]本身，为dp[i]=1<br>②A[i]之前的元素A[j]比A[i]小此时只需将A[i]添加到以A[j]为末尾的最长递增子序列,而求长度则是通过将i之前的元素逐一遍历，就可以获得dp[i]</p><pre><code class="cpp">  int answer=0;  for(int i=0;i&lt;n;i++){      dp[i]=1;//初始化为1      for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度          if(height[i]&lt;=height[j]){              dp[i]=max(dp[i],dp[j]+1);          }      }      answer=max(answer,dp[i]);  }</code></pre><p><strong>最长公共子序列</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最长公共子序列</td><td align="left">给定字符串s1,s2求一个最长的公共子序列(不一定连续)</td><td align="left">dp[i][j]表示以s1[i]作为末尾和以s2[j]为末尾的最长公共子序列的长度</td><td align="left">dp[i][j]=dp[i-1][j-1]+1(s1[i]=s2[j])___   否则dp[i][j]==max(dp[i-1][j],dp[i][j-1])</td></tr></tbody></table><p>转移情况：<br>①s1[i]=s2[j]，此时比存在一个最长公共子序列以s1[i]和s2[j]结尾，其他部分相当于s1的前i-1和s2的前j-1个字符的最长公共子序列，为dp[i-1][j-1]+1<br>②s1[i]!=s2[j],此时最长公共子序列的长度为<u>s1的前i-1个字符和s2的前j个字符的最长公共子序列</u>与<u>s1的前i个字符和s2中的前j-1个字符的最长公共子串</u>的较大者，为max(dp[i-1][j],dp[i][j-1])</p><p>边界情况：<br>dp[i][0]=0;       dp[0][j]=0;</p><pre><code class="cpp">while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入    int n=strlen(s1+1);    int m=strlen(s2+1);    for(int i=0;i&lt;=n;i++){        for(int j=0;j&lt;=m;j++){            if(i==0||j==0){//边界条件初始化                dp[i][j]=0;                continue;            }            //状态转移方程            if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);        }    }    cout&lt;&lt;dp[n][m]&lt;&lt;endl;}</code></pre><p><strong>背包问题</strong></p><ul><li>0-1背包</li></ul><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">0–1背包</td><td align="left">n种物品(<u>一种只取一次</u>),重量分别为w[i],现有容量为m背包,要使装进背包物品价值最大</td><td align="left">dp[i][j]表示前i个物品装进容量为j的背包能获得的最大价值</td><td align="left">dp[j]=max(dp[j],dp[j-w[i]]+v[i])</td></tr></tbody></table><p>转移情况：<br>①对于容量为j的背包，如果不放入第i件物品，问题就转化成了前i-1个物品放入容量为j的背包的问题，为dp[i-1][j]<br>②对于容量为j的背包，如果放入第i件物品，问题就转化成了将前面i-1个物品放入容量为j-w[i]的背包的问题，为dp[i-1][j-w[i]]+v[i]<br>最终转化成了dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])<br>经观察dp[i][j]只与二维数组中本行的上一行有关，根据这个可以将二维数组优化为一维数组：<br>dp[j]=max(dp[j],dp[j-w[i]+v[i])</p><p>边界情况：<br>dp[i][0]=0;       dp[0][j]=0;</p><pre><code class="cpp">for(int i=0;i&lt;=m;i++){    dp[i]=0;//初始化}for(int i=0;i&lt;n;i++){    for(int j=m;j&gt;=w[i];j--){        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);    }}</code></pre><ul><li><del>完全背包</del> ：暂时不是很理解(╯°Д°)╯︵┻━┻</li><li><del>多重背包</del> ：暂时不是很理解ヽ(｀Д´)ﾉ︵ ┻━┻ ┻━┻ </li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小邮票数</title>
    <link href="/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/"/>
    <url>/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。</p><p><strong>输入描述:</strong><br>    有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。</p><p><strong>输出描述:</strong><br>      对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。</p><p><strong>输入</strong></p><blockquote><p>10<br>5<br>1 3 3 3 4</p></blockquote><p><strong>输出</strong></p><blockquote><p>3</p></blockquote><pre><code class="cpp">/*    最少邮票数 &gt;&gt; 01动态规划    状态    集合中数字    dp[i][j]    0   1   2   3   4   5   6   7   8   9   10    1           0   1   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞    1 3         0   1   ∞   1   2   ∞   ∞   ∞   ∞   ∞   ∞    1 3 3       0   1   ∞   1   2   ∞   2   3   ∞   ∞   ∞    1 3 3 3     0   1   ∞   1   2   ∞   2   ∞   ∞   3   4    1 3 3 3 4   0   1   ∞   1   2   2   2   2   3   3   3      状态迁移方程    dp[j] = min{dp[j],dp[j-stamp[i]]+1}    其中dp[j-stamp[i]]+1，表示将第i个邮票加入集合后 凑总量为j的面额 所需要的最少邮票数量*/#include&lt;stdio.h&gt;#define INF 1000int stamp[1000];int dp[1000];// 返回最少数量，num表示邮票的个数，deno表示要凑成的面额int Min_Stamp(int num,int deno){    int i,j;    //将状态全部初始化为最多    for(j=0;j&lt;=deno;++j){        dp[j]= (j==0)?0:INF;           }    for(i=0;i&lt;num;i++){        //从后向前寻找若能凑成，且使数量变少就使用，不能也无所谓因为还是INF        for(j=deno;j&gt;=stamp[i];j--){            if(dp[j-stamp[i]]!=INF)dp[j]=(dp[j] &lt; dp[j-stamp[i]]+1)? dp[j]: dp[j-stamp[i]]+1;        }    }    return dp[deno]==INF?0:dp[deno];}int main(){    int num,deno;    while(scanf(&quot;%d %d&quot;,&amp;deno,&amp;num)!=EOF){        for(int i=0;i&lt;num;i++)scanf(&quot;%d&quot;,stamp+i);        printf(&quot;%d&quot;,Min_Stamp(num,deno));    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点菜问题</title>
    <link href="/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    北大网络实验室经常有活动需要叫外卖，但是每次叫外卖的报销经费的总额最大为C元，有N种菜可以点，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大。     注意：由于需要营养多样化，每种菜只能点一次。</p><p><strong>输入描述:</strong><br>    输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。</p><p><strong>输出描述:</strong><br>    输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。</p><p><strong>输入</strong></p><blockquote><p>90 4<br>20 25<br>30 20<br>40 50<br>10 18<br>40 2<br>25 30<br>10 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>95 38</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//背包问题using namespace std;const int MAXN=1001;int dp[MAXN];int v[MAXN];//物品价值int w[MAXN];//物品重量int main(){    int n,m;    cin&gt;&gt;m&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=0;i&lt;=m;i++){        dp[i]=0;//初始化    }    for(int i=0;i&lt;n;i++){        for(int j=m;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[m]&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/14/Common%20Subsequence/"/>
    <url>/2020/02/14/Common%20Subsequence/</url>
    
    <content type="html"><![CDATA[<p><strong>Description</strong><br>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><p><strong>Input</strong><br>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><p><strong>Output</strong><br>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><p><strong>Sample Input</strong></p><blockquote><p>abcfbc            abfcab<br>programming    contest<br>abcd           mnp</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4<br>2<br>0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//最长公共子序列using namespace std;const int MAXN=1001;char s1[MAXN];char s2[MAXN];int dp[MAXN][MAXN];int main(){    while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入        int n=strlen(s1+1);        int m=strlen(s2+1);        for(int i=0;i&lt;=n;i++){            for(int j=0;j&lt;=m;j++){                if(i==0||j==0){//边界条件初始化                    dp[i][j]=0;                    continue;                }                //状态转移方程                if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK， 则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>输入描述:</strong><br>输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。<br>第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。</p><p><strong>输出描述:</strong><br>可能包括多组测试数据，对于每组数据，<br>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><p><strong>输入</strong></p><blockquote><p>8<br>186 186 150 200 160 130 197 220</p></blockquote><p><strong>输出</strong></p><blockquote><p>4</p></blockquote><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;int num[100];int dp1[100];int dp2[100];//枚举每个位置，从左边找最长上升子序列，从右边开始找最长下降子序列，两个数相加就是题目所说的唱歌的人数。int main(){    int count;    while(cin&gt;&gt;count){        for(int i=0;i&lt;count;i++){            cin&gt;&gt;num[i];        }        for(int i=0;i&lt;count;i++){            dp1[i]=1;            for(int j=0;j&lt;i;j++){                if(num[i]&gt;num[j]){                    dp1[i]=max(dp1[j]+1,dp1[i]);                }            }        }        for(int i=count-1;i&gt;=0;i--){            dp2[i]=1;            for(int j=count-1;j&gt;i;j--){                if(num[i]&gt;num[j]){                    dp2[i]=max(dp2[i],dp2[j]+1);                }            }        }        int total=0;        for(int i=0;i&lt;count;i++){//i此时是作为最中间的一个点            total=max(dp1[i]+dp2[i]-1,total);        }        cout&lt;&lt;count-total&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大上升子序列和</title>
    <link href="/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p><p><strong>输入描述:</strong><br>输入包含多组测试数据。<br>每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</p><p><strong>输出描述:</strong><br>对于每组测试数据，输出其最大上升子序列和。</p><p><strong>输入</strong></p><blockquote><p>7<br>1 7 3 5 9 4 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>18</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1001;int a[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=a[i];//初始化为a[i]            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列                if(a[i]&gt;a[j]){                    dp[i]=max(dp[i],dp[j]+a[i]);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拦截导弹</title>
    <link href="/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/"/>
    <url>/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。 </p><p><strong>输入描述:</strong><br>每组输入有两行，<br>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），<br>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p><p><strong>输出描述:</strong><br>每组输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p><p><strong>输入</strong></p><blockquote><p>8<br>300 207 155 300 299 170 158 65</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//动态规划：最长递增子序列//状态转移方程：dp[i]=max(1,dp[j]+1|j&lt;i&amp;&amp;Aj&gt;Ai)using namespace std;const int MAXN=25;int height[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;height[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=1;//初始化为1            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度                if(height[i]&lt;=height[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。<br><strong>输入描述:</strong><br>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。<br>再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。<br>已知矩阵中整数的范围都在[-127, 127]。<br><strong>输出描述:</strong><br>测试数据可能有多组，对于每组测试数据，输出最大子矩阵的大小。<br>示例1<br><strong>输入</strong></p><blockquote><p>4<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4  1<br>-1 8  0 -2</p></blockquote><p><strong>输出</strong></p><blockquote><p>15</p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN=100;int dp[MAXN];int arr[MAXN];int matrix[MAXN][MAXN];int total[MAXN][MAXN];//total[i][j]表示从这个元素往上的所有元素的和int MaxSubsequence(int n){    int maximum=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=arr[i];        else dp[i]=max(dp[i-1]+arr[i],arr[i]);        maximum=max(maximum,dp[i]);    }    return maximum;}int maxSubmatrix(int n){    int maximal=0;    for(int i=0;i&lt;n;i++){        for(int j=i;j&lt;n;j++){//            for(int k=0;k&lt;n;k++){//获得一维数组                if(i==0) arr[k]=total[j][k];                else arr[k]=total[j][k]-total[i-1][k];            }        int current =MaxSubsequence(n);        maximal = max(maximal,current);        }    }    return maximal;}int main(){    int N;    while(cin&gt;&gt;N){        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                cin&gt;&gt;matrix[i][j];            }        }        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                if(i==0) total[i][j]=matrix[i][j];                else total[i][j]=total[i-1][j]+matrix[i][j];            }        }        int result=maxSubmatrix(N);        cout&lt;&lt;result&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。<br><strong>输入描述:</strong><br>    测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。<br><strong>输出描述:</strong><br>    对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。<br><strong>输入</strong></p><blockquote><p>6<br>-2 11 -4 13 -5 -2 10<br>-10<br>1 2 3 4 -5 -23 3 7 -21<br>6<br>5 -8 3 2 5 0<br>1<br>10<br>3<br>-1 -5 -2<br>3<br>-1 0 -2<br>0</p></blockquote><p><strong>输出</strong></p><blockquote><p>20 11 13<br>10 1 4<br>10 3 5<br>10 10 10<br>0 -1 -2<br>0 0 0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=10000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];void maxSub(int n,int&amp; Max,int&amp; first,int&amp; last){    Max=0,first=0,last=n-1;    //第一次遍历找出最大子序列和    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    //第二次遍历确定最大子序列的两个边界    for(int i=0;i&lt;n;i++){        if(i==0){            dp[i]=a[i];        }        else if(dp[i-1]+a[i]&gt;a[i]){            last=i;//当前子序列继续扩充元素            dp[i]=dp[i-1]+a[i];        }        else{            first=i;//从当前的元素重新往后找，赋值first            dp[i]=a[i];        }        if(dp[i]==Max){            last=i;//此时已经找到最大的子序列，给last赋最终值            return;        }    }}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int Max,first,last;        maxSub(n,Max,first,last);        cout&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;a[first]&lt;&lt;&quot; &quot;&lt;&lt;a[last]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大序列和</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。<br><strong>输入描述</strong>:<br>第一行为一个正整数N，第二行为N个整数，表示序列中的数。<br><strong>输出描述:</strong><br>输入可能包括多组数据，对于每一组输入数据，<br>仅输出一个数，表示最大序列和。<br><strong>输入</strong></p><blockquote><p>5<br>1 5 -3 2 4<br>6<br>1 -2 3 4 -10 6<br>4<br>-3 -1 -2 -5</p></blockquote><p><strong>输出</strong></p><blockquote><p>9<br>7<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        cout&lt;&lt;maxSub(n)&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文</title>
    <link href="/2020/02/11/%E8%AE%BA%E6%96%87/"/>
    <url>/2020/02/11/%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>小H为了完成一篇论文，一共要完成n个实验。其中第i个实验需要ai的时间去完成。小H可以同时进行若干实验，但存在一些实验，只有当它的若干前置实验完成时，才能开始进行该实验。同时我们认为小H在一个实验的前置实验都完成时，就能马上开始该实验。为了让小H尽快完成论文，需要知道在最优的情况下，最后一个完成的实验什么时候完成？小H还想知道，在保证最后一个实验尽快完成的情况下（即保证上一问的答案不变），他想知道每个实验最晚可以什么时候开始。设第i个实验最早可能的开始时间为fi，不影响最后一个实验完成时间的最晚开始时间为gi，请你证明<img src="https://img-blog.csdnimg.cn/20200211171228484.png" srcset="/img/loading.gif" alt="">除以10^9+7所得的余数。题目保证有解。</p><p><strong>输入描述:</strong><br>从标准输入读入数据。<br>第一行输入一个整数n，m。<br>第二行输入n个正整数，a1,a2,…..an,描述每个实验完成所需要的时间。<br>接下来读入m行，每行读入两个整数u,v，表示编号为u的实验是编号为v的实验的前置实验。<br>对于所有的输入数据，都满足1&lt;=n&lt;=10^5,1&lt;=m&lt;=5<em>10^5,1&lt;=ai&lt;=10^6。<br>*</em>输出描述:**<br>输出到标准输出。<br>第一行输出一个整数表示最晚完成的实验的时间。<br>第二行输出一个整数表示除以10^9+7所得的余数。<br>输入输出样例<br><strong>输入样例#:</strong></p><blockquote><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p></blockquote><p><strong>输出样例#:</strong></p><blockquote><p>34<br>7840</p></blockquote><p>提示：<br>第一个点最早开始时间为20，最晚开始时间为23。<br>第二个点最早开始时间为0，最晚开始时间为3。<br>第三个点最早开始时间为17，最晚开始时间为17。<br>第四个点最早开始时间为20，最晚开始时间为24。<br>第五个点最早开始时间为0，最晚开始时间为13。<br>第六个点最早开始时间为0，最晚开始时间为6。<br>第七个点最早开始时间为0，最晚开始时间为0。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1e5+7;const int INF=INT_MAX;const int MOD=1e9+7;vector&lt;int&gt; graph[MAXN];//邻接表long long earliest[MAXN];//最早开始时间long long latest[MAXN];//最晚开始时间long long time[MAXN];//花费时间int inDegree[MAXN];long long CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=1;i&lt;=n;i++){        if(inDegree[i]==0){            node.push(i);        }    }    long long totalTime=0;//总耗时    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i];            earliest[v]=max(earliest[v],earliest[u]+time[u]);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0){                node.push(v);                totalTime=max(totalTime,earliest[v]+time[v]);            }        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=totalTime-time[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j];            latest[u]=min(latest[u],latest[v]-time[u]);//逆向找最小，形成latest        }    }    return totalTime;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        memset(time,0,sizeof(time));        for(int i=1;i&lt;=n;i++){            cin&gt;&gt;time[i];        }        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;        }        long long totalTime=CriticalPath(n);        long long answer=1;        for(int i=1;i&lt;=n;i++){            answer*=latest[i]-earliest[i]+1;            answer%=MOD;        }        cout&lt;&lt;totalTime&lt;&lt;endl;        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction Arrangement</title>
    <link href="/2020/02/11/Instruction%20Arrangement/"/>
    <url>/2020/02/11/Instruction%20Arrangement/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>Ali has taken the Computer Organization and Architecture course this term. He learned that there may be dependence between instructions, like WAR (write after read), WAW, RAW.<br>If the distance between two instructions is less than the Safe Distance, it will result in hazard, which may cause wrong result. So we need to design special circuit to eliminate hazard. However the most simple way to solve this problem is to add bubbles (useless operation), which means wasting time to ensure that the distance between two instructions is not smaller than the Safe Distance.<br>The definition of the distance between two instructions is the difference between their beginning times.<br>Now we have many instructions, and we know the dependent relations and Safe Distances between instructions. We also have a very strong CPU with infinite number of cores, so you can run as many instructions as you want simultaneity, and the CPU is so fast that it just cost 1ns to finish any instruction.<br>Your job is to rearrange the instructions so that the CPU can finish all the instructions using minimum time.<br><strong>Input</strong><br>The input consists several testcases.<br>The first line has two integers N, M (N &lt;= 1000, M &lt;= 10000), means that there are N instructions and M dependent relations.<br>The following M lines, each contains three integers X, Y , Z, means the Safe Distance between X and Y is Z, and Y should run after X. The instructions are numbered from 0 to N - 1.<br><strong>Output</strong><br>Print one integer, the minimum time the CPU needs to run.</p><p><strong>Sample Input</strong></p><blockquote><p>5 2<br>1 2 1<br>3 4 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Hint</strong><br>In the 1st ns, instruction 0, 1 and 3 are executed;<br>In the 2nd ns, instruction 2 and 4 are executed.<br>So the answer should be 2.</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1001;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to(t),length(l){}};vector&lt;Edge&gt; graph[MAXN];//邻接表int earliest[MAXN];//最早开始时间int latest[MAXN];//最晚开始时间int inDegree[MAXN];void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            inDegree[to]++;        }        CriticalPath(n);        int answer=0;        for(int i=0;i&lt;n;i++){            answer=max(answer,earliest[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jungle roads</title>
    <link href="/2020/02/10/Jungle%20roads/"/>
    <url>/2020/02/10/Jungle%20roads/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br><img src="https://img-blog.csdnimg.cn/20200210210056936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.<br><strong>Input</strong><br>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.<br><strong>Output</strong><br>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. </p><p><strong>Sample Input</strong></p><blockquote><p>9<br>A 2 B 12 I 25<br>B 3 C 10 H 40 I 8<br>C 2 D 18 G 55<br>D 1 E 44<br>E 2 F 60 G 38<br>F 0<br>G 1 H 35<br>H 1 I 35<br>3 A 2 B 10 C 40<br>B 1 C 20<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>216<br>30</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;struct Edge{    int from;    int to;    int length;    bool operator&lt;(const Edge&amp; e) const{//жиди&lt;a        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(father[x]!=x) return Find(father[x]);    else return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;        else{            father[y]=x; height[x]++;        }    }}int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        int k=0;        for(int i=0;i&lt;n-1;i++){            char v; int num;            cin&gt;&gt;v&gt;&gt;num;            for(int j=0;j&lt;num;j++){                char v1; int length;                cin&gt;&gt;v1&gt;&gt;length;                edge[k].from=i;                edge[k].to=v1-&#39;A&#39;;                edge[k].length=length;                k++;            }        }        int answer=Kruskal(n,k);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最小生成树</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>畅通工程续</title>
    <link href="/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/"/>
    <url>/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p><p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p><p><strong>Input</strong><br>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p><p><strong>Output</strong><br>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.<br><strong>Sample Input</strong></p><blockquote><p>3 3<br>0 1 1<br>0 2 3<br>1 2 1<br>0 2<br>3 1<br>0 1 1<br>1 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;climits&gt;using namespace std;const int MAXN=200;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to{t},length(l){}};struct Point{    int number;    int distance;    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; p) const{        return distance&gt;p.distance;    }};vector&lt;Edge&gt; graph[MAXN];   //邻接表实现的图，数组中是点，而每一个点后面都跟了一个vectorint dis[MAXN];void Dijkstra(int s){    priority_queue&lt;Point&gt; pqueue;    dis[s]=0;    pqueue.push(Point(s,dis[s]));    while(!pqueue.empty()){        int u=pqueue.top().number;//离源点最近的点        pqueue.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;//u为顶点的编号，i为边的序号            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){                dis[v]=dis[u]+d;                pqueue.push(Point(v,dis[v]));            }        }    }    return ;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));//图初始化        fill(dis,dis+n,INF);//距离初始化为无穷        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            graph[to].push_back(Edge(from,length));        }        int s,t;        cin&gt;&gt;s&gt;&gt;t;        Dijkstra(s);        if(dis[t]==INF) dis[t]=-1;        cout&lt;&lt;dis[t]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>确定比赛名次</title>
    <link href="/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/"/>
    <url>/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p><p><strong>Input</strong><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p><p><strong>Output</strong><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><p><strong>Sample Input</strong></p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 2 4 3</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];//邻接表的实现int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        if(n==0&amp;&amp;m==0) break;        memset(graph,0,sizeof(graph));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;//在输入时更新入度数组        }        vector&lt;int&gt; answer=TopologicalSort(n);        for(int i=0;i&lt;answer.size();i++){            if(i==0) cout&lt;&lt;answer[i];            else cout&lt;&lt;&quot; &quot;&lt;&lt;answer[i];        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量修改XML中的标签值</title>
    <link href="/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/"/>
    <url>/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>因为用labelimg给图片打标签的时候打错了，本来是water dispenser弄成了drinking_fountain了，尴尬_(:з)∠)_，并且已经标了1500张了，只能自己写程序改，xml文件示例如下：</p><pre><code class="cpp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;us-ascii&#39;?&gt;&lt;annotation verified=&quot;no&quot;&gt;  &lt;folder&gt;drinking_fountain&lt;/folder&gt;  &lt;filename&gt;1&lt;/filename&gt;  &lt;path&gt;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain\1.jpg&lt;/path&gt;  &lt;source&gt;    &lt;database&gt;Unknown&lt;/database&gt;  &lt;/source&gt;  &lt;size&gt;    &lt;width&gt;720&lt;/width&gt;    &lt;height&gt;1280&lt;/height&gt;    &lt;depth&gt;3&lt;/depth&gt;  &lt;/size&gt;  &lt;segmented&gt;0&lt;/segmented&gt;  &lt;object&gt;    &lt;name&gt;drinking_fountain&lt;/name&gt;    &lt;pose&gt;Unspecified&lt;/pose&gt;    &lt;truncated&gt;0&lt;/truncated&gt;    &lt;difficult&gt;0&lt;/difficult&gt;    &lt;bndbox&gt;      &lt;xmin&gt;153&lt;/xmin&gt;      &lt;ymin&gt;6&lt;/ymin&gt;      &lt;xmax&gt;587&lt;/xmax&gt;      &lt;ymax&gt;1157&lt;/ymax&gt;    &lt;/bndbox&gt;  &lt;/object&gt;&lt;/annotation&gt;</code></pre><p>用来修改的python代码的如下：</p><pre><code class="cpp">import osimport os.pathfrom xml.etree.ElementTree import parse, Element#批量修改xml中内容def test():    path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;#xml文件所在的目录    files = os.listdir(path)  # 得到文件夹下所有文件名称    s = []    for xmlFile in files:  # 遍历文件夹        if not os.path.isdir(xmlFile):  # 判断是否是文件夹,不是文件夹才打开            print            xmlFile            pass        path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;        print(xmlFile)        path1 = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;+xmlFile#定位当前处理的文件的路径        newStr = os.path.join(path, xmlFile)        name = &quot;water dispenser&quot;        dom = parse(newStr)  ###最核心的部分,路径拼接,输入的是具体路径        root = dom.getroot()        print(root)        for obj in root.iter(&#39;object&#39;):#获取object节点中的name子节点            obj.find(&#39;name&#39;).text=name            name1 = obj.find(&#39;name&#39;).text#修改            print(name1)        dom.write(path1, xml_declaration=True)#保存到指定文件        passif __name__ == &#39;__main__&#39;:    test()</code></pre>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约瑟夫问题no_2</title>
    <link href="/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/"/>
    <url>/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h4><p>n 个小孩围坐成一圈，并按顺时针编号为1,2,…,n，从编号为 p 的小孩顺时针依次报数，由1报到m ，当报到 m 时，该小孩从圈中出去，然后下一个再从1报数，当报到 m 时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a><strong>Input:</strong></h4><p>每行是用空格分开的三个整数，第一个是n,第二个是p,第三个是m (0 &lt; m,n &lt; 300)。最后一行是: 0 0 0</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>按出圈的顺序输出编号，编号之间以逗号间隔。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><blockquote><p>8 3 4<br>0 0 0</p></blockquote><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h4><blockquote><p>6,2,7,4,3,5,1,8</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;//用循环队列的方式解决约瑟夫问题int main(){    int n,p,m;    while(cin&gt;&gt;n&gt;&gt;p&gt;&gt;m){        queue&lt;int&gt; children;        for(int i=1;i&lt;=n;i++){            children.push(i);        }        //使编号为p的小孩放在队首        for(int i=1;i&lt;p;i++){            //这两句实现了循环队列，将要pop出去的再次放入队尾            children.push(children.front());            children.pop();        }        //m-1个小孩重新入队        while(!children.empty()){            for(int i=1;i&lt;m;i++){                children.push(children.front());                children.pop();            }            //将第m个小孩出队            if(children.size()==1) cout&lt;&lt;children.front()&lt;&lt;endl;            else cout&lt;&lt;children.front();            children.pop();        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>判断两序列是否为同一二叉搜索树序列</p><p><strong>输入描述:</strong><br>开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。<br><strong>输出描述:</strong><br>如果序列相同则输出YES，否则输出NO<br><strong>示例</strong></p><p>输入</p><blockquote><p>2<br>567432<br>543267<br>576342`<br>0 </p></blockquote><p>输出</p><blockquote><p>YES<br>NO</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;//前序遍历和中序遍历可以唯一确定一棵二叉树，//而对二叉排序树而言，相同元素的二叉排序树中//序遍历一定相同，而不同元素二叉排序树使用前//序遍历就可以发现不相同，所以只需要前序遍历//两个二叉树，比较一下就可以判断using namespace std;string pre,in;struct TreeNode{    char data;    TreeNode* leftchild;    TreeNode* rightchild;    TreeNode(char c):data(c),leftchild(NULL),rightchild(NULL){}};TreeNode* Insert(TreeNode* root,char x){    if(root==NULL){        root=new TreeNode(x);    }    else if(x&lt;root-&gt;data){        root-&gt;leftchild=Insert(root-&gt;leftchild,x);    }    else if(x&gt;root-&gt;data){        root-&gt;rightchild=Insert(root-&gt;rightchild,x);    }    return root;}string preorder(TreeNode* root){    if(root==NULL) return &quot;#&quot;;    return root-&gt;data+preorder(root-&gt;leftchild)+preorder(root-&gt;rightchild);}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        string s; TreeNode* root=NULL;        cin&gt;&gt;s;        //构建初始的排序树        for(int i=0;i&lt;s.size();i++){            root=Insert(root,s[i]);        }        string pre=preorder(root);        //构建用来比较的排序树        for(int i=0;i&lt;n;i++){            string str; TreeNode* T=NULL;            cin&gt;&gt;str;            for(int j=0;j&lt;str.size();j++){                T=Insert(T,str[j]);            }            string pre1=preorder(T);        //进行比较            if(pre1==pre) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>二叉排序树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫爬取全国历史天气数据</title>
    <link href="/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>一段很简单的爬虫程序，爬取的网站为<a href="http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据" target="_blank" rel="noopener">http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据</a></p><pre><code class="cpp">from bs4 import BeautifulSoupimport requestsimport pymysqlimport warnings# import pinyin# from pinyin import PinYinfrom pypinyin import pinyin, lazy_pinyinimport pypinyinwarnings.filterwarnings(&quot;ignore&quot;)conn = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, passwd=&#39;root&#39;, db=&#39;test2&#39;, port=3306, charset=&#39;utf8&#39;)cursor = conn.cursor()def get_temperature(url,city):    headers = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,  like Gecko) Chrome/63.0.3239.132 Safari/537.36&#39;}           # 设置头文件信息    response = requests.get(url,  headers=headers).content    # 提交requests get 请求    soup = BeautifulSoup(response,  &quot;lxml&quot;)       # 用Beautifulsoup 进行解析    conmid2 = soup.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    # conmid2 = conmid.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    for info in conmid2:        tr_list = info.find_all(&#39;tr&#39;)[1:]       # 使用切片取到第三个tr标签        for index,  tr in enumerate(tr_list):     # enumerate可以返回元素的位置及内容            td_list = tr.find_all(&#39;td&#39;)            # if index == 0:            date = td_list[0].text.strip().replace(&quot;\n&quot;, &quot;&quot;)  # 取每个标签的text信息，并使用replace()函数将换行符删除            weather = td_list[1].text.strip().replace(&quot;\n&quot;, &quot;&quot;).split(&quot;/&quot;)[0].strip()            temperature = td_list[2].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            wind = td_list[3].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            # else:            #     city_name = td_list[0].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     weather = td_list[4].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     wind = td_list[5].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     max = td_list[3].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     min = td_list[6].text.replace(&#39;\n&#39;,  &#39;&#39;)            print(city,date,  weather,  wind,  temperature)            cursor.execute(&#39;insert into weather(city, date, weather, wind, temp) values(%s, %s, %s, %s, %s)&#39;                           ,  (city,  date,  weather,  wind,  temperature ))if __name__==&#39;__main__&#39;:    # citys1= [&quot;成都市&quot;,&quot;广元市&quot;,&quot;绵阳市&quot;,&quot;德阳市&quot;,&quot;南充市&quot;,&quot;广安市&quot;,&quot;遂宁市&quot;,&quot;内江市&quot;,&quot;乐山市&quot;,&quot;自贡市&quot;,&quot;泸州市&quot;,&quot;宜宾市&quot;,&quot;攀枝花市&quot;,&quot;巴中市&quot;,&quot;达州市&quot;,&quot;资阳市&quot;,&quot;眉山市&quot;,&quot;雅安市&quot;,&quot;崇州市&quot;,&quot;邛崃市&quot;,&quot;都江堰市&quot;,&quot;彭州市&quot;,&quot;江油市&quot;,&quot;什邡市&quot;,&quot;广汉市&quot;,&quot;绵竹市&quot;,&quot;阆中市&quot;,&quot;华蓥市&quot;,&quot;峨眉山市&quot;,&quot;万源市&quot;,&quot;简阳市&quot;,&quot;西昌市&quot;,&quot;康定市&quot;,&quot;马尔康市&quot;,&quot;隆昌市&quot;]    # citys1= [&quot;郑州市&quot;,&quot;开封市&quot;,&quot;洛阳市&quot;,&quot;平顶山市&quot;,&quot;安阳市&quot;,&quot;鹤壁市&quot;,&quot;新乡市&quot;,&quot;焦作市&quot;,&quot;濮阳市&quot;,&quot;许昌市&quot;,&quot;漯河市&quot;,&quot;三门峡市&quot;,&quot;南阳市&quot;,&quot;商丘市&quot;,&quot;周口市&quot;,&quot;驻马店市&quot;,&quot;信阳市&quot;,&quot;荥阳市&quot;,&quot;新郑市&quot;,&quot;登封市&quot;,&quot;新密市&quot;,&quot;偃师市&quot;,&quot;孟州市&quot;,&quot;沁阳市&quot;,&quot;卫辉市&quot;,&quot;辉县市&quot;,&quot;林州市&quot;,&quot;禹州市&quot;,&quot;长葛市&quot;,&quot;舞钢市&quot;,&quot;义马市&quot;,&quot;灵宝市&quot;,&quot;项城市&quot;,&quot;巩义市&quot;,&quot;邓州市&quot;,&quot;永城市&quot;,&quot;汝州市&quot;,&quot;济源市&quot;]    # citys1= [&quot;呼和浩特市&quot;,&quot;包头市&quot;,&quot;乌海市&quot;,&quot;赤峰市&quot;,&quot;通辽市&quot;,&quot;鄂尔多斯市&quot;,&quot;呼伦贝尔市&quot;,&quot;巴彦淖尔市&quot;,&quot;乌兰察布市&quot;,&quot;霍林郭勒市&quot;,&quot;满洲里市&quot;,&quot;牙克石市&quot;,&quot;扎兰屯市&quot;,&quot;额尔古纳市&quot;,&quot;根河市&quot;,&quot;丰镇市&quot;,&quot;乌兰浩特市&quot;,&quot;阿尔山市&quot;,&quot;二连浩特市&quot;,&quot;锡林浩特市&quot;]    # citys1= [&quot;沈阳市&quot;,&quot;大连市&quot;,&quot;鞍山市&quot;,&quot;抚顺市&quot;,&quot;本溪市&quot;,&quot;丹东市&quot;,&quot;锦州市&quot;,&quot;营口市&quot;,&quot;阜新市&quot;,&quot;辽阳市&quot;,&quot;盘锦市&quot;,&quot;铁岭市&quot;,&quot;朝阳市&quot;,&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    # citys1= [&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    citys1= [&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    for city in citys1:        city1 = &#39;&#39;.join(lazy_pinyin(city[:-1]))        print(city1)        urls = [&#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201801.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201802.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201803.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201804.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201805.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201806.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201807.html&#39;]        for url in urls:            get_temperature(url, city)        conn.commit()</code></pre>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
