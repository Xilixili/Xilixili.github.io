<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数论算法</title>
    <link href="/2020/05/05/%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/05/%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p><img src="https://img-blog.csdnimg.cn/20200505184857978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p><img src="https://img-blog.csdnimg.cn/20200505185724851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="分数四则运算"><a href="#分数四则运算" class="headerlink" title="分数四则运算"></a>分数四则运算</h2><p><strong>1.分数的表示</strong><br><img src="https://img-blog.csdnimg.cn/20200505192558963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>2.分数的化简</strong><br><img src="https://img-blog.csdnimg.cn/2020050519272114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>3.分数的加法</strong><br><img src="https://img-blog.csdnimg.cn/20200505192749541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>4.分数的减法</strong><br><img src="https://img-blog.csdnimg.cn/20200505192900279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>5.分数的乘法</strong><br><img src="https://img-blog.csdnimg.cn/20200505192947930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>6.分数的除法</strong><br><img src="https://img-blog.csdnimg.cn/20200505193102689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><strong>分数的输出</strong><br><img src="https://img-blog.csdnimg.cn/20200505193601749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h2><p><img src="https://img-blog.csdnimg.cn/20200505194004488.png" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200505194035979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;//质因子分解struct factor{    int x;//素数    int cnt;//素数出现的次数}fac[10];vector&lt;int&gt; prime;bool isprime[10010];void init_prime(){    fill(isprime,isprime+10010,true);    isprime[0]=false;    isprime[1]=false;    for(int i=2;i&lt;10010;i++){        if(!isprime[i]) continue;        else{            prime.push_back(i);            for(int j=i*i;j&lt;10010;j+=i){                isprime[j]=false;            }        }    }}int main(){    int n;    cin&gt;&gt;n;    int index=0;    init_prime();    for(int i=0;prime[i]&lt;sqrt(n);i++){        if(n%prime[i]==0){            fac[index].x=prime[i];            fac[index].cnt=1;            n/=prime[i];            //如果还是能除得尽当前的素数就继续除            while(n!=0&amp;&amp;n%prime[i]==0){                fac[index].cnt++;                n/=prime[i];            }            index++;        }    }    //最后可能存在的一个超过sqrt(n)的素数    if(n!=0){        fac[index].x=n;        fac[index].cnt=1;        index++;    }    for(int i=0;i&lt;index;i++){        for(int j=fac[i].cnt;j&gt;0;j--){            cout&lt;&lt;fac[i].x&lt;&lt;&#39;*&#39;;        }    }}</code></pre><h2 id="n-质因p的个数"><a href="#n-质因p的个数" class="headerlink" title="n!质因p的个数"></a>n!质因p的个数</h2><p><img src="https://img-blog.csdnimg.cn/20200505202052232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200505202306240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>相当于组合数公式的变形，对于$C^{m}_{n}$来说<br>相当于 <strong>后m个的乘积/前m个的乘积</strong><br>但注意乘和除一定同步进行，不然可能在中途溢出<br><img src="https://img-blog.csdnimg.cn/20200505203215768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="高精度运算"><a href="#高精度运算" class="headerlink" title="高精度运算"></a>高精度运算</h2><p><a href="https://xilixili.github.io/2020/04/16/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/" target="_blank" rel="noopener">任意门</a></p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><a href="https://xilixili.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%9C%80%E7%BB%88%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">任意门</a></p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用字符串分割方法</title>
    <link href="/2020/05/05/C++%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"/>
    <url>/2020/05/05/C++%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、用strtok函数进行字符串分割"><a href="#一、用strtok函数进行字符串分割" class="headerlink" title="一、用strtok函数进行字符串分割"></a>一、用strtok函数进行字符串分割</h2><p>原型： char *strtok(char *str, const char *delim);</p><p>功能：分解字符串为一组字符串。</p><p>参数说明：str为要分解的字符串，delim为分隔符字符串。</p><p>返回值：从str开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。</p><p>其它：strtok函数线程不安全，可以使用strtok_r替代。</p><p>示例：</p><pre><code class="cpp">//借助strtok实现split#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(){    char s[] = &quot;Golden Global   View,disk * desk&quot;;    const char *d = &quot; ,*&quot;;    char *p;    p = strtok(s,d);    while(p)    {        printf(&quot;%s\n&quot;,p);        p=strtok(NULL,d);    }    return 0;}</code></pre><p>运行效果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200505163131183.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="二、用STL进行字符串的分割"><a href="#二、用STL进行字符串的分割" class="headerlink" title="二、用STL进行字符串的分割"></a>二、用STL进行字符串的分割</h2><p>涉及到string类的两个函数find和substr：<br>1、find函数<br>原型：size_t find ( const string&amp; str, size_t pos = 0 ) const;<br>功能：查找子字符串第一次出现的位置。<br>参数说明：str为子字符串，pos为初始查找位置。<br>返回值：找到的话返回第一次出现的位置，否则返回string::npos</p><p>2、substr函数<br>原型：string substr ( size_t pos = 0, size_t n = npos ) const;<br>功能：获得子字符串。<br>参数说明：pos为起始位置（默认为0），n为结束位置（默认为npos）<br>返回值：子字符串</p><p>实现如下：</p><pre><code class="cpp">//字符串分割函数std::vector&lt;std::string&gt; split(std::string str,std::string pattern){  std::string::size_type pos;  std::vector&lt;std::string&gt; result;  str+=pattern;//扩展字符串以方便操作  int size=str.size();  for(int i=0; i&lt;size; i++)  {    pos=str.find(pattern,i);    if(pos&lt;size)    {      std::string s=str.substr(i,pos-i);      result.push_back(s);      i=pos+pattern.size()-1;    }  }  return result;}</code></pre><p>完整代码：</p><pre><code class="cpp">/*    File   : split1.cpp    Author  : Mike    E-Mail  : Mike_Zhang@live.com */#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;//字符串分割函数std::vector&lt;std::string&gt; split(std::string str,std::string pattern){  std::string::size_type pos;  std::vector&lt;std::string&gt; result;  str+=pattern;//扩展字符串以方便操作  int size=str.size();  for(int i=0; i&lt;size; i++)  {    pos=str.find(pattern,i);    if(pos&lt;size)    {      std::string s=str.substr(i,pos-i);      result.push_back(s);      i=pos+pattern.size()-1;    }  }  return result;}int main(){  std::string str;  std::cout&lt;&lt;&quot;Please input str:&quot;&lt;&lt;std::endl;  //std::cin&gt;&gt;str;  getline(std::cin,str);  std::string pattern;  std::cout&lt;&lt;&quot;Please input pattern:&quot;&lt;&lt;std::endl;  //std::cin&gt;&gt;pattern;  getline(std::cin,pattern);//用于获取含空格的字符串  std::vector&lt;std::string&gt; result=split(str,pattern);  std::cout&lt;&lt;&quot;The result:&quot;&lt;&lt;std::endl;  for(int i=0; i&lt;result.size(); i++)  {    std::cout&lt;&lt;result[i]&lt;&lt;std::endl;  }  std::cin.get();  std::cin.get();  return 0;}运行效果如下图所示：</code></pre><h2 id="三、用Boost进行字符串的分割"><a href="#三、用Boost进行字符串的分割" class="headerlink" title="三、用Boost进行字符串的分割"></a>三、用Boost进行字符串的分割</h2><p>用boost库的正则表达式实现字符串分割<br>实现如下：</p><pre><code class="cpp">std::vector&lt;std::string&gt; split(std::string str,std::string s){    boost::regex reg(s.c_str());    std::vector&lt;std::string&gt; vec;    boost::sregex_token_iterator it(str.begin(),str.end(),reg,-1);    boost::sregex_token_iterator end;    while(it!=end)    {        vec.push_back(*it++);    }    return vec;</code></pre><p>}<br>完整代码：</p><pre><code class="cpp">//本程序实现的是利用正则表达式对字符串实现分割//运行环境   VC6.0 + boost 库/*    File   : split2.cpp    Author  : Mike    E-Mail  : Mike_Zhang@live.com*/#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &quot;boost/regex.hpp&quot;std::vector&lt;std::string&gt; split(std::string str,std::string s){    boost::regex reg(s.c_str());    std::vector&lt;std::string&gt; vec;    boost::sregex_token_iterator it(str.begin(),str.end(),reg,-1);    boost::sregex_token_iterator end;    while(it!=end)    {        vec.push_back(*it++);    }    return vec;}int main(){    std::string str,s;    str=&quot;sss/ddd/ggg/hh&quot;;    s=&quot;/&quot;;    std::vector&lt;std::string&gt; vec=split(str,s);    for(int i=0,size=vec.size();i&lt;size;i++)    {        std::cout&lt;&lt;vec[i]&lt;&lt;std::endl;    }    std::cin.get();    std::cin.get();    return 0;}</code></pre><p>运行效果如下图所示：</p><p>补充：</p><p>最近发现boost里面有自带的split的函数，如果用boost的话，还是直接用split的好，这里就不多说了，代码如下：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;boost/algorithm/string/classification.hpp&gt;#include &lt;boost/algorithm/string/split.hpp&gt;using namespace std;int main(){ string s = &quot;sss/ddd,ggg&quot;; vector&lt;string&gt; vStr; boost::split( vStr, s, boost::is_any_of( &quot;,/&quot; ), boost::token_compress_on ); for( vector&lt;string&gt;::iterator it = vStr.begin(); it != vStr.end(); ++ it )  cout &lt;&lt; *it &lt;&lt; endl; return 0;}#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;boost/algorithm/string/classification.hpp&gt;#include &lt;boost/algorithm/string/split.hpp&gt;using namespace std;int main(){ string s = &quot;sss/ddd,ggg&quot;; vector&lt;string&gt; vStr; boost::split( vStr, s, boost::is_any_of( &quot;,/&quot; ), boost::token_compress_on ); for( vector&lt;string&gt;::iterator it = vStr.begin(); it != vStr.end(); ++ it )  cout &lt;&lt; *it &lt;&lt; endl; return 0;}</code></pre><p>希望本文所述对大家的C++程序设计有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>printf输出不够时前面补0</title>
    <link href="/2020/05/05/printf%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B0%E5%AD%97%EF%BC%8C%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%A4%9F%E5%89%8D%E9%9D%A2%E8%A1%A50/"/>
    <url>/2020/05/05/printf%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B0%E5%AD%97%EF%BC%8C%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%A4%9F%E5%89%8D%E9%9D%A2%E8%A1%A50/</url>
    
    <content type="html"><![CDATA[<p>printf格式输出：%[flags][width][.perc][F|N|h|l]type<br>用到了flags中的0,其百科描述为：将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用-）</p><p>width 即表示需要输出的位数。</p><pre><code class="cpp">int a = 4;printf(&quot;%03d&quot;,a);</code></pre><blockquote><p>输出：004</p></blockquote><p>也可以用 * 代替位数，在后面的参数列表中用变量控制输出位数；</p><pre><code class="cpp">int a = 4;int n = 3;printf(&quot;%0*d&quot;,n,a);</code></pre><blockquote><p>输出：004</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector的总结</title>
    <link href="/2020/05/05/vector%E7%9A%84%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/05/vector%E7%9A%84%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="vector总结"><a href="#vector总结" class="headerlink" title="vector总结"></a>vector总结</h1><p>vector是不定长数组，具有静态数组的稳定性和动态分配内存的灵活性，在赛场上不失为指针之外牺牲部分时间的保险之举。</p><p>本文先介绍一些vector常用的函数（部分借鉴一篇博客中的内容 链接），并以此为铺垫，介绍本人在解题过程中对vector用途的一些总结。</p><p>vector中迭代器的声明：vector<int>::iterator it;</p><p>迭代器的使用方法与指针几乎完全一样，vector中绝大多数带参数的函数参数都有迭代器，很多函数的返回值也是迭代器。</p><h1 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h1><p><strong>1.begin,end：</strong><br>a.begin()返回指向a中第一个元素的迭代器，a.end()返回指向a中最后一个元素的位置的下一个位置的迭代器。begin和end可以用来遍历，当然for(int i=0;i&lt;a.size();i++)也可以实现，效率完全相同，但在运行一些输入参数为迭代器的函数时，vector的下标就无法解决了。</p><p><strong>2.size,capacity：</strong><br>a.size()返回a中非空元素个数，a.capacity()返回a所占内存可容纳元素的个数。</p><p><strong>3.clear,resize：</strong><br>a.clear()是void类型，表示将a中所有元素置空，但不改变a所占内存，即size变为0，capacity不变。</p><p>a.resize(x)也是void类型，表示将a的size变为x，capacity变为max(capacity,x)。（好奇怪的操作……）</p><p><strong>4.push_back：</strong><br> a.pushback(x)是void类型，表示将x插入到a的尾部，size+1。</p><p>值得注意的是，a的capacity并不是push_back一次就+1，而是当capacity不够用的时候增大为原来的两倍。即capacity的值只可能是0或2的幂次。在某些极限情况下vector所占内存可以达到预计内存的近似两倍，在做题时要额外注意MLE的风险。</p><p><strong>5.insert：</strong><br>insert共有三种用法：</p><ul><li><p>a.insert(it,val)：函数表示在迭代器it指向位置之前插入值为val的元素，返回指向插入元素的迭代器。</p></li><li><p>a.insert(it,num,val)：该函数是void类型，表示在迭代器it指向位置之前插入num个值为val的元素。</p></li><li><p>a.insert(it,l,r)：该函数是void类型，表示在迭代器it指向位置之前插入从迭代器l指向位置到迭代器r指向位置的前一个位置的元素（即插入某个容器中[l,r)的元素）。<br>(可以实现两段vector的合并：<br>vector  vec_1.insert(vec_1.end(),  vec_2.begin(),  vec_2.end()) )</p></li></ul><p><strong>6.erase：</strong><br>erase共有两种用法，与insert的第一种和第三种类似。</p><ul><li>a.erase(it)：函数表示删除迭代器it指向的元素，返回指向被删元素的前一个元素的迭代器。</li><li>a.erase(l,r)：函数表示删除从迭代器l指向位置到迭代器r指向位置的前一个位置的元素（即删除a中[l,r)的元素）。</li></ul><p>insert的操作3和erase的操作2结合起来使用，可以实现区间的插入，删除，交换。</p><p><strong>7.lower_bound,upper_bound：</strong></p><ul><li><p>lower_bound(l,r,x)中l,r为迭代器，函数返回指向容器[l,r)中第一个大于等于x的元素的迭代器。</p></li><li><p>upper_bound(l,r,x)中l,r为迭代器，函数返回指向容器[l,r)中第一个大于x的元素的迭代器。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划总结</title>
    <link href="/2020/05/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="简单dp"><a href="#简单dp" class="headerlink" title="简单dp"></a>简单dp</h1><h2 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h2><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h3><p><img src="https://img-blog.csdnimg.cn/20200429165006825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {        int m=triangle.size();        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt; (m,INT_MAX));        int ans=INT_MAX;        for(int i=0;i&lt;m;i++){            for(int j=0;j&lt;=i;j++){                if(i==0&amp;&amp;j==0){                    dp[i][j]=triangle[i][j];                    continue;                }                //上和左上的值，即上一步的位置                int up=INT_MAX,left_up=INT_MAX;                if(i&gt;=j){//此时上方存在元素                    up=dp[i-1][j];                }                if(j-1&gt;=0){////此时左上方存在元素                    left_up=dp[i-1][j-1];                }                dp[i][j]=min(up,left_up)+triangle[i][j];                //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;            }        }        //遍历最后一行，找到总路径和最小的出口        for(int j=0;j&lt;triangle[m-1].size();j++){            if(dp[m-1][j]&lt;ans) ans=dp[m-1][j];        }        return ans;    }};</code></pre><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><p><img src="https://img-blog.csdnimg.cn/20200419151336146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    //up[i] 存的是目前为止最长的以第 i 个元素结尾的上升摆动序列的长度。    //down[i] 记录的是目前为止最长的以第 i 个元素结尾的下降摆动序列的长度。    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {        int n=nums.size();        if(n==0) return 0;        vector&lt;int&gt; up(n,1);        vector&lt;int&gt; down(n,1);        for(int i=0;i&lt;n;i++){            for(int j=0;j&lt;i;j++){                if(nums[i]&gt;nums[j]){                    up[i]=max(up[i],down[j]+1);                }                else if(nums[i]&lt;nums[j]){                    down[i]=max(down[i],up[j]+1);                }                //cout&lt;&lt;nums[i]&lt;&lt;endl;                //cout&lt;&lt;up[i]&lt;&lt;&quot; &quot;&lt;&lt;down[i]&lt;&lt;endl;            }        }        return max(up[n-1],down[n-1]);    }};</code></pre><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2><h1 id="树型dp"><a href="#树型dp" class="headerlink" title="树型dp"></a>树型dp</h1><h2 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a>打家劫舍 III</h2><p><img src="https://img-blog.csdnimg.cn/20200417171403325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int rob(TreeNode* root) {        auto ans=dfs(root);        return max(ans.first,ans.second);    }    //返回的pair-&gt;first:选择当前结点的最大收益;pair-&gt;second:不选当前结点的最大收益    pair&lt;int,int&gt; dfs(TreeNode* root){        if(root==NULL) return {0,0};        auto left_pair=dfs(root-&gt;left);        auto right_pair=dfs(root-&gt;right);        //选root|不选root        return {root-&gt;val+left_pair.second+right_pair.second,                //max(选左边，不选左边)+max(选右边，不选右边)                max(left_pair.first,left_pair.second)+max(right_pair.first,right_pair.second)};    }};</code></pre><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p><img src="https://img-blog.csdnimg.cn/20200417171623377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxh;    //因为有全部是负数的树存在(因为对NULL的处理是返回{0,0})，所以对这个情况单独拿出来    bool all_negetive=true;    int max_negetive=INT_MIN;    int max_path=INT_MIN;    int maxPathSum(TreeNode* root) {        auto ans=dfs(root);        //if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) return root-&gt;val;        if(all_negetive){            return max_negetive;        }        else return max_path;    }    pair&lt;int,int&gt; dfs(TreeNode* root){        if(root==NULL){            return {0,0};        }        if(root-&gt;val&gt;=0) all_negetive=false;        max_negetive=max(max_negetive,root-&gt;val);        auto left_pair=dfs(root-&gt;left);        auto right_pair=dfs(root-&gt;right);        //cout&lt;&lt;root-&gt;val&lt;&lt;endl;        //cout&lt;&lt;left_pair.first&lt;&lt;&quot; &quot;&lt;&lt;left_pair.second&lt;&lt;endl;        //cout&lt;&lt;right_pair.first&lt;&lt;&quot; &quot;&lt;&lt;right_pair.second&lt;&lt;endl;        max_path=max(max_path,                    max(                        max(root-&gt;val+left_pair.first,                            root-&gt;val+right_pair.first),                        max(root-&gt;val,                            root-&gt;val+left_pair.first+right_pair.first)                    )                );        return {//选root,要注意路径里面的结点是连续的,比如如果左边儿子没有选，那么不选左边儿子的最大路径和与当前结点的最大路径和也没关系了//并且子节点不能左右都选，不然就不是路径,所以当要选儿子时，最多只会选择儿子一条边来与自己构成路径        max(max(root-&gt;val+left_pair.first,root-&gt;val),root-&gt;val+right_pair.first),            //不选root        max(max(left_pair.first,left_pair.second),max(right_pair.first,right_pair.second))        };    }};</code></pre><h1 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h1><p><strong>题目描述</strong><br>不要49</p><pre><code class="cpp">//    pos    = 当前处理的位置(一般从高位到低位)//    pre    = 上一个位的数字(更高的那一位)//    status = 要达到的状态,如果为1则可以认为找到了答案,到时候用来返回,//         　　 给计数器+1。//    limit  = 是否受限,也即当前处理这位能否随便取值。如567,当前处理6这位,//         　　 如果前面取的是4,则当前这位可以取0-9。如果前面取的5,那么当前//         　　 这位就不能随便取，不然会超出这个数的范围,所以如果前面取5的//         　　 话此时的limit=1,也就是说当前只可以取0-6。////    用DP数组保存这三个状态是因为往后转移的时候会遇到很多重复的情况。int    dfs(int pos,int pre,int status,int limit){    //已结搜到尽头,返回&quot;是否找到了答案&quot;这个状态。    if(pos &lt; 1)        return    status;    //DP里保存的是完整的,也即不受限的答案,所以如果满足的话,可以直接返回。    if(!limit &amp;&amp; DP[pos][pre][status] != -1)        return    DP[pos][pre][status];    int    end = limit ? DIG[pos] : 9;    int    ret = 0;    //往下搜的状态表示的很巧妙,status用||是因为如果前面找到了答案那么后面    //还有没有答案都无所谓了。而limti用&amp;&amp;是因为只有前面受限、当前受限才能    //推出下一步也受限，比如567,如果是46X的情况,虽然6已经到尽头,但是后面的    //个位仍然可以随便取,因为百位没受限,所以如果个位要受限,那么前面必须是56。    //    //这里用&quot;不要49&quot;一题来做例子。    for(int i = 0;i &lt;= end;i ++)        ret += dfs(pos - 1,i,status || (pre == 4 &amp;&amp; i == 9),limit &amp;&amp; (i == end));    //DP里保存完整的、取到尽头的数据    if(!limit)        DP[pos][pre][status] = ret;    return    ret;}</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><p><strong>题目描述</strong><br>给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”… 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><pre><code class="cpp">public class Solution {    public int numDecodings(String s) {        if(s == null || s.length() == 0) {            return 0;        }        int n = s.length();        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = s.charAt(0) != &#39;0&#39; ? 1 : 0;        for(int i = 2; i &lt;= n; i++) {            int first = Integer.valueOf(s.substring(i-1, i));            int second = Integer.valueOf(s.substring(i-2, i));            if(first &gt;= 1 &amp;&amp; first &lt;= 9) {               dp[i] += dp[i-1];              }            if(second &gt;= 10 &amp;&amp; second &lt;= 26) {                dp[i] += dp[i-2];            }        }        return dp[n];    }}</code></pre><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><img src="https://img-blog.csdnimg.cn/20200429153120710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int Max=0;    string longestPalindrome(string s) {        int n=s.size();        vector&lt;vector&lt;bool&gt;&gt; dp(n,vector&lt;bool&gt;(n));        //dp[j][i]表示从j到i是否为回文子串        string ans;        if(s.size()==0) return &quot;&quot;;        else if(s.size()==1) return s;        for(int i=0;i&lt;s.size();i++){            for(int j=i;j&gt;=0;j--){                if(s[i]==s[j]&amp;&amp;(i-j&lt;=2||dp[j+1][i-1])){                    dp[j][i]=true;                    if(i-j+1&gt;Max){                        ans=s.substr(j,i-j+1);                        Max=i-j+1;                    }                }            }        }        return ans;    }};</code></pre><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><img src="https://img-blog.csdnimg.cn/20200429161114506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    bool isMatch(string s, string p) {        s=&quot; &quot;+s;//防止该案例：&quot;&quot;\n&quot;c*&quot;        p=&quot; &quot;+p;        int m=s.size(),n=p.size();        bool dp[m+1][n+1];        memset(dp,false,(m+1)*(n+1));        dp[0][0]=true;        for(int i=1;i&lt;=m;i++){            for(int j=1;j&lt;=n;j++){                if(s[i-1]==p[j-1] || p[j-1]==&#39;.&#39;){                    dp[i][j]=dp[i-1][j-1];                }                else if(p[j-1]==&#39;*&#39;){                    if(s[i-1]!=p[j-2] &amp;&amp; p[j-2]!=&#39;.&#39;)                        dp[i][j]=dp[i][j-2];                    else{                        dp[i][j]=dp[i][j-1] || dp[i][j-2] || dp[i-1][j];                    }                }            }        }        return dp[m][n];    }};</code></pre><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p><img src="https://img-blog.csdnimg.cn/20200429161843401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注意：进行括号匹配的时候分三段:<br>1.前一个字符结尾能匹配的最长的串<br>2.能和当前这个字符匹配的 (<br>3.再往前一个能匹配的最长串</p><pre><code class="cpp">class Solution {public:    int longestValidParentheses(string s) {        if(s.size()==0) return 0;        int n=s.size();        int max_len=0;        vector&lt;int&gt;  dp(n);//dp[i]表示以s[i]结尾的最长有效括号长度        dp[0]=0;        for(int i=0;i&lt;s.size();i++){            if(s[i]==&#39;(&#39;) dp[i]=0;            else{                if(i&gt;=1&amp;&amp;s[i-1]==&#39;(&#39;){//      ()的情况                    if(i==1) dp[i]=2;                    else{                        dp[i]=dp[i-2]+2;                    }                }                else if(i&gt;=1&amp;&amp;s[i-1]==&#39;)&#39;){//  ))的情况                    //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;dp[i-1]&lt;&lt;endl;                    if(i-dp[i-1]-1&lt;0||s[i-dp[i-1]-1]!=&#39;(&#39;) dp[i]=0;                    else if(s[i-dp[i-1]-1]==&#39;(&#39;){                        if(i-dp[i-1]-2&lt;0){                            dp[i]=0+dp[i-1]+2;                        }                        else{                            dp[i]=dp[i-dp[i-1]-2]+dp[i-1]+2;                        }                    }                }            }            cout&lt;&lt;dp[i]&lt;&lt;endl;            max_len=max(max_len,dp[i]);        }        return max_len;    }};</code></pre><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p><img src="https://img-blog.csdnimg.cn/20200429164556944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int dp[666][666];    int minDistance(string word1, string word2) {        int m=word1.size();        int n=word2.size();        //cout&lt;&lt;m&lt;&lt;endl;        word1=&quot; &quot;+word1;        word2=&quot; &quot;+word2;        //只进行删除的状态        for(int i=0;i&lt;word1.size();i++){            dp[i][0]=i;        }        //只进行插入的状态        for(int j=0;j&lt;word2.size();j++){            dp[0][j]=j;        }        //自顶向下        for(int i=1;i&lt;=word1.size();i++){            for(int j=1;j&lt;=word2.size();j++){                //相同则不做操作                if(word1[i]==word2[j]){                    dp[i][j]=dp[i-1][j-1];                }                else{                    dp[i][j]=Min(                        dp[i][j-1]+1,//插入                        dp[i-1][j]+1,//删除                        dp[i-1][j-1]+1//替换                    );                }                //cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;            }        }        return dp[m][n];    }    int Min(int x,int y,int z){        return min(x,min(y,z));    }};</code></pre><h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h2><p><img src="https://img-blog.csdnimg.cn/20200429170041313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    struct node{        int rows,cols;        //方便初始化        node():rows(0),cols(0){}    };    int max_Area=0;    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {        int m=matrix.size();        if(m==0) return 0;        int n=matrix[0].size();        vector&lt;vector&lt;node&gt;&gt; dp(m+1,vector&lt;node&gt;(n+1,node()));        if(matrix[0][0]==&#39;1&#39;){            dp[0][0].rows=1;            dp[0][0].cols=1;        }        for(int i=0;i&lt;m;i++){            for(int j=0;j&lt;n;j++){                if(i==0||j==0){                    dp[i][j].rows=matrix[i][j]-&#39;0&#39;;                    dp[i][j].cols=matrix[i][j]-&#39;0&#39;;                                    }                else if(matrix[i][j]==&#39;1&#39;){                    dp[i][j].rows=min(dp[i-1][j-1].rows,dp[i][j-1].rows)+1;                    dp[i][j].cols=min(dp[i-1][j-1].cols,dp[i-1][j].cols)+1;                }                //cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;   &quot;&lt;&lt;dp[i][j].rows&lt;&lt;&quot; &quot;&lt;&lt;dp[i][j].cols&lt;&lt;endl;            }        }        for(int i=0;i&lt;m;i++){            for(int j=0;j&lt;n;j++){                int edge=min(dp[i][j].rows,dp[i][j].cols);                max_Area=max(max_Area,edge*edge);            }        }        return max_Area;    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(16)--概率图模型</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了半监督学习，首先从如何利用未标记样本所蕴含的分布信息出发，引入了半监督学习的基本概念，即训练数据同时包含有标记样本和未标记样本的学习方法；接着分别介绍了几种常见的半监督学习方法：生成式方法基于对数据分布的假设，利用未标记样本隐含的分布信息，使得对模型参数的估计更加准确；TSVM给未标记样本赋予伪标记，并通过不断调整易出错样本的标记得到最终输出；基于分歧的方法结合了集成学习的思想，通过多个学习器在不同视图上的协作，有效利用了未标记样本数据 ；最后半监督聚类则是借助已有的监督信息来辅助聚类的过程，带约束k-均值算法需检测当前样本划分是否满足约束关系，带标记k-均值算法则利用有标记样本指定初始类中心。本篇将讨论一种基于图的学习算法–概率图模型。</p><p>#<strong>15、概率图模型</strong></p><p>现在再来谈谈机器学习的核心价值观，可以更通俗地理解为：<strong>根据一些已观察到的证据来推断未知</strong>，更具哲学性地可以阐述为：未来的发展总是遵循着历史的规律。其中<strong>基于概率的模型将学习任务归结为计算变量的概率分布</strong>，正如之前已经提到的：生成式模型先对联合分布进行建模，从而再来求解后验概率，例如：贝叶斯分类器先对联合分布进行最大似然估计，从而便可以计算类条件概率；判别式模型则是直接对条件分布进行建模。</p><p><strong>概率图模型</strong>（probabilistic graphical model）是一类用<strong>图结构</strong>来表达各属性之间相关关系的概率模型，一般而言：<strong>图中的一个结点表示一个或一组随机变量，结点之间的边则表示变量间的相关关系</strong>，从而形成了一张“<strong>变量关系图</strong>”。若使用有向的边来表达变量之间的依赖关系，这样的有向关系图称为<strong>贝叶斯网</strong>（Bayesian nerwork）或有向图模型；若使用无向边，则称为<strong>马尔可夫网</strong>（Markov network）或无向图模型。</p><p>##<strong>15.1 隐马尔可夫模型(HMM)</strong></p><p>隐马尔可夫模型（Hidden Markov Model，简称HMM）是结构最简单的一种贝叶斯网，在语音识别与自然语言处理领域上有着广泛的应用。HMM中的变量分为两组：<strong>状态变量</strong>与<strong>观测变量</strong>，其中状态变量一般是未知的，因此又称为“<strong>隐变量</strong>”，观测变量则是已知的输出值。在隐马尔可夫模型中，变量之间的依赖关系遵循如下两个规则：</p><blockquote><p><strong>1. 观测变量的取值仅依赖于状态变量</strong>；<br><strong>2. 下一个状态的取值仅依赖于当前状态</strong>，通俗来讲：<strong>现在决定未来，未来与过去无关</strong>，这就是著名的<strong>马尔可夫性</strong>。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwYPmR.png" srcset="/img/loading.gif" alt="iwYPmR.png"></p><p>基于上述变量之间的依赖关系，我们很容易写出隐马尔可夫模型中所有变量的联合概率分布：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwY9X9.png" srcset="/img/loading.gif" alt="iwY9X9.png"></p><p>易知：<strong>欲确定一个HMM模型需要以下三组参数</strong>：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYi01.png" srcset="/img/loading.gif" alt="iwYi01.png"></p><p>当确定了一个HMM模型的三个参数后，便按照下面的规则来生成观测值序列：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYFTx.png" srcset="/img/loading.gif" alt="iwYFTx.png"></p><p>在实际应用中，HMM模型的发力点主要体现在下述三个问题上：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYEtK.png" srcset="/img/loading.gif" alt="iwYEtK.png"></p><p>###<strong>15.1.1 HMM评估问题</strong></p><p>HMM评估问题指的是：<strong>给定了模型的三个参数与观测值序列，求该观测值序列出现的概率</strong>。例如：对于赌场问题，便可以依据骰子掷出的结果序列来计算该结果序列出现的可能性，若小概率的事件发生了则可认为赌场的骰子有作弊的可能。解决该问题使用的是<strong>前向算法</strong>，即步步为营，自底向上的方式逐步增加序列的长度，直到获得目标概率值。在前向算法中，定义了一个<strong>前向变量</strong>，即给定观察值序列且t时刻的状态为Si的概率：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYVfO.png" srcset="/img/loading.gif" alt="iwYVfO.png"></p><p>基于前向变量，很容易得到该问题的递推关系及终止条件：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYAk6.png" srcset="/img/loading.gif" alt="iwYAk6.png"></p><p>因此可使用动态规划法，从最小的子问题开始，通过填表格的形式一步一步计算出目标结果。</p><p>###<strong>15.1.2 HMM解码问题</strong></p><p>HMM解码问题指的是：<strong>给定了模型的三个参数与观测值序列，求可能性最大的状态序列</strong>。例如：在语音识别问题中，人说话形成的数字信号对应着观测值序列，对应的具体文字则是状态序列，从数字信号转化为文字正是对应着根据观测值序列推断最有可能的状态值序列。解决该问题使用的是<strong>Viterbi算法</strong>，与前向算法十分类似地，Viterbi算法定义了一个<strong>Viterbi变量</strong>，也是采用动态规划的方法，自底向上逐步求解。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYepD.png" srcset="/img/loading.gif" alt="iwYepD.png"></p><p>###<strong>15.1.3 HMM学习问题</strong></p><p>HMM学习问题指的是：<strong>给定观测值序列，如何调整模型的参数使得该序列出现的概率最大</strong>。这便转化成了机器学习问题，即从给定的观测值序列中学习出一个HMM模型，<strong>该问题正是EM算法的经典案例之一</strong>。其思想也十分简单：对于给定的观测值序列，如果我们能够按照该序列潜在的规律来调整模型的三个参数，则可以使得该序列出现的可能性最大。假设状态值序列也已知，则很容易计算出与该序列最契合的模型参数：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYm1e.png" srcset="/img/loading.gif" alt="iwYm1e.png"></p><p>但一般状态值序列都是不可观测的，且<strong>即使给定观测值序列与模型参数，状态序列仍然遭遇组合爆炸</strong>。因此上面这种简单的统计方法就行不通了，若将状态值序列看作为隐变量，这时便可以考虑使用EM算法来对该问题进行求解：</p><p>【1】首先对HMM模型的三个参数进行随机初始化；<br>【2】根据模型的参数与观测值序列，计算t时刻状态为i且t+1时刻状态为j的概率以及t时刻状态为i的概率。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYn6H.png" srcset="/img/loading.gif" alt="iwYn6H.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYdns.png" srcset="/img/loading.gif" alt="iwYdns.png"></p><p>【3】接着便可以对模型的三个参数进行重新估计：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYY9S.png" srcset="/img/loading.gif" alt="iwYY9S.png"></p><p>【4】重复步骤2-3，直至三个参数值收敛，便得到了最终的HMM模型。</p><p>##<strong>15.2 马尔可夫随机场（MRF）</strong></p><p>马尔可夫随机场（Markov Random Field）是一种典型的马尔可夫网，即使用无向边来表达变量间的依赖关系。在马尔可夫随机场中，对于关系图中的一个子集，<strong>若任意两结点间都有边连接，则称该子集为一个团；若再加一个结点便不能形成团，则称该子集为极大团</strong>。MRF使用<strong>势函数</strong>来定义多个变量的概率分布函数，其中<strong>每个（极大）团对应一个势函数</strong>，一般团中的变量关系也体现在它所对应的极大团中，因此常常基于极大团来定义变量的联合概率分布函数。具体而言，若所有变量构成的极大团的集合为C，则MRF的联合概率函数可以定义为：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYGh8.png" srcset="/img/loading.gif" alt="iwYGh8.png"></p><p>对于条件独立性，<strong>马尔可夫随机场通过分离集来实现条件独立</strong>，若A结点集必须经过C结点集才能到达B结点集，则称C为分离集。书上给出了一个简单情形下的条件独立证明过程，十分贴切易懂，此处不再展开。基于分离集的概念，得到了MRF的三个性质：</p><blockquote><p><strong>全局马尔可夫性</strong>：给定两个变量子集的分离集，则这两个变量子集条件独立。<br><strong>局部马尔可夫性</strong>：给定某变量的邻接变量，则该变量与其它变量条件独立。<br><strong>成对马尔可夫性</strong>：给定所有其他变量，两个非邻接变量条件独立。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwY07q.png" srcset="/img/loading.gif" alt="iwY07q.png"></p><p>对于MRF中的势函数，势函数主要用于描述团中变量之间的相关关系，且要求为非负函数，直观来看：势函数需要在偏好的变量取值上函数值较大，例如：若x1与x2成正相关，则需要将这种关系反映在势函数的函数值中。一般我们常使用指数函数来定义势函数：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwY8tf.png" srcset="/img/loading.gif" alt="iwY8tf.png"></p><p>##<strong>15.3 条件随机场（CRF）</strong></p><p>前面所讲到的<strong>隐马尔可夫模型和马尔可夫随机场都属于生成式模型，即对联合概率进行建模，条件随机场则是对条件分布进行建模</strong>。CRF试图在给定观测值序列后，对状态序列的概率分布进行建模，即P(y | x)。直观上看：CRF与HMM的解码问题十分类似，都是在给定观测值序列后，研究状态序列可能的取值。CRF可以有多种结构，只需保证状态序列满足马尔可夫性即可，一般我们常使用的是<strong>链式条件随机场</strong>：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYt1g.png" srcset="/img/loading.gif" alt="iwYt1g.png"></p><p>与马尔可夫随机场定义联合概率类似地，CRF也通过团以及势函数的概念来定义条件概率P(y | x)。在给定观测值序列的条件下，链式条件随机场主要包含两种团结构：单个状态团及相邻状态团，通过引入两类特征函数便可以定义出目标条件概率：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYNcQ.png" srcset="/img/loading.gif" alt="iwYNcQ.png"></p><p>以词性标注为例，如何判断给出的一个标注序列靠谱不靠谱呢？<strong>转移特征函数主要判定两个相邻的标注是否合理</strong>，例如：动词+动词显然语法不通；<strong>状态特征函数则判定观测值与对应的标注是否合理</strong>，例如： ly结尾的词–&gt;副词较合理。因此我们可以定义一个特征函数集合，用这个特征函数集合来为一个标注序列打分，并据此选出最靠谱的标注序列。也就是说，每一个特征函数（对应一种规则）都可以用来为一个标注序列评分，把集合中所有特征函数对同一个标注序列的评分综合起来，就是这个标注序列最终的评分值。可以看出：<strong>特征函数是一些经验的特性</strong>。</p><p>##<strong>15.4 学习与推断</strong></p><p>对于生成式模型，通常我们都是先对变量的联合概率分布进行建模，接着再求出目标变量的<strong>边际分布</strong>（marginal distribution），那如何从联合概率得到边际分布呢？这便是学习与推断。下面主要介绍两种精确推断的方法：<strong>变量消去</strong>与<strong>信念传播</strong>。</p><p>###<strong>15.4.1 变量消去</strong></p><p>变量消去利用条件独立性来消减计算目标概率值所需的计算量，它通过运用<strong>乘法与加法的分配率</strong>，将对变量的积的求和问题转化为对部分变量交替进行求积与求和的问题，从而将每次的<strong>运算控制在局部</strong>，达到简化运算的目的。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYUXj.png" srcset="/img/loading.gif" alt="iwYUXj.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYwBn.png" srcset="/img/loading.gif" alt="iwYwBn.png"></p><p>###<strong>15.4.2 信念传播</strong></p><p>若将变量求和操作看作是一种消息的传递过程，信念传播可以理解成：<strong>一个节点在接收到所有其它节点的消息后才向另一个节点发送消息</strong>，同时当前节点的边际概率正比于他所接收的消息的乘积：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYDA0.png" srcset="/img/loading.gif" alt="iwYDA0.png"></p><p>因此只需要经过下面两个步骤，便可以完成所有的消息传递过程。利用动态规划法的思想记录传递过程中的所有消息，当计算某个结点的边际概率分布时，只需直接取出传到该结点的消息即可，从而避免了计算多个边际分布时的冗余计算问题。</p><blockquote><p>1.指定一个根节点，从所有的叶节点开始向根节点传递消息，直到根节点收到所有邻接结点的消息<strong>（从叶到根）</strong>；<br>2.从根节点开始向叶节点传递消息，直到所有叶节点均收到消息<strong>（从根到叶）</strong>。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwYgc4.png" srcset="/img/loading.gif" alt="iwYgc4.png"></p><p>##<strong>15.5 LDA话题模型</strong></p><p>话题模型主要用于处理文本类数据，其中<strong>隐狄利克雷分配模型</strong>（Latent Dirichlet Allocation，简称LDA）是话题模型的杰出代表。在话题模型中，有以下几个基本概念：词（word）、文档（document）、话题（topic）。</p><blockquote><p><strong>词</strong>：最基本的离散单元；<br><strong>文档</strong>：由一组词组成，词在文档中不计顺序；<br><strong>话题</strong>：由一组特定的词组成，这组词具有较强的相关关系。</p></blockquote><p>在现实任务中，一般我们可以得出一个文档的词频分布，但不知道该文档对应着哪些话题，LDA话题模型正是为了解决这个问题。具体来说：<strong>LDA认为每篇文档包含多个话题，且其中每一个词都对应着一个话题</strong>。因此可以假设文档是通过如下方式生成：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwY2jJ.png" srcset="/img/loading.gif" alt="iwY2jJ.png"></p><p>这样一个文档中的所有词都可以认为是通过话题模型来生成的，当已知一个文档的词频分布后（即一个N维向量，N为词库大小），则可以认为：<strong>每一个词频元素都对应着一个话题，而话题对应的词频分布则影响着该词频元素的大小</strong>。因此很容易写出LDA模型对应的联合概率函数：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYc3F.png" srcset="/img/loading.gif" alt="iwYc3F.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYWu9.png" srcset="/img/loading.gif" alt="iwYWu9.png"></p><p>从上图可以看出，LDA的三个表示层被三种颜色表示出来：</p><blockquote><p><strong>corpus-level（红色）：</strong> α和β表示语料级别的参数，也就是每个文档都一样，因此生成过程只采样一次。<br><strong>document-level（橙色）：</strong> θ是文档级别的变量，每个文档对应一个θ。<br><strong>word-level（绿色）：</strong> z和w都是单词级别变量，z由θ生成，w由z和β共同生成，一个单词w对应一个主题z。</p></blockquote><p>通过上面对LDA生成模型的讨论，可以知道<strong>LDA模型主要是想从给定的输入语料中学习训练出两个控制参数α和β</strong>，当学习出了这两个控制参数就确定了模型，便可以用来生成文档。其中α和β分别对应以下各个信息：</p><blockquote><p><strong>α</strong>：分布p(θ)需要一个向量参数，即Dirichlet分布的参数，用于生成一个主题θ向量；<br><strong>β</strong>：各个主题对应的单词概率分布矩阵p(w|z)。</p></blockquote><p>把w当做观察变量，θ和z当做隐藏变量，就可以通过EM算法学习出α和β，求解过程中遇到后验概率p(θ,z|w)无法直接求解，需要找一个似然函数下界来近似求解，原作者使用基于分解（factorization）假设的变分法（varialtional inference）进行计算，用到了EM算法。每次E-step输入α和β，计算似然函数，M-step最大化这个似然函数，算出α和β，不断迭代直到收敛。</p><p>在此，概率图模型就介绍完毕。上周受到协同训练的启发，让实验的小伙伴做了一个HMM的slides，结果扩充了好多知识，所以完成这篇笔记还是花费了不少功夫，还刚好赶上实验室没空调回到解放前的日子，可谓汗流之作…</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(15)--半监督学习</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了机器学习的理论基础，首先从独立同分布引入泛化误差与经验误差，接着介绍了PAC可学习的基本概念，即以较大的概率学习出与目标概念近似的假设（泛化误差满足预设上限），对于有限假设空间：（1）可分情形时，假设空间都是PAC可学习的，即当样本满足一定的数量之后，总是可以在与训练集一致的假设中找出目标概念的近似；（2）不可分情形时，假设空间都是不可知PAC可学习的，即以较大概率学习出与当前假设空间中泛化误差最小的假设的有效近似（Hoeffding不等式）。对于无限假设空间，通过增长函数与VC维来描述其复杂度，若学习算法满足经验风险最小化原则，则任何VC维有限的假设空间都是（不可知）PAC可学习的，同时也给出了泛化误差界与样本复杂度。稳定性则考察的是输入发生变化时输出的波动，稳定性通过损失函数与假设空间的可学习理论联系在了一起。本篇将讨论一种介于监督与非监督学习之间的学习算法–半监督学习。</p><p>#<strong>14、半监督学习</strong></p><p>前面我们一直围绕的都是监督学习与无监督学习，监督学习指的是训练样本包含标记信息的学习任务，例如：常见的分类与回归算法；无监督学习则是训练样本不包含标记信息的学习任务，例如：聚类算法。在实际生活中，常常会出现一部分样本有标记和较多样本无标记的情形，例如：做网页推荐时需要让用户标记出感兴趣的网页，但是少有用户愿意花时间来提供标记。若直接丢弃掉无标记样本集，使用传统的监督学习方法，常常会由于训练样本的不充足，使得其刻画总体分布的能力减弱，从而影响了学习器泛化性能。那如何利用未标记的样本数据呢？</p><p>一种简单的做法是通过专家知识对这些未标记的样本进行打标，但随之而来的就是巨大的人力耗费。若我们先使用有标记的样本数据集训练出一个学习器，再基于该学习器对未标记的样本进行预测，从中<strong>挑选出不确定性高或分类置信度低的样本来咨询专家并进行打标</strong>，最后使用扩充后的训练集重新训练学习器，这样便能大幅度降低标记成本，这便是<strong>主动学习</strong>（active learning），其目标是<strong>使用尽量少的/有价值的咨询来获得更好的性能</strong>。</p><p>显然，<strong>主动学习需要与外界进行交互/查询/打标，其本质上仍然属于一种监督学习</strong>。事实上，无标记样本虽未包含标记信息，但它们与有标记样本一样都是从总体中独立同分布采样得到，因此<strong>它们所包含的数据分布信息对学习器的训练大有裨益</strong>。如何让学习过程不依赖外界的咨询交互，自动利用未标记样本所包含的分布信息的方法便是<strong>半监督学习</strong>（semi-supervised learning），<strong>即训练集同时包含有标记样本数据和未标记样本数据</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc856e39801d.png" srcset="/img/loading.gif" alt="1.png"></p><p>此外，半监督学习还可以进一步划分为<strong>纯半监督学习</strong>和<strong>直推学习</strong>，两者的区别在于：前者假定训练数据集中的未标记数据并非待预测数据，而后者假定学习过程中的未标记数据就是待预测数据。主动学习、纯半监督学习以及直推学习三者的概念如下图所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJFJS.png" srcset="/img/loading.gif" alt="iwJFJS.png"></p><p>##<strong>14.1 生成式方法</strong></p><p><strong>生成式方法</strong>（generative methods）是基于生成式模型的方法，即先对联合分布P（x,c）建模，从而进一步求解 P（c | x），<strong>此类方法假定样本数据服从一个潜在的分布，因此需要充分可靠的先验知识</strong>。例如：前面已经接触到的贝叶斯分类器与高斯混合聚类，都属于生成式模型。现假定总体是一个高斯混合分布，即由多个高斯分布组合形成，从而一个子高斯分布就代表一个类簇（类别）。高斯混合分布的概率密度函数如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc856e3b82dc.png" srcset="/img/loading.gif" alt="3.png"></p><p>不失一般性，假设类簇与真实的类别按照顺序一一对应，即第i个类簇对应第i个高斯混合成分。与高斯混合聚类类似地，这里的主要任务也是估计出各个高斯混合成分的参数以及混合系数，不同的是：对于有标记样本，不再是可能属于每一个类簇，而是只能属于真实类标对应的特定类簇。</p><p><img src="https://i.loli.net/2018/10/18/5bc856e431d30.png" srcset="/img/loading.gif" alt="4.png"></p><p>直观上来看，<strong>基于半监督的高斯混合模型有机地整合了贝叶斯分类器与高斯混合聚类的核心思想</strong>，有效地利用了未标记样本数据隐含的分布信息，从而使得参数的估计更加准确。同样地，这里也要召唤出之前的EM大法进行求解，首先对各个高斯混合成分的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类，有标记样本则直接属于特定类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新。</p><p><img src="https://i.loli.net/2018/10/18/5bc856e43ff08.png" srcset="/img/loading.gif" alt="5.png"></p><p>当参数迭代更新收敛后，对于待预测样本x，便可以像贝叶斯分类器那样计算出样本属于每个类簇的后验概率，接着找出概率最大的即可：</p><p><img src="https://i.loli.net/2018/10/18/5bc856e3dfb1c.png" srcset="/img/loading.gif" alt="6.png"></p><p>可以看出：基于生成式模型的方法十分依赖于对潜在数据分布的假设，即假设的分布要能和真实分布相吻合，否则利用未标记的样本数据反倒会在错误的道路上渐行渐远，从而降低学习器的泛化性能。因此，<strong>此类方法要求极强的领域知识和掐指观天的本领</strong>。</p><p>##<strong>14.2 半监督SVM</strong></p><p>监督学习中的SVM试图找到一个划分超平面，使得两侧支持向量之间的间隔最大，即“<strong>最大划分间隔</strong>”思想。对于半监督学习，S3VM则考虑超平面需穿过数据低密度的区域。TSVM是半监督支持向量机中的最著名代表，其核心思想是：尝试为未标记样本找到合适的标记指派，使得超平面划分后的间隔最大化。TSVM采用局部搜索的策略来进行迭代求解，即首先使用有标记样本集训练出一个初始SVM，接着使用该学习器对未标记样本进行打标，这样所有样本都有了标记，并基于这些有标记的样本重新训练SVM，之后再寻找易出错样本不断调整。整个算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc856e427830.png" srcset="/img/loading.gif" alt="7.png"></p><p><img src="https://s1.ax1x.com/2018/10/18/iwJZss.png" srcset="/img/loading.gif" alt="iwJZss.png"></p><p>##<strong>14.3 基于分歧的方法</strong></p><p>基于分歧的方法通过多个学习器之间的<strong>分歧（disagreement）/多样性（diversity）</strong>来利用未标记样本数据，协同训练就是其中的一种经典方法。<strong>协同训练最初是针对于多视图（multi-view）数据而设计的，多视图数据指的是样本对象具有多个属性集，每个属性集则对应一个试图</strong>。例如：电影数据中就包含画面类属性和声音类属性，这样画面类属性的集合就对应着一个视图。首先引入两个关于视图的重要性质：</p><blockquote><p><strong>相容性</strong>：即使用单个视图数据训练出的学习器的输出空间是一致的。例如都是{好，坏}、{+1,-1}等。<br><strong>互补性</strong>：即不同视图所提供的信息是互补/相辅相成的，实质上这里体现的就是集成学习的思想。</p></blockquote><p>协同训练正是很好地利用了多视图数据的“<strong>相容互补性</strong>”，其基本的思想是：首先基于有标记样本数据在每个视图上都训练一个初始分类器，然后让每个分类器去挑选分类置信度最高的样本并赋予标记，并将带有伪标记的样本数据传给另一个分类器去学习，从而<strong>你依我侬/共同进步</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJVMj.png" srcset="/img/loading.gif" alt="iwJVMj.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwJeLn.png" srcset="/img/loading.gif" alt="iwJeLn.png"></p><p>##<strong>14.4 半监督聚类</strong></p><p>前面提到的几种方法都是借助无标记样本数据来辅助监督学习的训练过程，从而使得学习更加充分/泛化性能得到提升；半监督聚类则是借助已有的监督信息来辅助聚类的过程。一般而言，监督信息大致有两种类型：</p><blockquote><p><strong>必连与勿连约束</strong>：必连指的是两个样本必须在同一个类簇，勿连则是必不在同一个类簇。<br><strong>标记信息</strong>：少量的样本带有真实的标记。</p></blockquote><p>下面主要介绍两种基于半监督的K-Means聚类算法：第一种是数据集包含一些必连与勿连关系，另外一种则是包含少量带有标记的样本。两种算法的基本思想都十分的简单：对于带有约束关系的k-均值算法，在迭代过程中对每个样本划分类簇时，需要<strong>检测当前划分是否满足约束关系</strong>，若不满足则会将该样本划分到距离次小对应的类簇中，再继续检测是否满足约束关系，直到完成所有样本的划分。算法流程如下图所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJAzQ.png" srcset="/img/loading.gif" alt="iwJAzQ.png"></p><p>对于带有少量标记样本的k-均值算法，则可以<strong>利用这些有标记样本进行类中心的指定，同时在对样本进行划分时，不需要改变这些有标记样本的簇隶属关系</strong>，直接将其划分到对应类簇即可。算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJkRg.png" srcset="/img/loading.gif" alt="iwJkRg.png"></p><p>在此，半监督学习就介绍完毕。十分有趣的是：半监督学习将前面许多知识模块联系在了一起，足以体现了作者编排的用心。结合本篇的新知识再来回想之前自己做过的一些研究，发现还是蹚了一些浑水，也许越是觉得过去的自己傻，越就是好的兆头吧~</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(14)--计算学习理论</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了常用的特征选择方法及稀疏学习。首先从相关/无关特征出发引出了特征选择的基本概念，接着分别介绍了子集搜索与评价、过滤式、包裹式以及嵌入式四种类型的特征选择方法。子集搜索与评价使用的是一种优中生优的贪婪算法，即每次从候选特征子集中选出最优子集；过滤式方法计算一个相关统计量来评判特征的重要程度；包裹式方法将学习器作为特征选择的评价准则；嵌入式方法则是通过L1正则项将特征选择融入到学习器参数优化的过程中。最后介绍了稀疏表示与压缩感知的核心思想：稀疏表示利用稀疏矩阵的优良性质，试图通过某种方法找到原始稠密矩阵的合适稀疏表示；压缩感知则试图利用可稀疏表示的欠采样信息来恢复全部信息。本篇将讨论一种为机器学习提供理论保证的学习方法–计算学习理论。</p><p>#<strong>13、计算学习理论</strong></p><p>计算学习理论（computational learning theory）是通过“计算”来研究机器学习的理论，简而言之，其目的是分析学习任务的本质，例如：<strong>在什么条件下可进行有效的学习，需要多少训练样本能获得较好的精度等，从而为机器学习算法提供理论保证</strong>。</p><p>首先我们回归初心，再来谈谈经验误差和泛化误差。假设给定训练集D，其中所有的训练样本都服从一个未知的分布T，且它们都是在总体分布T中独立采样得到，即<strong>独立同分布</strong>（independent and identically distributed，i.i.d.），在《贝叶斯分类器》中我们已经提到：独立同分布是很多统计学习算法的基础假设，例如最大似然法，贝叶斯分类器，高斯混合聚类等，简单来理解独立同分布：每个样本都是从总体分布中独立采样得到，而没有拖泥带水。例如现在要进行问卷调查，要从总体人群中随机采样，看到一个美女你高兴地走过去，结果她男票突然冒了出来，说道：you jump，i jump，于是你本来只想调查一个人结果被强行撒了一把狗粮得到两份问卷，这样这两份问卷就不能称为独立同分布了，因为它们的出现具有强相关性。</p><p>回归正题，<strong>泛化误差指的是学习器在总体上的预测误差，经验误差则是学习器在某个特定数据集D上的预测误差</strong>。在实际问题中，往往我们并不能得到总体且数据集D是通过独立同分布采样得到的，因此我们常常使用经验误差作为泛化误差的近似。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f38d4fe.png" srcset="/img/loading.gif" alt="1.png"></p><p>##<strong>13.1 PAC学习</strong></p><p>在高中课本中，我们将<strong>函数定义为：从自变量到因变量的一种映射；对于机器学习算法，学习器也正是为了寻找合适的映射规则</strong>，即如何从条件属性得到目标属性。从样本空间到标记空间存在着很多的映射，我们将每个映射称之为<strong>概念</strong>（concept），定义：</p><blockquote><p>若概念c对任何样本x满足c(x)=y，则称c为<strong>目标概念</strong>，即最理想的映射，所有的目标概念构成的集合称为<strong>“概念类”</strong>；<br>给定学习算法，它所有可能映射/概念的集合称为<strong>“假设空间”</strong>，其中单个的概念称为<strong>“假设”</strong>（hypothesis）；<br>若一个算法的假设空间包含目标概念，则称该数据集对该算法是<strong>可分</strong>（separable）的，亦称<strong>一致</strong>（consistent）的；<br>若一个算法的假设空间不包含目标概念，则称该数据集对该算法是<strong>不可分</strong>（non-separable）的，或称<strong>不一致</strong>（non-consistent）的。</p></blockquote><p>举个简单的例子：对于非线性分布的数据集，若使用一个线性分类器，则该线性分类器对应的假设空间就是空间中所有可能的超平面，显然假设空间不包含该数据集的目标概念，所以称数据集对该学习器是不可分的。给定一个数据集D，我们希望模型学得的假设h尽可能地与目标概念一致，这便是<strong>概率近似正确</strong> (Probably Approximately Correct，简称PAC)的来源，即以较大的概率学得模型满足误差的预设上限。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f446f97.png" srcset="/img/loading.gif" alt="2.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc854f482d0b.png" srcset="/img/loading.gif" alt="3.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc854f47d006.png" srcset="/img/loading.gif" alt="4.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc854f46ad91.png" srcset="/img/loading.gif" alt="5.png"></p><p>上述关于PAC的几个定义层层相扣：定义12.1表达的是对于某种学习算法，如果能以一个置信度学得假设满足泛化误差的预设上限，则称该算法能PAC辨识概念类，即该算法的输出假设已经十分地逼近目标概念。定义12.2则将样本数量考虑进来，当样本超过一定数量时，学习算法总是能PAC辨识概念类，则称概念类为PAC可学习的。定义12.3将学习器运行时间也考虑进来，若运行时间为多项式时间，则称PAC学习算法。</p><p>显然，PAC学习中的一个关键因素就是<strong>假设空间的复杂度</strong>，对于某个学习算法，<strong>若假设空间越大，则其中包含目标概念的可能性也越大，但同时找到某个具体概念的难度也越大</strong>，一般假设空间分为有限假设空间与无限假设空间。</p><p>##<strong>13.2 有限假设空间</strong></p><p>###<strong>13.2.1 可分情形</strong></p><p>可分或一致的情形指的是：<strong>目标概念包含在算法的假设空间中</strong>。对于目标概念，在训练集D中的经验误差一定为0，因此首先我们可以想到的是：不断地剔除那些出现预测错误的假设，直到找到经验误差为0的假设即为目标概念。但<strong>由于样本集有限，可能会出现多个假设在D上的经验误差都为0，因此问题转化为：需要多大规模的数据集D才能让学习算法以置信度的概率从这些经验误差都为0的假设中找到目标概念的有效近似</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f484f30.png" srcset="/img/loading.gif" alt="6.png"></p><p>通过上式可以得知：<strong>对于可分情形的有限假设空间，目标概念都是PAC可学习的，即当样本数量满足上述条件之后，在与训练集一致的假设中总是可以在1-σ概率下找到目标概念的有效近似。</strong></p><p>###<strong>13.2.2 不可分情形</strong></p><p>不可分或不一致的情形指的是：<strong>目标概念不存在于假设空间中</strong>，这时我们就不能像可分情形时那样从假设空间中寻找目标概念的近似。但<strong>当假设空间给定时，必然存一个假设的泛化误差最小，若能找出此假设的有效近似也不失为一个好的目标，这便是不可知学习(agnostic learning)的来源。</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc854f485f2e.png" srcset="/img/loading.gif" alt="7.png"></p><p>这时候便要用到<strong>Hoeffding不等式</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc854f46970a.png" srcset="/img/loading.gif" alt="8.png"></p><p>对于假设空间中的所有假设，出现泛化误差与经验误差之差大于e的概率和为：</p><p><img src="https://i.loli.net/2018/10/18/5bc854f4114fd.png" srcset="/img/loading.gif" alt="9.png"></p><p>因此，可令不等式的右边小于（等于）σ，便可以求出满足泛化误差与经验误差相差小于e所需的最少样本数，同时也可以求出泛化误差界。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f440a02.png" srcset="/img/loading.gif" alt="10.png"></p><p>##<strong>13.3 VC维</strong></p><p>现实中的学习任务通常都是无限假设空间，例如d维实数域空间中所有的超平面等，因此要对此种情形进行可学习研究，需要度量<strong>假设空间的复杂度</strong>。这便是<strong>VC维</strong>（Vapnik-Chervonenkis dimension）的来源。在介绍VC维之前，需要引入两个概念：</p><blockquote><p><strong>增长函数</strong>：对于给定数据集D，假设空间中的每个假设都能对数据集的样本赋予标记，因此一个假设对应着一种打标结果，不同假设对D的打标结果可能是相同的，也可能是不同的。随着样本数量m的增大，假设空间对样本集D的打标结果也会增多，增长函数则表示假设空间对m个样本的数据集D打标的最大可能结果数，因此<strong>增长函数描述了假设空间的表示能力与复杂度。</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc855ba970cd.png" srcset="/img/loading.gif" alt="11.png"></p></blockquote><blockquote><p><strong>打散</strong>：例如对二分类问题来说，m个样本最多有2^m个可能结果，每种可能结果称为一种<strong>“对分”</strong>，若假设空间能实现数据集D的所有对分，则称数据集能被该假设空间打散。</p></blockquote><p><strong>因此尽管假设空间是无限的，但它对特定数据集打标的不同结果数是有限的，假设空间的VC维正是它能打散的最大数据集大小</strong>。通常这样来计算假设空间的VC维：若存在大小为d的数据集能被假设空间打散，但不存在任何大小为d+1的数据集能被假设空间打散，则其VC维为d。</p><p><img src="https://i.loli.net/2018/10/18/5bc855bb20c1e.png" srcset="/img/loading.gif" alt="12.png"></p><p>同时书中给出了假设空间VC维与增长函数的两个关系：</p><p><img src="https://i.loli.net/2018/10/18/5bc855ba83eb8.png" srcset="/img/loading.gif" alt="13.png"></p><p>直观来理解（1）式也十分容易： 首先假设空间的VC维是d，说明当m&lt;=d时，增长函数与2^m相等，例如：当m=d时，右边的组合数求和刚好等于2^d；而当m=d+1时，右边等于2^(d+1)-1，十分符合VC维的定义，同时也可以使用数学归纳法证明；（2）式则是由（1）式直接推导得出。</p><p>在有限假设空间中，根据Hoeffding不等式便可以推导得出学习算法的泛化误差界；但在无限假设空间中，由于假设空间的大小无法计算，只能通过增长函数来描述其复杂度，因此无限假设空间中的泛化误差界需要引入增长函数。</p><p><img src="https://i.loli.net/2018/10/18/5bc855babc890.png" srcset="/img/loading.gif" alt="14.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc855ba5b2c3.png" srcset="/img/loading.gif" alt="15.png"></p><p>上式给出了基于VC维的泛化误差界，同时也可以计算出满足条件需要的样本数（样本复杂度）。若学习算法满足<strong>经验风险最小化原则（ERM）</strong>，即学习算法的输出假设h在数据集D上的经验误差最小，可证明：<strong>任何VC维有限的假设空间都是（不可知）PAC可学习的，换而言之：若假设空间的最小泛化误差为0即目标概念包含在假设空间中，则是PAC可学习，若最小泛化误差不为0，则称为不可知PAC可学习。</strong></p><p>##<strong>13.4 稳定性</strong></p><p>稳定性考察的是当算法的输入发生变化时，输出是否会随之发生较大的变化，输入的数据集D有以下两种变化：</p><p><img src="https://i.loli.net/2018/10/18/5bc855badc5a8.png" srcset="/img/loading.gif" alt="16.png"></p><p>若对数据集中的任何样本z，满足：</p><p><img src="https://i.loli.net/2018/10/18/5bc855ba59b06.png" srcset="/img/loading.gif" alt="17.png"></p><p>即原学习器和剔除一个样本后生成的学习器对z的损失之差保持β稳定，称学习器关于损失函数满足<strong>β-均匀稳定性</strong>。同时若损失函数有上界，即原学习器对任何样本的损失函数不超过M，则有如下定理：</p><p><img src="https://i.loli.net/2018/10/18/5bc855babe7c3.png" srcset="/img/loading.gif" alt="18.png"></p><p>事实上，<strong>若学习算法符合经验风险最小化原则（ERM）且满足β-均匀稳定性，则假设空间是可学习的</strong>。稳定性通过损失函数与假设空间的可学习联系在了一起，区别在于：假设空间关注的是经验误差与泛化误差，需要考虑到所有可能的假设；而稳定性只关注当前的输出假设。</p><p>在此，计算学习理论就介绍完毕，一看这个名字就知道这一章比较偏底层理论了，最终还是咬着牙看完了它，这里引用一段小文字来梳理一下现在的心情：“孤岂欲卿治经为博士邪？但当涉猎，见往事耳”，就当扩充知识体系吧~</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(13)--特征选择与稀疏学习</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了经典的降维方法与度量学习，首先从“维数灾难”导致的样本稀疏以及距离难计算两大难题出发，引出了降维的概念，即通过某种数学变换将原始高维空间转变到一个低维的子空间，接着分别介绍了kNN、MDS、PCA、KPCA以及两种经典的流形学习方法，k近邻算法的核心在于k值的选取以及距离的度量，MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持，主成分分析试图找到一个低维超平面来表出原空间样本点，核化主成分分析先将样本点映射到高维空间，再在高维空间中使用线性降维的方法，从而解决了原空间样本非线性分布的情形，基于流形学习的降维则是一种“邻域保持”的思想，最后度量学习试图去学习出一个距离度量来等效降维的效果。本篇将讨论另一种常用方法–特征选择与稀疏学习。</p><p>#<strong>12、特征选择与稀疏学习</strong></p><p>最近在看论文的过程中，发现对于数据集行和列的叫法颇有不同，故在介绍本篇之前，决定先将最常用的术语罗列一二，以后再见到了不管它脚扑朔还是眼迷离就能一眼识破真身了~对于数据集中的一个对象及组成对象的零件元素：</p><blockquote><p>统计学家常称它们为<strong>观测</strong>（<strong>observation</strong>）和<strong>变量</strong>（<strong>variable</strong>）；<br>数据库分析师则称其为<strong>记录</strong>（<strong>record</strong>）和<strong>字段</strong>（<strong>field</strong>）；<br>数据挖掘/机器学习学科的研究者则习惯把它们叫做<strong>样本</strong>/<strong>示例</strong>（<strong>example</strong>/<strong>instance</strong>）和<strong>属性</strong>/<strong>特征</strong>（<strong>attribute</strong>/<strong>feature</strong>）。</p></blockquote><p>回归正题，在机器学习中特征选择是一个重要的“<strong>数据预处理</strong>”（<strong>data</strong> <strong>preprocessing</strong>）过程，即试图从数据集的所有特征中挑选出与当前学习任务相关的特征子集，接着再利用数据子集来训练学习器；稀疏学习则是围绕着稀疏矩阵的优良性质，来完成相应的学习任务。</p><p>##<strong>12.1 子集搜索与评价</strong></p><p>一般地，我们可以用很多属性/特征来描述一个示例，例如对于一个人可以用性别、身高、体重、年龄、学历、专业、是否吃货等属性来描述，那现在想要训练出一个学习器来预测人的收入。根据生活经验易知：并不是所有的特征都与学习任务相关，例如年龄/学历/专业可能很大程度上影响了收入，身高/体重这些外貌属性也有较小的可能性影响收入，但像是否是一个地地道道的吃货这种属性就八杆子打不着了。因此我们只需要那些与学习任务紧密相关的特征，<strong>特征选择便是从给定的特征集合中选出相关特征子集的过程</strong>。</p><p>与上篇中降维技术有着异曲同工之处的是，特征选择也可以有效地解决维数灾难的难题。具体而言：<strong>降维从一定程度起到了提炼优质低维属性和降噪的效果，特征选择则是直接剔除那些与学习任务无关的属性而选择出最佳特征子集</strong>。若直接遍历所有特征子集，显然当维数过多时遭遇指数爆炸就行不通了；若采取从候选特征子集中不断迭代生成更优候选子集的方法，则时间复杂度大大减小。这时就涉及到了两个关键环节：<strong>1.如何生成候选子集；2.如何评价候选子集的好坏</strong>，这便是早期特征选择的常用方法。书本上介绍了贪心算法，分为三种策略：</p><blockquote><p><strong>前向搜索</strong>：初始将每个特征当做一个候选特征子集，然后从当前所有的候选子集中选择出最佳的特征子集；接着在上一轮选出的特征子集中添加一个新的特征，同样地选出最佳特征子集；最后直至选不出比上一轮更好的特征子集。<br><strong>后向搜索</strong>：初始将所有特征作为一个候选特征子集；接着尝试去掉上一轮特征子集中的一个特征并选出当前最优的特征子集；最后直到选不出比上一轮更好的特征子集。<br><strong>双向搜索</strong>：将前向搜索与后向搜索结合起来，即在每一轮中既有添加操作也有剔除操作。</p></blockquote><p>对于特征子集的评价，书中给出了一些想法及基于信息熵的方法。假设数据集的属性皆为离散属性，这样给定一个特征子集，便可以通过这个特征子集的取值将数据集合划分为V个子集。例如：A1={男,女}，A2={本科,硕士}就可以将原数据集划分为2*2=4个子集，其中每个子集的取值完全相同。这时我们就可以像决策树选择划分属性那样，通过计算信息增益来评价该属性子集的好坏。</p><p><img src="https://i.loli.net/2018/10/18/5bc853eca1a43.png" srcset="/img/loading.gif" alt="1.png"></p><p>此时，信息增益越大表示该属性子集包含有助于分类的特征越多，使用上述这种<strong>子集搜索与子集评价相结合的机制，便可以得到特征选择方法</strong>。值得一提的是若将前向搜索策略与信息增益结合在一起，与前面我们讲到的ID3决策树十分地相似。事实上，决策树也可以用于特征选择，树节点划分属性组成的集合便是选择出的特征子集。</p><p>##<strong>12.2 过滤式选择（Relief）</strong></p><p>过滤式方法是一种将特征选择与学习器训练相分离的特征选择技术，即首先将相关特征挑选出来，再使用选择出的数据子集来训练学习器。Relief是其中著名的代表性算法，它使用一个“<strong>相关统计量</strong>”来度量特征的重要性，该统计量是一个向量，其中每个分量代表着相应特征的重要性，因此我们最终可以根据这个统计量各个分量的大小来选择出合适的特征子集。</p><p>易知Relief算法的核心在于如何计算出该相关统计量。对于数据集中的每个样例xi，Relief首先找出与xi同类别的最近邻与不同类别的最近邻，分别称为<strong>猜中近邻（near-hit）</strong>与<strong>猜错近邻（near-miss）</strong>，接着便可以分别计算出相关统计量中的每个分量。对于j分量：</p><p><img src="https://i.loli.net/2018/10/18/5bc853ec70c88.png" srcset="/img/loading.gif" alt="2.png"></p><p>直观上理解：对于猜中近邻，两者j属性的距离越小越好，对于猜错近邻，j属性距离越大越好。更一般地，若xi为离散属性，diff取海明距离，即相同取0，不同取1；若xi为连续属性，则diff为曼哈顿距离，即取差的绝对值。分别计算每个分量，最终取平均便得到了整个相关统计量。</p><p>标准的Relief算法只用于二分类问题，后续产生的拓展变体Relief-F则解决了多分类问题。对于j分量，新的计算公式如下：</p><p><img src="https://i.loli.net/2018/10/18/5bc853ec93042.png" srcset="/img/loading.gif" alt="3.png"></p><p>其中pl表示第l类样本在数据集中所占的比例，易知两者的不同之处在于：<strong>标准Relief 只有一个猜错近邻，而Relief-F有多个猜错近邻</strong>。</p><p>##<strong>12.3 包裹式选择（LVW）</strong></p><p>与过滤式选择不同的是，包裹式选择将后续的学习器也考虑进来作为特征选择的评价准则。因此包裹式选择可以看作是为某种学习器<strong>量身定做</strong>的特征选择方法，由于在每一轮迭代中，包裹式选择都需要训练学习器，因此在获得较好性能的同时也产生了较大的开销。下面主要介绍一种经典的包裹式特征选择方法 –LVW（Las Vegas Wrapper），它在拉斯维加斯框架下使用随机策略来进行特征子集的搜索。拉斯维加斯？怎么听起来那么耳熟，不是那个声名显赫的赌场吗？歪果仁真会玩。怀着好奇科普一下，结果又顺带了一个赌场：</p><blockquote><p><strong>蒙特卡罗算法</strong>：采样越多，越近似最优解，一定会给出解，但给出的解不一定是正确解；<br><strong>拉斯维加斯算法</strong>：采样越多，越有机会找到最优解，不一定会给出解，且给出的解一定是正确解。</p></blockquote><p>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找较好的，但不保证是最好的。</p><p>而拉斯维加斯算法，则是另一种情况。假如有一把锁，给我100把钥匙，只有1把是对的。于是我每次随机拿1把钥匙去试，打不开就再换1把。我试的次数越多，打开（正确解）的机会就越大，但在打开之前，那些错的钥匙都是没有用的。这个试钥匙的算法，就是拉斯维加斯的——尽量找最好的，但不保证能找到。</p><p>LVW算法的具体流程如下所示，其中比较特别的是停止条件参数T的设置，即在每一轮寻找最优特征子集的过程中，若随机T次仍没找到，算法就会停止，从而保证了算法运行时间的可行性。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed5e08e.png" srcset="/img/loading.gif" alt="4.png"></p><p>##<strong>12.4 嵌入式选择与正则化</strong></p><p>前面提到了的两种特征选择方法：<strong>过滤式中特征选择与后续学习器完全分离，包裹式则是使用学习器作为特征选择的评价准则；嵌入式是一种将特征选择与学习器训练完全融合的特征选择方法，即将特征选择融入学习器的优化过程中</strong>。在之前《经验风险与结构风险》中已经提到：经验风险指的是模型与训练数据的契合度，结构风险则是模型的复杂程度，机器学习的核心任务就是：<strong>在模型简单的基础上保证模型的契合度</strong>。例如：岭回归就是加上了L2范数的最小二乘法，有效地解决了奇异矩阵、过拟合等诸多问题，下面的嵌入式特征选择则是在损失函数后加上了L1范数。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ec8b203.png" srcset="/img/loading.gif" alt="5.png"></p><p>L1范数美名又约<strong>Lasso Regularization</strong>，指的是向量中每个元素的绝对值之和，这样在优化目标函数的过程中，就会使得w尽可能地小，在一定程度上起到了防止过拟合的作用，同时与L2范数（Ridge Regularization ）不同的是，L1范数会使得部分w变为0， 从而达到了特征选择的效果。</p><p>总的来说：<strong>L1范数会趋向产生少量的特征，其他特征的权值都是0；L2会选择更多的特征，这些特征的权值都会接近于0</strong>。这样L1范数在特征选择上就十分有用，而L2范数则具备较强的控制过拟合能力。可以从下面两个方面来理解：</p><p>（1）<strong>下降速度</strong>：L1范数按照绝对值函数来下降，L2范数按照二次函数来下降。因此在0附近，L1范数的下降速度大于L2范数，故L1范数能很快地下降到0，而L2范数在0附近的下降速度非常慢，因此较大可能收敛在0的附近。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed0aaf5.png" srcset="/img/loading.gif" alt="6.png"></p><p>（2）<strong>空间限制</strong>：L1范数与L2范数都试图在最小化损失函数的同时，让权值W也尽可能地小。我们可以将原优化问题看做为下面的问题，即让后面的规则则都小于某个阈值。这样从图中可以看出：L1范数相比L2范数更容易得到稀疏解。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ecc223e.png" srcset="/img/loading.gif" alt="7.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc853ed51aa1.png" srcset="/img/loading.gif" alt="8.png"></p><p>##<strong>12.5 稀疏表示与字典学习</strong></p><p>当样本数据是一个稀疏矩阵时，对学习任务来说会有不少的好处，例如很多问题变得线性可分，储存更为高效等。这便是稀疏表示与字典学习的基本出发点。稀疏矩阵即矩阵的每一行/列中都包含了大量的零元素，且这些零元素没有出现在同一行/列，对于一个给定的稠密矩阵，若我们能<strong>通过某种方法找到其合适的稀疏表示</strong>，则可以使得学习任务更加简单高效，我们称之为<strong>稀疏编码（sparse coding）</strong>或<strong>字典学习（dictionary learning）</strong>。</p><p>给定一个数据集，字典学习/稀疏编码指的便是通过一个字典将原数据转化为稀疏表示，因此最终的目标就是求得字典矩阵B及稀疏表示α，书中使用变量交替优化的策略能较好地求得解，深感陷进去短时间无法自拔，故先不进行深入…</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed0ca43.png" srcset="/img/loading.gif" alt="9.png"></p><p>##<strong>12.6 压缩感知</strong></p><p>压缩感知在前些年也是风风火火，与特征选择、稀疏表示不同的是：它关注的是通过欠采样信息来恢复全部信息。在实际问题中，为了方便传输和存储，我们一般将数字信息进行压缩，这样就有可能损失部分信息，如何根据已有的信息来重构出全部信号，这便是压缩感知的来历，压缩感知的前提是已知的信息具有稀疏表示。下面是关于压缩感知的一些背景：</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed431c6.png" srcset="/img/loading.gif" alt="10.png"></p><p>在此，特征选择与稀疏学习就介绍完毕。在很多实际情形中，选了好的特征比选了好的模型更为重要，这也是为什么厉害的大牛能够很快地得出一些结论的原因，谓：吾昨晚夜观天象，星象云是否吃货乃无用也~</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(12)--降维与度量学习</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了几种常用的聚类算法，首先从距离度量与性能评估出发，列举了常见的距离计算公式与聚类评价指标，接着分别讨论了K-Means、LVQ、高斯混合聚类、密度聚类以及层次聚类算法。K-Means与LVQ都试图以类簇中心作为原型指导聚类，其中K-Means通过EM算法不断迭代直至收敛，LVQ使用真实类标辅助聚类；高斯混合聚类采用高斯分布来描述类簇原型；密度聚类则是将一个核心对象所有密度可达的样本形成类簇，直到所有核心对象都遍历完；最后层次聚类是一种自底向上的树形聚类方法，不断合并最相近的两个小类簇。本篇将讨论机器学习常用的方法–降维与度量学习。</p><p>#<strong>11、降维与度量学习</strong></p><p>样本的特征数称为<strong>维数</strong>（dimensionality），当维数非常大时，也就是现在所说的“<strong>维数灾难</strong>”，具体表现在：在高维情形下，<strong>数据样本将变得十分稀疏</strong>，因为此时要满足训练样本为“<strong>密采样</strong>”的总体样本数目是一个触不可及的天文数字，谓可远观而不可亵玩焉…<strong>训练样本的稀疏使得其代表总体分布的能力大大减弱，从而消减了学习器的泛化能力</strong>；同时当维数很高时，<strong>计算距离也变得十分复杂</strong>，甚至连计算内积都不再容易，这也是为什么支持向量机（SVM）使用核函数<strong>“低维计算，高维表现”</strong>的原因。</p><p>缓解维数灾难的一个重要途径就是<strong>降维，即通过某种数学变换将原始高维空间转变到一个低维的子空间</strong>。在这个子空间中，样本的密度将大幅提高，同时距离计算也变得容易。这时也许会有疑问，这样降维之后不是会丢失原始数据的一部分信息吗？这是因为在很多实际的问题中，虽然训练数据是高维的，但是与学习任务相关也许仅仅是其中的一个低维子空间，也称为一个<strong>低维嵌入</strong>，例如：数据属性中存在噪声属性、相似属性或冗余属性等，<strong>对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果</strong>。</p><p>##<strong>11.1 K近邻学习</strong></p><p>k近邻算法简称<strong>kNN（k-Nearest Neighbor）</strong>，是一种经典的监督学习方法，同时也实力担当入选数据挖掘十大算法。其工作机制十分简单粗暴：给定某个测试样本，kNN基于某种<strong>距离度量</strong>在训练集中找出与其距离最近的k个带有真实标记的训练样本，然后给基于这k个邻居的真实标记来进行预测，类似于前面集成学习中所讲到的基学习器结合策略：分类任务采用投票法，回归任务则采用平均法。接下来本篇主要就kNN分类进行讨论。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a43873a.png" srcset="/img/loading.gif" alt="1.png"></p><p>从上图【来自Wiki】中我们可以看到，图中有两种类型的样本，一类是蓝色正方形，另一类是红色三角形。而那个绿色圆形是我们待分类的样本。基于kNN算法的思路，我们很容易得到以下结论：</p><blockquote><p>如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。<br>如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。</p></blockquote><p>可以发现：<strong>kNN虽然是一种监督学习方法，但是它却没有显式的训练过程</strong>，而是当有新样本需要预测时，才来计算出最近的k个邻居，因此<strong>kNN是一种典型的懒惰学习方法</strong>，再来回想一下朴素贝叶斯的流程，训练的过程就是参数估计，因此朴素贝叶斯也可以懒惰式学习，此类技术在<strong>训练阶段开销为零</strong>，待收到测试样本后再进行计算。相应地我们称那些一有训练数据立马开工的算法为“<strong>急切学习</strong>”，可见前面我们学习的大部分算法都归属于急切学习。</p><p>很容易看出：<strong>kNN算法的核心在于k值的选取以及距离的度量</strong>。k值选取太小，模型很容易受到噪声数据的干扰，例如：极端地取k=1，若待分类样本正好与一个噪声数据距离最近，就导致了分类错误；若k值太大， 则在更大的邻域内进行投票，此时模型的预测能力大大减弱，例如：极端取k=训练样本数，就相当于模型根本没有学习，所有测试样本的预测结果都是一样的。<strong>一般地我们都通过交叉验证法来选取一个适当的k值</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a47db9a.png" srcset="/img/loading.gif" alt="2.png"></p><p>对于距离度量，<strong>不同的度量方法得到的k个近邻不尽相同，从而对最终的投票结果产生了影响</strong>，因此选择一个合适的距离度量方法也十分重要。在上一篇聚类算法中，在度量样本相似性时介绍了常用的几种距离计算方法，包括<strong>闵可夫斯基距离，曼哈顿距离，VDM</strong>等。在实际应用中，<strong>kNN的距离度量函数一般根据样本的特性来选择合适的距离度量，同时应对数据进行去量纲/归一化处理来消除大量纲属性的强权政治影响</strong>。</p><p>##<strong>11.2 MDS算法</strong></p><p>不管是使用核函数升维还是对数据降维，我们都希望<strong>原始空间样本点之间的距离在新空间中基本保持不变</strong>，这样才不会使得原始空间样本之间的关系及总体分布发生较大的改变。<strong>“多维缩放”（MDS）</strong>正是基于这样的思想，<strong>MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持</strong>。</p><p>假定m个样本在原始空间中任意两两样本之间的距离矩阵为D∈R(m<em>m)，我们的目标便是获得样本在低维空间中的表示Z∈R(d’</em>m , d’&lt; d)，且任意两个样本在低维空间中的欧式距离等于原始空间中的距离，即||zi-zj||=Dist(ij)。因此接下来我们要做的就是根据已有的距离矩阵D来求解出降维后的坐标矩阵Z。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4b664e.png" srcset="/img/loading.gif" alt="3.png"></p><p>令降维后的样本坐标矩阵Z被中心化，<strong>中心化是指将每个样本向量减去整个样本集的均值向量，故所有样本向量求和得到一个零向量</strong>。这样易知：矩阵B的每一列以及每一列求和均为0，因为提取公因子后都有一项为所有样本向量的和向量。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4a4ee2.png" srcset="/img/loading.gif" alt="4.png"></p><p>根据上面矩阵B的特征，我们很容易得到等式（2）、（3）以及（4）：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4a777b.png" srcset="/img/loading.gif" alt="5.png"></p><p>这时根据(1)–(4)式我们便可以计算出bij，即<strong>bij=(1)-(2)<em>(1/m)-(3)</em>(1/m)+(4)*(1/(m^2))</strong>，再逐一地计算每个b(ij)，就得到了降维后低维空间中的内积矩阵B(B=Z’*Z)，只需对B进行特征值分解便可以得到Z。MDS的算法流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a5340dd.png" srcset="/img/loading.gif" alt="6.png"></p><p>##<strong>11.3 主成分分析（PCA）</strong></p><p>不同于MDS采用距离保持的方法，<strong>主成分分析（PCA）直接通过一个线性变换，将原始空间中的样本投影到新的低维空间中</strong>。简单来理解这一过程便是：<strong>PCA采用一组新的基来表示样本点，其中每一个基向量都是原来基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的。</strong></p><p>假设使用d’个新基向量来表示原来样本，实质上是将样本投影到一个由d’个基向量确定的一个<strong>超平面</strong>上（<strong>即舍弃了一些维度</strong>），要用一个超平面对空间中所有高维样本进行恰当的表达，最理想的情形是：<strong>若这些样本点都能在超平面上表出且这些表出在超平面上都能够很好地分散开来</strong>。但是一般使用较原空间低一些维度的超平面来做到这两点十分不容易，因此我们退一步海阔天空，要求这个超平面应具有如下两个性质：</p><blockquote><p><strong>最近重构性</strong>：样本点到超平面的距离足够近，即尽可能在超平面附近；<br><strong>最大可分性</strong>：样本点在超平面上的投影尽可能地分散开来，即投影后的坐标具有区分性。</p></blockquote><p>这里十分神奇的是：<strong>最近重构性与最大可分性虽然从不同的出发点来定义优化问题中的目标函数，但最终这两种特性得到了完全相同的优化问题</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a5213c1.png" srcset="/img/loading.gif" alt="7.png"></p><p>接着使用拉格朗日乘子法求解上面的优化问题，得到：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4a102a.png" srcset="/img/loading.gif" alt="8.png"></p><p>因此只需对协方差矩阵进行特征值分解即可求解出W，PCA算法的整个流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a540eb3.png" srcset="/img/loading.gif" alt="9.png"></p><p>另一篇博客给出更通俗更详细的理解：<a href="http://blog.csdn.net/u011826404/article/details/57472730" target="_blank" rel="noopener">主成分分析解析（基于最大方差理论）</a></p><p>##<strong>11.4 核化线性降维</strong></p><p>说起机器学习你中有我/我中有你/水乳相融…在这里能够得到很好的体现。正如SVM在处理非线性可分时，通过引入核函数将样本投影到高维特征空间，接着在高维空间再对样本点使用超平面划分。这里也是相同的问题：若我们的样本数据点本身就不是线性分布，那还如何使用一个超平面去近似表出呢？因此也就引入了核函数，<strong>即先将样本映射到高维空间，再在高维空间中使用线性降维的方法</strong>。下面主要介绍<strong>核化主成分分析（KPCA）</strong>的思想。</p><p>若核函数的形式已知，即我们知道如何将低维的坐标变换为高维坐标，这时我们只需先将数据映射到高维特征空间，再在高维空间中运用PCA即可。但是一般情况下，我们并不知道核函数具体的映射规则，例如：Sigmoid、高斯核等，我们只知道如何计算高维空间中的样本内积，这时就引出了KPCA的一个重要创新之处：<strong>即空间中的任一向量，都可以由该空间中的所有样本线性表示</strong>。证明过程也十分简单：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a51bd2a.png" srcset="/img/loading.gif" alt="10.png"></p><p>这样我们便可以将高维特征空间中的投影向量wi使用所有高维样本点线性表出，接着代入PCA的求解问题，得到：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b74b083.png" srcset="/img/loading.gif" alt="11.png"></p><p>化简到最后一步，发现结果十分的美妙，只需对核矩阵K进行特征分解，便可以得出投影向量wi对应的系数向量α，因此选取特征值前d’大对应的特征向量便是d’个系数向量。这时对于需要降维的样本点，只需按照以下步骤便可以求出其降维后的坐标。可以看出：KPCA在计算降维后的坐标表示时，需要与所有样本点计算核函数值并求和，因此该算法的计算开销十分大。</p><p><img src="https://i.loli.net/2018/10/18/5bc851b735754.png" srcset="/img/loading.gif" alt="12.png"></p><p>##<strong>11.5 流形学习</strong></p><p><strong>流形学习（manifold learning）是一种借助拓扑流形概念的降维方法</strong>，<strong>流形是指在局部与欧式空间同胚的空间</strong>，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种<strong>“邻域保持”</strong>的思想。其中<strong>等度量映射（Isomap）试图在降维前后保持邻域内样本之间的距离，而局部线性嵌入（LLE）则是保持邻域内样本之间的线性关系</strong>，下面将分别对这两种著名的流行学习方法进行介绍。</p><p>###<strong>11.5.1 等度量映射（Isomap）</strong></p><p>等度量映射的基本出发点是：高维空间中的直线距离具有误导性，因为有时高维空间中的直线距离在低维空间中是不可达的。<strong>因此利用流形在局部上与欧式空间同胚的性质，可以使用近邻距离来逼近测地线距离</strong>，即对于一个样本点，它与近邻内的样本点之间是可达的，且距离使用欧式距离计算，这样整个样本空间就形成了一张近邻图，高维空间中两个样本之间的距离就转为最短路径问题。可采用著名的<strong>Dijkstra算法</strong>或<strong>Floyd算法</strong>计算最短距离，得到高维空间中任意两点之间的距离后便可以使用MDS算法来其计算低维空间中的坐标。</p><p><img src="https://i.loli.net/2018/10/18/5bc851b731a1e.png" srcset="/img/loading.gif" alt="13.png"></p><p>从MDS算法的描述中我们可以知道：MDS先求出了低维空间的内积矩阵B，接着使用特征值分解计算出了样本在低维空间中的坐标，但是并没有给出通用的投影向量w，因此对于需要降维的新样本无从下手，书中给出的权宜之计是利用已知高/低维坐标的样本作为训练集学习出一个“投影器”，便可以用高维坐标预测出低维坐标。Isomap算法流程如下图：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b6c7e37.png" srcset="/img/loading.gif" alt="14.png"></p><p>对于近邻图的构建，常用的有两种方法：<strong>一种是指定近邻点个数</strong>，像kNN一样选取k个最近的邻居；<strong>另一种是指定邻域半径</strong>，距离小于该阈值的被认为是它的近邻点。但两种方法均会出现下面的问题：</p><blockquote><p>若<strong>邻域范围指定过大，则会造成“短路问题”</strong>，即本身距离很远却成了近邻，将距离近的那些样本扼杀在摇篮。<br>若<strong>邻域范围指定过小，则会造成“断路问题”</strong>，即有些样本点无法可达了，整个世界村被划分为互不可达的小部落。</p></blockquote><p>###<strong>11.5.2 局部线性嵌入(LLE)</strong></p><p>不同于Isomap算法去保持邻域距离，LLE算法试图去保持邻域内的线性关系，假定样本xi的坐标可以通过它的邻域样本线性表出：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b64236f.png" srcset="/img/loading.gif" alt="15.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc851b6a7b9a.png" srcset="/img/loading.gif" alt="16.png"></p><p>LLE算法分为两步走，<strong>首先第一步根据近邻关系计算出所有样本的邻域重构系数w</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b662815.png" srcset="/img/loading.gif" alt="17.png"></p><p><strong>接着根据邻域重构系数不变，去求解低维坐标</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b648b98.png" srcset="/img/loading.gif" alt="18.png"></p><p>这样利用矩阵M，优化问题可以重写为：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b6948d7.png" srcset="/img/loading.gif" alt="19.png"></p><p>M特征值分解后最小的d’个特征值对应的特征向量组成Z，LLE算法的具体流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b757d8c.png" srcset="/img/loading.gif" alt="20.png"></p><p>##<strong>11.6 度量学习</strong></p><p>本篇一开始就提到维数灾难，即在高维空间进行机器学习任务遇到样本稀疏、距离难计算等诸多的问题，因此前面讨论的降维方法都试图将原空间投影到一个合适的低维空间中，接着在低维空间进行学习任务从而产生较好的性能。事实上，不管高维空间还是低维空间都潜在对应着一个距离度量，那可不可以直接学习出一个距离度量来等效降维呢？例如：<strong>咋们就按照降维后的方式来进行距离的计算，这便是度量学习的初衷</strong>。</p><p><strong>首先要学习出距离度量必须先定义一个合适的距离度量形式</strong>。对两个样本xi与xj，它们之间的平方欧式距离为：</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3ca3d5.png" srcset="/img/loading.gif" alt="21.png"></p><p>若各个属性重要程度不一样即都有一个权重，则得到加权的平方欧式距离：</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3d82c5.png" srcset="/img/loading.gif" alt="22.png"></p><p>此时各个属性之间都是相互独立无关的，但现实中往往会存在属性之间有关联的情形，例如：身高和体重，一般人越高，体重也会重一些，他们之间存在较大的相关性。这样计算距离就不能分属性单独计算，于是就引入经典的<strong>马氏距离(Mahalanobis distance)</strong>:</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3dc303.png" srcset="/img/loading.gif" alt="23.png"></p><p><strong>标准的马氏距离中M是协方差矩阵的逆，马氏距离是一种考虑属性之间相关性且尺度无关（即无须去量纲）的距离度量</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3e17c0.png" srcset="/img/loading.gif" alt="24.png"></p><p><strong>矩阵M也称为“度量矩阵”，为保证距离度量的非负性与对称性，M必须为(半)正定对称矩阵</strong>，这样就为度量学习定义好了距离度量的形式，换句话说：<strong>度量学习便是对度量矩阵进行学习</strong>。现在来回想一下前面我们接触的机器学习不难发现：<strong>机器学习算法几乎都是在优化目标函数，从而求解目标函数中的参数</strong>。同样对于度量学习，也需要设置一个优化目标，书中简要介绍了错误率和相似性两种优化目标，此处限于篇幅不进行展开。</p><p>在此，降维和度量学习就介绍完毕。<strong>降维是将原高维空间嵌入到一个合适的低维子空间中，接着在低维空间中进行学习任务；度量学习则是试图去学习出一个距离度量来等效降维的效果</strong>，两者都是为了解决维数灾难带来的诸多问题。也许大家最后心存疑惑，那kNN呢，为什么一开头就说了kNN算法，但是好像和后面没有半毛钱关系？正是因为在降维算法中，低维子空间的维数d’通常都由人为指定，因此我们需要使用一些低开销的学习器来选取合适的d’，<strong>kNN这家伙懒到家了根本无心学习，在训练阶段开销为零，测试阶段也只是遍历计算了距离，因此拿kNN来进行交叉验证就十分有优势了~同时降维后样本密度增大同时距离计算变易，更为kNN来展示它独特的十八般手艺提供了用武之地。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(11)--聚类</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)--%E8%81%9A%E7%B1%BB/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)--%E8%81%9A%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了一种机器学习的通用框架–集成学习方法，首先从准确性和差异性两个重要概念引出集成学习“<strong>好而不同</strong>”的四字真言，接着介绍了现阶段主流的三种集成学习方法：AdaBoost、Bagging及Random Forest，AdaBoost采用最小化指数损失函数迭代式更新样本分布权重和计算基学习器权重，Bagging通过自助采样引入样本扰动增加了基学习器之间的差异性，随机森林则进一步引入了属性扰动，最后简单概述了集成模型中的三类结合策略：平均法、投票法及学习法，其中Stacking是学习法的典型代表。本篇将讨论无监督学习中应用最为广泛的学习算法–聚类。</p><p>#<strong>10、聚类算法</strong></p><p>聚类是一种经典的<strong>无监督学习</strong>方法，<strong>无监督学习的目标是通过对无标记训练样本的学习，发掘和揭示数据集本身潜在的结构与规律</strong>，即不依赖于训练数据集的类标记信息。聚类则是试图将数据集的样本划分为若干个互不相交的类簇，从而每个簇对应一个潜在的类别。</p><p>聚类直观上来说是将相似的样本聚在一起，从而形成一个<strong>类簇（cluster）</strong>。那首先的问题是如何来<strong>度量相似性</strong>（similarity measure）呢？这便是<strong>距离度量</strong>，在生活中我们说差别小则相似，对应到多维样本，每个样本可以对应于高维空间中的一个数据点，若它们的距离相近，我们便可以称它们相似。那接着如何来评价聚类结果的好坏呢？这便是<strong>性能度量</strong>，性能度量为评价聚类结果的好坏提供了一系列有效性指标。</p><p>##<strong>10.1 距离度量</strong></p><p>谈及距离度量，最熟悉的莫过于欧式距离了，从年头一直用到年尾的距离计算公式：即对应属性之间相减的平方和再开根号。度量距离还有其它的很多经典方法，通常它们需要满足一些基本性质：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed4c0390.png" srcset="/img/loading.gif" alt="1.png"></p><p>最常用的距离度量方法是<strong>“闵可夫斯基距离”（Minkowski distance)</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed49e31f.png" srcset="/img/loading.gif" alt="2.png"></p><p>当p=1时，闵可夫斯基距离即<strong>曼哈顿距离（Manhattan distance）</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed49c31f.png" srcset="/img/loading.gif" alt="3.png"></p><p>当p=2时，闵可夫斯基距离即<strong>欧氏距离（Euclidean distance）</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed497613.png" srcset="/img/loading.gif" alt="4.png"></p><p>我们知道属性分为两种：<strong>连续属性</strong>和<strong>离散属性</strong>（有限个取值）。对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；而对于离散值的属性，需要作下面进一步的处理：</p><blockquote><p>若属性值之间<strong>存在序关系</strong>，则可以将其转化为连续值，例如：身高属性“高”“中等”“矮”，可转化为{1, 0.5, 0}。<br>若属性值之间<strong>不存在序关系</strong>，则通常将其转化为向量的形式，例如：性别属性“男”“女”，可转化为{（1,0），（0,1）}。</p></blockquote><p>在进行距离度量时，易知<strong>连续属性和存在序关系的离散属性都可以直接参与计算</strong>，因为它们都可以反映一种程度，我们称其为“<strong>有序属性</strong>”；而对于不存在序关系的离散属性，我们称其为：“<strong>无序属性</strong>”，显然无序属性再使用闵可夫斯基距离就行不通了。</p><p><strong>对于无序属性，我们一般采用VDM进行距离的计算</strong>，例如：对于离散属性的两个取值a和b，定义：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed4e9560.png" srcset="/img/loading.gif" alt="5.png"></p><p>于是，在计算两个样本之间的距离时，我们可以将闵可夫斯基距离和VDM混合在一起进行计算：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed507bc7.png" srcset="/img/loading.gif" alt="6.png"></p><p>若我们定义的距离计算方法是用来度量相似性，例如下面将要讨论的聚类问题，即距离越小，相似性越大，反之距离越大，相似性越小。这时距离的度量方法并不一定需要满足前面所说的四个基本性质，这样的方法称为：<strong>非度量距离（non-metric distance）</strong>。</p><p>##<strong>10.2 性能度量</strong></p><p>由于聚类算法不依赖于样本的真实类标，就不能像监督学习的分类那般，通过计算分对分错（即精确度或错误率）来评价学习器的好坏或作为学习过程中的优化目标。一般聚类有两类性能度量指标：<strong>外部指标</strong>和<strong>内部指标</strong>。</p><p>###<strong>10.2.1 外部指标</strong></p><p>即将聚类结果与某个参考模型的结果进行比较，<strong>以参考模型的输出作为标准，来评价聚类好坏</strong>。假设聚类给出的结果为λ，参考模型给出的结果是λ*，则我们将样本进行两两配对，定义：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed59160e.png" srcset="/img/loading.gif" alt="7.png"></p><p>显然a和b代表着聚类结果好坏的正能量，b和c则表示参考结果和聚类结果相矛盾，基于这四个值可以导出以下常用的外部评价指标：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed587438.png" srcset="/img/loading.gif" alt="8.png"></p><p>###<strong>10.2.2 内部指标</strong></p><p>内部指标即不依赖任何外部模型，直接对聚类的结果进行评估，聚类的目的是想将那些相似的样本尽可能聚在一起，不相似的样本尽可能分开，直观来说：<strong>簇内高内聚紧紧抱团，簇间低耦合老死不相往来</strong>。定义：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed581852.png" srcset="/img/loading.gif" alt="9.png"></p><p>基于上面的四个距离，可以导出下面这些常用的内部评价指标：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed582854.png" srcset="/img/loading.gif" alt="10.png"></p><p>##<strong>10.3 原型聚类</strong></p><p>原型聚类即“<strong>基于原型的聚类</strong>”（prototype-based clustering），原型表示模板的意思，就是通过参考一个模板向量或模板分布的方式来完成聚类的过程，常见的K-Means便是基于簇中心来实现聚类，混合高斯聚类则是基于簇分布来实现聚类。</p><p>###<strong>10.3.1 K-Means</strong></p><p>K-Means的思想十分简单，<strong>首先随机指定类中心，根据样本与类中心的远近划分类簇，接着重新计算类中心，迭代直至收敛</strong>。但是其中迭代的过程并不是主观地想象得出，事实上，若将样本的类别看做为“隐变量”（latent variable），类中心看作样本的分布参数，这一过程正是通过<strong>EM算法</strong>的两步走策略而计算出，其根本的目的是为了最小化平方误差函数E：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb82b5d3.png" srcset="/img/loading.gif" alt="11.png"></p><p>K-Means的算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9c0817.png" srcset="/img/loading.gif" alt="12.png"></p><p>###<strong>10.3.2 学习向量量化（LVQ）</strong></p><p>LVQ也是基于原型的聚类算法，与K-Means不同的是，<strong>LVQ使用样本真实类标记辅助聚类</strong>，首先LVQ根据样本的类标记，从各类中分别随机选出一个样本作为该类簇的原型，从而组成了一个<strong>原型特征向量组</strong>，接着从样本集中随机挑选一个样本，计算其与原型向量组中每个向量的距离，并选取距离最小的原型向量所在的类簇作为它的划分结果，再与真实类标比较。</p><blockquote><p><strong>若划分结果正确，则对应原型向量向这个样本靠近一些</strong><br><strong>若划分结果不正确，则对应原型向量向这个样本远离一些</strong></p></blockquote><p>LVQ算法的流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9d59f2.png" srcset="/img/loading.gif" alt="13.png"></p><p>###<strong>10.3.3 高斯混合聚类</strong></p><p>现在可以看出K-Means与LVQ都试图以类中心作为原型指导聚类，高斯混合聚类则采用高斯分布来描述原型。现假设<strong>每个类簇中的样本都服从一个多维高斯分布，那么空间中的样本可以看作由k个多维高斯分布混合而成</strong>。</p><p>对于多维高斯分布，其概率密度函数如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb870d98.png" srcset="/img/loading.gif" alt="14.png"></p><p>其中u表示均值向量，∑表示协方差矩阵，可以看出一个多维高斯分布完全由这两个参数所确定。接着定义高斯混合分布为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb876794.png" srcset="/img/loading.gif" alt="15.png"></p><p>α称为混合系数，这样空间中样本的采集过程则可以抽象为：<strong>（1）先选择一个类簇（高斯分布），（2）再根据对应高斯分布的密度函数进行采样</strong>，这时候贝叶斯公式又能大展身手了：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9191d9.png" srcset="/img/loading.gif" alt="16.png"></p><p>此时只需要选择PM最大时的类簇并将该样本划分到其中，看到这里很容易发现：这和那个传说中的贝叶斯分类不是神似吗，都是通过贝叶斯公式展开，然后计算类先验概率和类条件概率。但遗憾的是：<strong>这里没有真实类标信息，对于类条件概率，并不能像贝叶斯分类那样通过最大似然法美好地计算出来</strong>，因为这里的样本可能属于所有的类簇，这里的似然函数变为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb871d4a.png" srcset="/img/loading.gif" alt="17.png"></p><p>可以看出：简单的最大似然法根本无法求出所有的参数，这样PM也就没法计算。<strong>这里就要召唤出之前的EM大法，首先对高斯分布的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb8a6f32.png" srcset="/img/loading.gif" alt="18.png"></p><p>高斯混合聚类的算法流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9c4fa4.png" srcset="/img/loading.gif" alt="19.png"></p><p>##<strong>10.4 密度聚类</strong></p><p>密度聚类则是基于密度的聚类，它从样本分布的角度来考察样本之间的可连接性，并基于可连接性（密度可达）不断拓展疆域（类簇）。其中最著名的便是<strong>DBSCAN</strong>算法，首先定义以下概念：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9bd69c.png" srcset="/img/loading.gif" alt="20.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc8509f8d619.png" srcset="/img/loading.gif" alt="21.png"></p><p>简单来理解DBSCAN便是：<strong>找出一个核心对象所有密度可达的样本集合形成簇</strong>。首先从数据集中任选一个核心对象A，找出所有A密度可达的样本集合，将这些样本形成一个密度相连的类簇，直到所有的核心对象都遍历完。DBSCAN算法的流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc8509feb587.png" srcset="/img/loading.gif" alt="22.png"></p><p>##<strong>10.5 层次聚类</strong></p><p>层次聚类是一种基于树形结构的聚类方法，常用的是<strong>自底向上</strong>的结合策略（<strong>AGNES算法</strong>）。假设有N个待聚类的样本，其基本步骤是：</p><blockquote><p>1.初始化–&gt;把每个样本归为一类，计算每两个类之间的距离，也就是样本与样本之间的相似度；<br>2.寻找各个类之间最近的两个类，把他们归为一类（这样类的总数就少了一个）；<br>3.重新计算新生成的这个<strong>类与各个旧类之间的相似度</strong>；<br>4.重复2和3直到所有样本点都归为一类，结束。</p></blockquote><p>可以看出其中最关键的一步就是<strong>计算两个类簇的相似度</strong>，这里有多种度量方法：</p><pre><code>* 单链接（single-linkage）:取类间最小距离。</code></pre><p><img src="https://i.loli.net/2018/10/18/5bc8509ebb022.png" srcset="/img/loading.gif" alt="23.png"></p><pre><code>* 全链接（complete-linkage）:取类间最大距离</code></pre><p><img src="https://i.loli.net/2018/10/18/5bc8509eb2b30.png" srcset="/img/loading.gif" alt="24.png"></p><pre><code>* 均链接（average-linkage）:取类间两两的平均距离</code></pre><p><img src="https://i.loli.net/2018/10/18/5bc8509f089a7.png" srcset="/img/loading.gif" alt="25.png"></p><p>很容易看出：<strong>单链接的包容性极强，稍微有点暧昧就当做是自己人了，全链接则是坚持到底，只要存在缺点就坚决不合并，均连接则是从全局出发顾全大局</strong>。层次聚类法的算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc8509f9d4a0.png" srcset="/img/loading.gif" alt="26.png"></p><blockquote><p>在此聚类算法就介绍完毕，分类/聚类都是机器学习中最常见的任务，我实验室的大Boss也是靠着聚类起家，从此走上人生事业钱途…之巅峰，在书最后的阅读材料还看见Boss的名字，所以这章也是必读不可了…</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(10)--集成学习</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了鼎鼎大名的EM算法，从算法思想到数学公式推导（边际似然引入隐变量，Jensen不等式简化求导），EM算法实际上可以理解为一种坐标下降法，首先固定一个变量，接着求另外变量的最优解，通过其优美的“两步走”策略能较好地估计隐变量的值。本篇将继续讨论下一类经典算法–集成学习。</p><p>#<strong>9、集成学习</strong></p><p>顾名思义，集成学习（ensemble learning）指的是将多个学习器进行有效地结合，组建一个“学习器委员会”，其中每个学习器担任委员会成员并行使投票表决权，使得委员会最后的决定更能够四方造福普度众生<del>…</del>，即其泛化性能要能优于其中任何一个学习器。</p><p>##<strong>9.1 个体与集成</strong></p><p>集成学习的基本结构为：先产生一组个体学习器，再使用某种策略将它们结合在一起。集成模型如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0c15683.png" srcset="/img/loading.gif" alt="1.png"></p><p>在上图的集成模型中，若个体学习器都属于同一类别，例如都是决策树或都是神经网络，则称该集成为同质的（homogeneous）;若个体学习器包含多种类型的学习算法，例如既有决策树又有神经网络，则称该集成为异质的（heterogenous）。</p><blockquote><p><strong>同质集成</strong>：个体学习器称为“基学习器”（base learner），对应的学习算法为“基学习算法”（base learning algorithm）。<br><strong>异质集成</strong>：个体学习器称为“组件学习器”（component learner）或直称为“个体学习器”。</p></blockquote><p>上面我们已经提到要让集成起来的泛化性能比单个学习器都要好，虽说团结力量大但也有木桶短板理论调皮捣蛋，那如何做到呢？这就引出了集成学习的两个重要概念：<strong>准确性</strong>和<strong>多样性</strong>（diversity）。准确性指的是个体学习器不能太差，要有一定的准确度；多样性则是个体学习器之间的输出要具有差异性。通过下面的这三个例子可以很容易看出这一点，准确度较高，差异度也较高，可以较好地提升集成性能。</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d23e13.png" srcset="/img/loading.gif" alt="2.png"></p><p>现在考虑二分类的简单情形，假设基分类器之间相互独立（能提供较高的差异度），且错误率相等为 ε，则可以将集成器的预测看做一个伯努利实验，易知当所有基分类器中不足一半预测正确的情况下，集成器预测错误，所以集成器的错误率可以计算为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0cce0bb.png" srcset="/img/loading.gif" alt="3.png"></p><p>此时，集成器错误率随着基分类器的个数的增加呈指数下降，但前提是基分类器之间相互独立，在实际情形中显然是不可能的，假设训练有A和B两个分类器，对于某个测试样本，显然满足：P（A=1 | B=1）&gt; P（A=1），因为A和B为了解决相同的问题而训练，因此在预测新样本时存在着很大的联系。因此，<strong>个体学习器的“准确性”和“差异性”本身就是一对矛盾的变量</strong>，准确性高意味着牺牲多样性，所以产生“<strong>好而不同</strong>”的个体学习器正是集成学习研究的核心。现阶段有三种主流的集成学习方法：Boosting、Bagging以及随机森林（Random Forest），接下来将进行逐一介绍。</p><p>##<strong>9.2 Boosting</strong></p><p>Boosting是一种串行的工作机制，即个体学习器的训练存在依赖关系，必须一步一步序列化进行。其基本思想是：增加前一个基学习器在训练训练过程中预测错误样本的权重，使得后续基学习器更加关注这些打标错误的训练样本，尽可能纠正这些错误，一直向下串行直至产生需要的T个基学习器，Boosting最终对这T个学习器进行加权结合，产生学习器委员会。</p><p>Boosting族算法最著名、使用最为广泛的就是AdaBoost，因此下面主要是对AdaBoost算法进行介绍。AdaBoost使用的是<strong>指数损失函数</strong>，因此AdaBoost的权值与样本分布的更新都是围绕着最小化指数损失函数进行的。看到这里回想一下之前的机器学习算法，<strong>不难发现机器学习的大部分带参模型只是改变了最优化目标中的损失函数</strong>：如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是log-Loss，那就是Logistic Regression了。</p><p>定义基学习器的集成为加权结合，则有：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0ca2ca5.png" srcset="/img/loading.gif" alt="4.png"></p><p>AdaBoost算法的指数损失函数定义为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d10461.png" srcset="/img/loading.gif" alt="5.png"></p><p>具体说来，整个Adaboost 迭代算法分为3步：</p><ul><li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</li><li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li><li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</li></ul><p>整个AdaBoost的算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d7c057.png" srcset="/img/loading.gif" alt="6.png"></p><p>可以看出：<strong>AdaBoost的核心步骤就是计算基学习器权重和样本权重分布</strong>，那为何是上述的计算公式呢？这就涉及到了我们之前为什么说大部分带参机器学习算法只是改变了损失函数，就是因为<strong>大部分模型的参数都是通过最优化损失函数（可能还加个规则项）而计算（梯度下降，坐标下降等）得到</strong>，这里正是通过最优化指数损失函数从而得到这两个参数的计算公式，具体的推导过程此处不进行展开。</p><p>Boosting算法要求基学习器能对特定分布的数据进行学习，即每次都更新样本分布权重，这里书上提到了两种方法：“重赋权法”（re-weighting）和“重采样法”（re-sampling），书上的解释有些晦涩，这里进行展开一下：</p><blockquote><p><strong>重赋权法</strong> : 对每个样本附加一个权重，这时涉及到样本属性与标签的计算，都需要乘上一个权值。<br><strong>重采样法</strong> : 对于一些无法接受带权样本的及学习算法，适合用“重采样法”进行处理。方法大致过程是，根据各个样本的权重，对训练数据进行重采样，初始时样本权重一样，每个样本被采样到的概率一致，每次从N个原始的训练样本中按照权重有放回采样N个样本作为训练集，然后计算训练集错误率，然后调整权重，重复采样，集成多个基学习器。</p></blockquote><p>从偏差-方差分解来看：Boosting算法主要关注于降低偏差，每轮的迭代都关注于训练过程中预测错误的样本，将弱学习提升为强学习器。从AdaBoost的算法流程来看，标准的AdaBoost只适用于二分类问题。在此，当选为数据挖掘十大算法之一的AdaBoost介绍到这里，能够当选正是说明这个算法十分婀娜多姿，背后的数学证明和推导充分证明了这一点，限于篇幅不再继续展开。</p><p>##<strong>9.3 Bagging与Random Forest</strong></p><p>相比之下，Bagging与随机森林算法就简洁了许多，上面已经提到产生“好而不同”的个体学习器是集成学习研究的核心，即在保证基学习器准确性的同时增加基学习器之间的多样性。而这两种算法的基本思（tao）想（lu）都是通过“自助采样”的方法来增加多样性。</p><p>###<strong>9.3.1 Bagging</strong></p><p>Bagging是一种并行式的集成学习方法，即基学习器的训练之间没有前后顺序可以同时进行，Bagging使用“有放回”采样的方式选取训练集，对于包含m个样本的训练集，进行m次有放回的随机采样操作，从而得到m个样本的采样集，这样训练集中有接近36.8%的样本没有被采到。按照相同的方式重复进行，我们就可以采集到T个包含m个样本的数据集，从而训练出T个基学习器，最终对这T个基学习器的输出进行结合。</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0ce62fc.png" srcset="/img/loading.gif" alt="7.png"></p><p>Bagging算法的流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d0e761.png" srcset="/img/loading.gif" alt="8.png"></p><p>可以看出Bagging主要通过<strong>样本的扰动</strong>来增加基学习器之间的多样性，因此Bagging的基学习器应为那些对训练集十分敏感的不稳定学习算法，例如：神经网络与决策树等。从偏差-方差分解来看，Bagging算法主要关注于降低方差，即通过多次重复训练提高稳定性。不同于AdaBoost的是，Bagging可以十分简单地移植到多分类、回归等问题。总的说起来则是：<strong>AdaBoost关注于降低偏差，而Bagging关注于降低方差。</strong></p><p>###<strong>9.3.2 随机森林</strong></p><p>随机森林（Random Forest）是Bagging的一个拓展体，它的基学习器固定为决策树，多棵树也就组成了森林，而“随机”则在于选择划分属性的随机，随机森林在训练基学习器时，也采用有放回采样的方式添加样本扰动，同时它还引入了一种<strong>属性扰动</strong>，即在基决策树的训练过程中，在选择划分属性时，RF先从候选属性集中随机挑选出一个包含K个属性的子集，再从这个子集中选择最优划分属性，一般推荐K=log2（d）。</p><p>这样随机森林中基学习器的多样性不仅来自样本扰动，还来自属性扰动，从而进一步提升了基学习器之间的差异度。相比决策树的Bagging集成，随机森林的起始性能较差（由于属性扰动，基决策树的准确度有所下降），但随着基学习器数目的增多，随机森林往往会收敛到更低的泛化误差。同时不同于Bagging中决策树从所有属性集中选择最优划分属性，随机森林只在属性集的一个子集中选择划分属性，因此训练效率更高。</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d7a4fd.png" srcset="/img/loading.gif" alt="9.png"></p><p>##<strong>9.4 结合策略</strong></p><p>结合策略指的是在训练好基学习器后，如何将这些基学习器的输出结合起来产生集成模型的最终输出，下面将介绍一些常用的结合策略：</p><p>###<strong>9.4.1 平均法（回归问题）</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d07983.png" srcset="/img/loading.gif" alt="10.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc84de1b74ff.png" srcset="/img/loading.gif" alt="11.png"></p><p>易知简单平均法是加权平均法的一种特例，加权平均法可以认为是集成学习研究的基本出发点。由于各个基学习器的权值在训练中得出，<strong>一般而言，在个体学习器性能相差较大时宜使用加权平均法，在个体学习器性能相差较小时宜使用简单平均法</strong>。</p><p>###<strong>9.4.2 投票法（分类问题）</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc84de2629c4.png" srcset="/img/loading.gif" alt="12.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc84de25a74b.png" srcset="/img/loading.gif" alt="13.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc84de1bacc4.png" srcset="/img/loading.gif" alt="14.png"></p><p>绝对多数投票法（majority voting）提供了拒绝选项，这在可靠性要求很高的学习任务中是一个很好的机制。同时，对于分类任务，各个基学习器的输出值有两种类型，分别为类标记和类概率。</p><p><img src="https://i.loli.net/2018/10/18/5bc84de2768c1.png" srcset="/img/loading.gif" alt="15.png"></p><p>一些在产生类别标记的同时也生成置信度的学习器，置信度可转化为类概率使用，<strong>一般基于类概率进行结合往往比基于类标记进行结合的效果更好</strong>，需要注意的是对于异质集成，其类概率不能直接进行比较，此时需要将类概率转化为类标记输出，然后再投票。</p><p>###<strong>9.4.3 学习法</strong></p><p>学习法是一种更高级的结合策略，即学习出一种“投票”的学习器，Stacking是学习法的典型代表。Stacking的基本思想是：首先训练出T个基学习器，对于一个样本它们会产生T个输出，将这T个基学习器的输出与该样本的真实标记作为新的样本，m个样本就会产生一个m<em>T的样本集，来训练一个新的“投票”学习器。投票学习器的输入属性与学习算法对Stacking集成的泛化性能有很大的影响，书中已经提到：*</em>投票学习器采用类概率作为输入属性，选用多响应线性回归（MLR）一般会产生较好的效果**。</p><p><img src="https://i.loli.net/2018/10/18/5bc84de25cbaf.png" srcset="/img/loading.gif" alt="16.png"></p><p>##<strong>9.5 多样性（diversity）</strong></p><p>在集成学习中，基学习器之间的多样性是影响集成器泛化性能的重要因素。因此增加多样性对于集成学习研究十分重要，一般的思路是在学习过程中引入随机性，常见的做法主要是对数据样本、输入属性、输出表示、算法参数进行扰动。</p><blockquote><p><strong>数据样本扰动</strong>，即利用具有差异的数据集来训练不同的基学习器。例如：有放回自助采样法，但此类做法只对那些不稳定学习算法十分有效，例如：决策树和神经网络等，训练集的稍微改变能导致学习器的显著变动。<br><strong>输入属性扰动</strong>，即随机选取原空间的一个子空间来训练基学习器。例如：随机森林，从初始属性集中抽取子集，再基于每个子集来训练基学习器。但若训练集只包含少量属性，则不宜使用属性扰动。<br><strong>输出表示扰动</strong>，此类做法可对训练样本的类标稍作变动，或对基学习器的输出进行转化。<br><strong>算法参数扰动</strong>，通过随机设置不同的参数，例如：神经网络中，随机初始化权重与随机设置隐含层节点数。</p></blockquote><p>在此，集成学习就介绍完毕，看到这里，大家也会发现集成学习实质上是一种通用框架，可以使用任何一种基学习器，从而改进单个学习器的泛化性能。据说数据挖掘竞赛KDDCup历年的冠军几乎都使用了集成学习，看来的确是个好东西~</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(9)--EM算法</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)--EM%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)--EM%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的<strong>EM算法</strong>。</p><p>#<strong>8、EM算法</strong></p><p>EM（Expectation-Maximization）算法是一种常用的估计参数隐变量的利器，也称为“期望最大算法”，是数据挖掘的十大经典算法之一。EM算法主要应用于训练集样本不完整即存在隐变量时的情形（例如某个属性值未知），通过其独特的“两步走”策略能较好地估计出隐变量的值。</p><p>##<strong>8.1 EM算法思想</strong></p><p>EM是一种迭代式的方法，它的基本思想就是：若样本服从的分布参数θ已知，则可以根据已观测到的训练样本推断出隐变量Z的期望值（E步），若Z的值已知则运用最大似然法估计出新的θ值（M步）。重复这个过程直到Z和θ值不再发生变化。</p><p>简单来讲：假设我们想估计A和B这两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。</p><p><img src="https://i.loli.net/2018/10/18/5bc843bf53eb2.png" srcset="/img/loading.gif" alt="1.png"></p><p>现在再来回想聚类的代表算法K-Means：【首先随机选择类中心=&gt;将样本点划分到类簇中=&gt;重新计算类中心=&gt;不断迭代直至收敛】，不难发现这个过程和EM迭代的方法极其相似，事实上，若将样本的类别看做为“隐变量”（latent variable）Z，类中心看作样本的分布参数θ，K-Means就是通过EM算法来进行迭代的，与我们这里不同的是，K-Means的目标是最小化样本点到其对应类中心的距离和，上述为极大化似然函数。</p><p>##<strong>8.2 EM算法数学推导</strong></p><p>在上篇极大似然法中，当样本属性值都已知时，我们很容易通过极大化对数似然，接着对每个参数求偏导计算出参数的值。但当存在隐变量时，就无法直接求解，此时我们通常最大化已观察数据的对数“边际似然”（marginal likelihood）。</p><p><img src="https://i.loli.net/2018/10/18/5bc843bfd84d2.png" srcset="/img/loading.gif" alt="2.png"></p><p>这时候，通过边缘似然将隐变量Z引入进来，对于参数估计，现在与最大似然不同的只是似然函数式中多了一个未知的变量Z，也就是说我们的目标是找到适合的θ和Z让L(θ)最大，这样我们也可以分别对未知的θ和Z求偏导，再令其等于0。</p><p>然而观察上式可以发现，和的对数（ln(x1+x2+x3)）求导十分复杂，那能否通过变换上式得到一种求导简单的新表达式呢？这时候 Jensen不等式就派上用场了，先回顾一下高等数学凸函数的内容：</p><p><strong>Jensen’s inequality</strong>：过一个凸函数上任意两点所作割线一定在这两点间的函数图象的上方。理解起来也十分简单，对于凸函数f(x)’’&gt;0，即曲线的变化率是越来越大单调递增的，所以函数越到后面增长越厉害，这样在一个区间下，函数的均值就会大一些了。</p><p><img src="https://i.loli.net/2018/10/18/5bc843c064c72.png" srcset="/img/loading.gif" alt="3.png"></p><p>因为ln(*)函数为凹函数，故可以将上式“和的对数”变为“对数的和”，这样就很容易求导了。</p><p><img src="https://i.loli.net/2018/10/18/5bc843c3490ad.png" srcset="/img/loading.gif" alt="4.png"></p><p>接着求解Qi和θ：首先固定θ（初始值），通过求解Qi使得J（θ，Q）在θ处与L（θ）相等，即求出L（θ）的下界；然后再固定Qi，调整θ，最大化下界J（θ，Q）。不断重复两个步骤直到稳定。通过jensen不等式的性质，Qi的计算公式实际上就是后验概率：</p><p><img src="https://i.loli.net/2018/10/18/5bc843c21276c.png" srcset="/img/loading.gif" alt="5.png"></p><p>通过数学公式的推导，简单来理解这一过程：固定θ计算Q的过程就是在建立L（θ）的下界，即通过jenson不等式得到的下界（E步）；固定Q计算θ则是使得下界极大化（M步），从而不断推高边缘似然L（θ）。从而循序渐进地计算出L（θ）取得极大值时隐变量Z的估计值。</p><p>EM算法也可以看作一种“坐标下降法”，首先固定一个值，对另外一个值求极值，不断重复直到收敛。这时候也许大家就有疑问，问什么不直接这两个家伙求偏导用梯度下降呢？这时候就是坐标下降的优势，有些特殊的函数，例如曲线函数z=y^2+x^2+x^2y+xy+…，无法直接求导，这时如果先固定其中的一个变量，再对另一个变量求极值，则变得可行。</p><p><img src="https://i.loli.net/2018/10/18/5bc843c34e7ff.png" srcset="/img/loading.gif" alt="6.png"></p><p>##<strong>8.3 EM算法流程</strong></p><p>看完数学推导，算法的流程也就十分简单了，这里有两个版本，版本一来自西瓜书，周天使的介绍十分简洁；版本二来自于大牛的博客。结合着数学推导，自认为版本二更具有逻辑性，两者唯一的区别就在于版本二多出了红框的部分，这里我也没得到答案，欢迎骚扰讨论~</p><p><strong>版本一：</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc843c0e19db.png" srcset="/img/loading.gif" alt="7.png"></p><p><strong>版本二：</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc843c34775b.png" srcset="/img/loading.gif" alt="8.png"></p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(8)--贝叶斯分类器</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍和讨论了支持向量机。从最初的分类函数，通过最大化分类间隔，max(1/||w||)，min(1/2||w||^2)，凸二次规划，朗格朗日函数，对偶问题，一直到最后的SMO算法求解，都为寻找一个最优解。接着引入核函数将低维空间映射到高维特征空间，解决了非线性可分的情形。最后介绍了软间隔支持向量机，解决了outlier挤歪超平面的问题。本篇将讨论一个经典的统计学习算法–<strong>贝叶斯分类器</strong>。</p><p>#<strong>7、贝叶斯分类器</strong></p><p>贝叶斯分类器是一种概率框架下的统计学习分类器，对分类任务而言，假设在相关概率都已知的情况下，贝叶斯分类器考虑如何基于这些概率为样本判定最优的类标。在开始介绍贝叶斯决策论之前，我们首先来回顾下概率论委员会常委–贝叶斯公式。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd7a2575.png" srcset="/img/loading.gif" alt="1.png"></p><p>##<strong>7.1 贝叶斯决策论</strong></p><p>若将上述定义中样本空间的划分Bi看做为类标，A看做为一个新的样本，则很容易将条件概率理解为样本A是类别Bi的概率。在机器学习训练模型的过程中，往往我们都试图去优化一个风险函数，因此在概率框架下我们也可以为贝叶斯定义“<strong>条件风险</strong>”（conditional risk）。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd15db94.png" srcset="/img/loading.gif" alt="2.png"></p><p>我们的任务就是寻找一个判定准则最小化所有样本的条件风险总和，因此就有了<strong>贝叶斯判定准则</strong>（Bayes decision rule）:为最小化总体风险，只需在每个样本上选择那个使得条件风险最小的类标。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd308600.png" srcset="/img/loading.gif" alt="3.png"></p><p>若损失函数λ取0-1损失，则有：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd37c502.png" srcset="/img/loading.gif" alt="4.png"></p><p>即对于每个样本x，选择其后验概率P（c | x）最大所对应的类标，能使得总体风险函数最小，从而将原问题转化为估计后验概率P（c | x）。一般这里有两种策略来对后验概率进行估计：</p><pre><code>* 判别式模型：直接对 P（c | x）进行建模求解。例我们前面所介绍的决策树、神经网络、SVM都是属于判别式模型。* 生成式模型：通过先对联合分布P（x,c）建模，从而进一步求解 P（c | x）。</code></pre><p>贝叶斯分类器就属于生成式模型，基于贝叶斯公式对后验概率P（c | x） 进行一项神奇的变换，巴拉拉能量…. P（c | x）变身：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd501ad3.png" srcset="/img/loading.gif" alt="5.png"></p><p>对于给定的样本x，P（x）与类标无关，P（c）称为类先验概率，p（x | c ）称为类条件概率。这时估计后验概率P（c | x）就变成为估计类先验概率和类条件概率的问题。对于先验概率和后验概率，在看这章之前也是模糊了我好久，这里普及一下它们的基本概念。</p><pre><code>* 先验概率： 根据以往经验和分析得到的概率。* 后验概率：后验概率是基于新的信息，修正原来的先验概率后所获得的更接近实际情况的概率估计。</code></pre><p>实际上先验概率就是在没有任何结果出来的情况下估计的概率，而后验概率则是在有一定依据后的重新估计，直观意义上后验概率就是条件概率。下面直接上Wiki上的一个例子，简单粗暴快速完事…</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd799610.png" srcset="/img/loading.gif" alt="6.png"></p><p>回归正题，对于类先验概率P（c），p（c）就是样本空间中各类样本所占的比例，根据大数定理（当样本足够多时，频率趋于稳定等于其概率），这样当训练样本充足时，p(c)可以使用各类出现的频率来代替。因此只剩下类条件概率p（x | c ），它表达的意思是在类别c中出现x的概率，它涉及到属性的联合概率问题，若只有一个离散属性还好，当属性多时采用频率估计起来就十分困难，因此这里一般采用极大似然法进行估计。</p><p>##<strong>7.2 极大似然法</strong></p><p>极大似然估计（Maximum Likelihood Estimation，简称MLE），是一种根据数据采样来估计概率分布的经典方法。常用的策略是先假定总体具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计。运用到类条件概率p（x | c ）中，假设p（x | c ）服从一个参数为θ的分布，问题就变为根据已知的训练样本来估计θ。极大似然法的核心思想就是：估计出的参数使得已知样本出现的概率最大，即使得训练数据的似然最大。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd70fb73.png" srcset="/img/loading.gif" alt="7.png"></p><p>所以，贝叶斯分类器的训练过程就是参数估计。总结最大似然法估计参数的过程，一般分为以下四个步骤：</p><pre><code>* 1.写出似然函数；* 2.对似然函数取对数，并整理；* 3.求导数，令偏导数为0，得到似然方程组；* 4.解似然方程组，得到所有参数即为所求。</code></pre><p>例如：假设样本属性都是连续值，p（x | c ）服从一个多维高斯分布，则通过MLE计算出的参数刚好分别为：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd705729.png" srcset="/img/loading.gif" alt="8.png"></p><p>上述结果看起来十分合乎实际，但是采用最大似然法估计参数的效果很大程度上依赖于作出的假设是否合理，是否符合潜在的真实数据分布。这就需要大量的经验知识，搞统计越来越值钱也是这个道理，大牛们掐指一算比我们搬砖几天更有效果。</p><p>##<strong>7.3 朴素贝叶斯分类器</strong></p><p>不难看出：原始的贝叶斯分类器最大的问题在于联合概率密度函数的估计，首先需要根据经验来假设联合概率分布，其次当属性很多时，训练样本往往覆盖不够，参数的估计会出现很大的偏差。为了避免这个问题，朴素贝叶斯分类器（naive Bayes classifier）采用了“属性条件独立性假设”，即样本数据的所有属性之间相互独立。这样类条件概率p（x | c ）可以改写为：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd55e102.png" srcset="/img/loading.gif" alt="9.png"></p><p>这样，为每个样本估计类条件概率变成为每个样本的每个属性估计类条件概率。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd6678cd.png" srcset="/img/loading.gif" alt="10.png"></p><p>相比原始贝叶斯分类器，朴素贝叶斯分类器基于单个的属性计算类条件概率更加容易操作，需要注意的是：若某个属性值在训练集中和某个类别没有一起出现过，这样会抹掉其它的属性信息，因为该样本的类条件概率被计算为0。因此在估计概率值时，常常用进行平滑（smoothing）处理，拉普拉斯修正（Laplacian correction）就是其中的一种经典方法，具体计算方法如下：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fe54aaed.png" srcset="/img/loading.gif" alt="11.png"></p><p>当训练集越大时，拉普拉斯修正引入的影响越来越小。对于贝叶斯分类器，模型的训练就是参数估计，因此可以事先将所有的概率储存好，当有新样本需要判定时，直接查表计算即可。</p><p>针对朴素贝叶斯，人们觉得它too sample，sometimes too naive！因此又提出了半朴素的贝叶斯分类器，具体有SPODE、TAN、贝叶斯网络等来刻画属性之间的依赖关系，此处不进行深入，等哪天和贝叶斯邂逅了再回来讨论。在此鼎鼎大名的贝叶斯介绍完毕，下一篇将介绍这一章剩下的内容–EM算法，朴素贝叶斯和EM算法同为数据挖掘的十大经典算法，想着还是单独介绍吧~</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(7)--支持向量机</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>写在前面的话：距离上篇博客竟过去快一个月了，写完神经网络博客正式进入考试模式，几次考试+几篇报告下来弄得心颇不宁静了，今日定下来看到一句鸡血：Tomorrow is another due！也许生活就需要一些deadline~~</p><p>上篇主要介绍了神经网络。首先从生物学神经元出发，引出了它的数学抽象模型–MP神经元以及由两层神经元组成的感知机模型，并基于梯度下降的方法描述了感知机模型的权值调整规则。由于简单的感知机不能处理线性不可分的情形，因此接着引入了含隐层的前馈型神经网络，BP神经网络则是其中最为成功的一种学习方法，它使用误差逆传播的方法来逐层调节连接权。最后简单介绍了局部/全局最小以及目前十分火热的深度学习的概念。本篇围绕的核心则是曾经一度取代过神经网络的另一种监督学习算法–<strong>支持向量机</strong>（Support Vector Machine），简称<strong>SVM</strong>。</p><p>#<strong>6、支持向量机</strong></p><p>支持向量机是一种经典的二分类模型，基本模型定义为特征空间中最大间隔的线性分类器，其学习的优化目标便是间隔最大化，因此支持向量机本身可以转化为一个凸二次规划求解的问题。</p><p>##<strong>6.1 函数间隔与几何间隔</strong></p><p>对于二分类学习，假设现在的数据是线性可分的，这时分类学习最基本的想法就是找到一个合适的超平面，该超平面能够将不同类别的样本分开，类似二维平面使用ax+by+c=0来表示，超平面实际上表示的就是高维的平面，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6a2ec8a.png" srcset="/img/loading.gif" alt="1.png"></p><p>对数据点进行划分时，易知：当超平面距离与它最近的数据点的间隔越大，分类的鲁棒性越好，即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小。因此需要让所选择的超平面能够最大化这个间隔Gap（如下图所示）， 常用的间隔定义有两种，一种称之为函数间隔，一种为几何间隔，下面将分别介绍这两种间隔，并对SVM为什么会选用几何间隔做了一些阐述。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6a06d5a.png" srcset="/img/loading.gif" alt="2.png"></p><p>###<strong>6.1.1 函数间隔</strong></p><p>在超平面w’x+b=0确定的情况下，|w’x<em>+b|能够代表点x*距离超平面的远近，易知：当w’x</em>+b&gt;0时，表示x<em>在超平面的一侧（正类，类标为1），而当w’x</em>+b&lt;0时，则表示x<em>在超平面的另外一侧（负类，类别为-1），因此（w’x</em>+b）y* 的正负性恰能表示数据点x<em>是否被分类正确。于是便引出了*</em>函数间隔**的定义（functional margin）:</p><p><img src="https://i.loli.net/2018/10/17/5bc72f690a14b.png" srcset="/img/loading.gif" alt="3.png"></p><p>而超平面（w,b）关于所有样本点（Xi，Yi）的函数间隔最小值则为超平面在训练数据集T上的函数间隔：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f690ac26.png" srcset="/img/loading.gif" alt="4.png"></p><p>可以看出：这样定义的函数间隔在处理SVM上会有问题，当超平面的两个参数w和b同比例改变时，函数间隔也会跟着改变，但是实际上超平面还是原来的超平面，并没有变化。例如：w1x1+w2x2+w3x3+b=0其实等价于2w1x1+2w2x2+2w3x3+2b=0，但计算的函数间隔却翻了一倍。从而引出了能真正度量点到超平面距离的概念–几何间隔（geometrical margin）。</p><p>###<strong>6.1.2 几何间隔</strong></p><p><strong>几何间隔</strong>代表的则是数据点到超平面的真实距离，对于超平面w’x+b=0，w代表的是该超平面的法向量，设x<em>为超平面外一点x在法向量w方向上的投影点，x与超平面的距离为r，则有x</em>=x-r(w/||w||)，又x<em>在超平面上，即w’x</em>+b=0，代入即可得：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f697d499.png" srcset="/img/loading.gif" alt="5.png"></p><p>为了得到r的绝对值，令r呈上其对应的类别y，即可得到几何间隔的定义：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f696fd10.png" srcset="/img/loading.gif" alt="6.png"></p><p>从上述函数间隔与几何间隔的定义可以看出：实质上函数间隔就是|w’x+b|，而几何间隔就是点到超平面的距离。</p><p>##<strong>6.2 最大间隔与支持向量</strong></p><p>通过前面的分析可知：函数间隔不适合用来最大化间隔，因此这里我们要找的最大间隔指的是几何间隔，于是最大间隔分类器的目标函数定义为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f69af163.png" srcset="/img/loading.gif" alt="7.png"></p><p>一般地，我们令r^为1（这样做的目的是为了方便推导和目标函数的优化），从而上述目标函数转化为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f697bb1d.png" srcset="/img/loading.gif" alt="8.png"></p><p>对于y(w’x+b)=1的数据点，即下图中位于w’x+b=1或w’x+b=-1上的数据点，我们称之为<strong>支持向量</strong>（support vector），易知：对于所有的支持向量，它们恰好满足y<em>(w’x</em>+b)=1，而所有不是支持向量的点，有y<em>(w’x</em>+b)&gt;1。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6a838c4.png" srcset="/img/loading.gif" alt="9.png"></p><p>##<strong>6.3 从原始优化问题到对偶问题</strong></p><p>对于上述得到的目标函数，求1/||w||的最大值相当于求||w||^2的最小值，因此很容易将原来的目标函数转化为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6978cbb.png" srcset="/img/loading.gif" alt="10.png"></p><p>即变为了一个带约束的凸二次规划问题，按书上所说可以使用现成的优化计算包（QP优化包）求解，但由于SVM的特殊性，一般我们将原问题变换为它的<strong>对偶问题</strong>，接着再对其对偶问题进行求解。为什么通过对偶问题进行求解，有下面两个原因：</p><pre><code>* 一是因为使用对偶问题更容易求解；* 二是因为通过对偶问题求解出现了向量内积的形式，从而能更加自然地引出核函数。</code></pre><p>对偶问题，顾名思义，可以理解成优化等价的问题，更一般地，是将一个原始目标函数的最小化转化为它的对偶函数最大化的问题。对于当前的优化问题，首先我们写出它的朗格朗日函数：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9332be7.png" srcset="/img/loading.gif" alt="11.png"></p><p>上式很容易验证：当其中有一个约束条件不满足时，L的最大值为 ∞（只需令其对应的α为 ∞即可）；当所有约束条件都满足时，L的最大值为1/2||w||^2（此时令所有的α为0），因此实际上原问题等价于：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f93321c5.png" srcset="/img/loading.gif" alt="12.png"></p><p>由于这个的求解问题不好做，因此一般我们将最小和最大的位置交换一下（需满足KKT条件） ，变成原问题的对偶问题：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9330967.png" srcset="/img/loading.gif" alt="13.png"></p><p>这样就将原问题的求最小变成了对偶问题求最大（用对偶这个词还是很形象），接下来便可以先求L对w和b的极小，再求L对α的极大。</p><p>（1）首先求L对w和b的极小，分别求L关于w和b的偏导，可以得出：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9333e66.png" srcset="/img/loading.gif" alt="14.png"></p><p>将上述结果代入L得到：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f935ae21.png" srcset="/img/loading.gif" alt="15.png"></p><p>（2）接着L关于α极大求解α（通过SMO算法求解，此处不做深入）。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9338a9d.png" srcset="/img/loading.gif" alt="16.png"></p><p>（3）最后便可以根据求解出的α，计算出w和b，从而得到分类超平面函数。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f93419ca.png" srcset="/img/loading.gif" alt="17.png"></p><p>在对新的点进行预测时，实际上就是将数据点x*代入分类函数f(x)=w’x+b中，若f(x)&gt;0，则为正类，f(x)&lt;0，则为负类，根据前面推导得出的w与b，分类函数如下所示，此时便出现了上面所提到的内积形式。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9353166.png" srcset="/img/loading.gif" alt="18.png"></p><p>这里实际上只需计算新样本与支持向量的内积，因为对于非支持向量的数据点，其对应的拉格朗日乘子一定为0，根据最优化理论（K-T条件），对于不等式约束y(w’x+b)-1≥0，满足：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f933c947.png" srcset="/img/loading.gif" alt="19.png">        </p><p>##<strong>6.4 核函数</strong></p><p>由于上述的超平面只能解决线性可分的问题，对于线性不可分的问题，例如：异或问题，我们需要使用核函数将其进行推广。一般地，解决线性不可分问题时，常常采用<strong>映射</strong>的方式，将低维原始空间映射到高维特征空间，使得数据集在高维空间中变得线性可分，从而再使用线性学习器分类。如果原始空间为有限维，即属性数有限，那么总是存在一个高维特征空间使得样本线性可分。若∅代表一个映射，则在特征空间中的划分函数变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f934303e.png" srcset="/img/loading.gif" alt="20.png"></p><p>按照同样的方法，先写出新目标函数的拉格朗日函数，接着写出其对偶问题，求L关于w和b的极大，最后运用SOM求解α。可以得出：</p><p>（1）原对偶问题变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc68b3b.png" srcset="/img/loading.gif" alt="21.png"></p><p>（2）原分类函数变为：<br>​    <img src="https://i.loli.net/2018/10/17/5bc730cc1b673.png" srcset="/img/loading.gif" alt="22.png"></p><p>求解的过程中，只涉及到了高维特征空间中的内积运算，由于特征空间的维数可能会非常大，例如：若原始空间为二维，映射后的特征空间为5维，若原始空间为三维，映射后的特征空间将是19维，之后甚至可能出现无穷维，根本无法进行内积运算了，此时便引出了<strong>核函数</strong>（Kernel）的概念。</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc49adc.png" srcset="/img/loading.gif" alt="23.png"></p><p>因此，核函数可以直接计算隐式映射到高维特征空间后的向量内积，而不需要显式地写出映射后的结果，它虽然完成了将特征从低维到高维的转换，但最终却是在低维空间中完成向量内积计算，与高维特征空间中的计算等效<strong>（低维计算，高维表现）</strong>，从而避免了直接在高维空间无法计算的问题。引入核函数后，原来的对偶问题与分类函数则变为：</p><p>（1）对偶问题：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc173b2.png" srcset="/img/loading.gif" alt="24.png"></p><p>（2）分类函数：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc05959.png" srcset="/img/loading.gif" alt="25.png"></p><p>因此，在线性不可分问题中，核函数的选择成了支持向量机的最大变数，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，核函数需要满足以下这个必要条件：</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccc468c.png" srcset="/img/loading.gif" alt="26.png"></p><p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccc541a.png" srcset="/img/loading.gif" alt="27.png"></p><p>##<strong>6.5 软间隔支持向量机</strong></p><p>前面的讨论中，我们主要解决了两个问题：当数据线性可分时，直接使用最大间隔的超平面划分；当数据线性不可分时，则通过核函数将数据映射到高维特征空间，使之线性可分。然而在现实问题中，对于某些情形还是很难处理，例如数据中有<strong>噪声</strong>的情形，噪声数据（<strong>outlier</strong>）本身就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，当加入这些outlier后导致划分超平面被挤歪了，如下图所示，对支持向量机的泛化性能造成很大的影响。</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccce68e.png" srcset="/img/loading.gif" alt="28.png"></p><p>为了解决这一问题，我们需要允许某一些数据点不满足约束，即可以在一定程度上偏移超平面，同时使得不满足约束的数据点尽可能少，这便引出了<strong>“软间隔”支持向量机</strong>的概念</p><pre><code>* 允许某些数据点不满足约束y(w&#39;x+b)≥1；* 同时又使得不满足约束的样本尽可能少。</code></pre><p>这样优化目标变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc6c9fe.png" srcset="/img/loading.gif" alt="29.png"></p><p>如同阶跃函数，0/1损失函数虽然表示效果最好，但是数学性质不佳。因此常用其它函数作为“替代损失函数”。</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc5e5a9.png" srcset="/img/loading.gif" alt="30.png"></p><p>支持向量机中的损失函数为<strong>hinge损失</strong>，引入<strong>“松弛变量”</strong>，目标函数与约束条件可以写为：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317aa3411.png" srcset="/img/loading.gif" alt="31.png"></p><p>其中C为一个参数，控制着目标函数与新引入正则项之间的权重，这样显然每个样本数据都有一个对应的松弛变量，用以表示该样本不满足约束的程度，将新的目标函数转化为拉格朗日函数得到：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317a4c96e.png" srcset="/img/loading.gif" alt="32.png"></p><p>按照与之前相同的方法，先让L求关于w，b以及松弛变量的极小，再使用SMO求出α，有：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317a6dff2.png" srcset="/img/loading.gif" alt="33.png"></p><p>将w代入L化简，便得到其对偶问题：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317ab6646.png" srcset="/img/loading.gif" alt="34.png"></p><p>将“软间隔”下产生的对偶问题与原对偶问题对比可以发现：新的对偶问题只是约束条件中的α多出了一个上限C，其它的完全相同，因此在引入核函数处理线性不可分问题时，便能使用与“硬间隔”支持向量机完全相同的方法。</p><p>—-在此SVM就介绍完毕。</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(6)--神经网络</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值/缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法–神经网络（neural network）。</p><p>#<strong>5、神经网络</strong></p><p>在机器学习中，神经网络一般指的是“神经网络学习”，是机器学习与神经网络两个学科的交叉部分。所谓神经网络，目前用得最广泛的一个定义是“神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的交互反应”。</p><p>##<strong>5.1 神经元模型</strong></p><p>神经网络中最基本的单元是神经元模型（neuron）。在生物神经网络的原始机制中，每个神经元通常都有多个树突（dendrite），一个轴突（axon）和一个细胞体（cell body），树突短而多分支，轴突长而只有一个；在功能上，树突用于传入其它神经元传递的神经冲动，而轴突用于将神经冲动传出到其它神经元，当树突或细胞体传入的神经冲动使得神经元兴奋时，该神经元就会通过轴突向其它神经元传递兴奋。神经元的生物学结构如下图所示，不得不说高中的生化知识大学忘得可是真干净…</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb6cc11.png" srcset="/img/loading.gif" alt="1.png"></p><p>一直沿用至今的“M-P神经元模型”正是对这一结构进行了抽象，也称“阈值逻辑单元“，其中树突对应于输入部分，每个神经元收到n个其他神经元传递过来的输入信号，这些信号通过带权重的连接传递给细胞体，这些权重又称为连接权（connection weight）。细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb7be44.png" srcset="/img/loading.gif" alt="2.png"></p><p>与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb40dc5.png" srcset="/img/loading.gif" alt="3.png"></p><p>将多个神经元按一定的层次结构连接起来，就得到了神经网络。它是一种包含多个参数的模型，比方说10个神经元两两连接，则有100个参数需要学习（每个神经元有9个连接权以及1个阈值），若将每个神经元都看作一个函数，则整个神经网络就是由这些函数相互嵌套而成。</p><p>##<strong>5.2 感知机与多层网络</strong></p><p>感知机（Perceptron）是由两层神经元组成的一个简单模型，但只有输出层是M-P神经元，即只有输出层神经元进行激活函数处理，也称为功能神经元（functional neuron）；输入层只是接受外界信号（样本属性）并传递给输出层（输入层的神经元个数等于样本的属性数目），而没有激活函数。这样一来，感知机与之前线性模型中的对数几率回归的思想基本是一样的，都是通过对属性加权与另一个常数求和，再使用sigmoid函数将这个输出值压缩到0-1之间，从而解决分类问题。不同的是感知机的输出层应该可以有多个神经元，从而可以实现多分类问题，同时两个模型所用的参数估计方法十分不同。</p><p>给定训练集，则感知机的n+1个参数（n个权重+1个阈值）都可以通过学习得到。阈值Θ可以看作一个输入值固定为-1的哑结点的权重ωn+1，即假设有一个固定输入xn+1=-1的输入层神经元，其对应的权重为ωn+1，这样就把权重和阈值统一为权重的学习了。简单感知机的结构如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb3fdf0.png" srcset="/img/loading.gif" alt="4.png"></p><p>感知机权重的学习规则如下：对于训练样本（x，y），当该样本进入感知机学习后，会产生一个输出值，若该输出值与样本的真实标记不一致，则感知机会对权重进行调整，若激活函数为阶跃函数，则调整的方法为（基于梯度下降法）：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb3ba63.png" srcset="/img/loading.gif" alt="5.png"></p><p>其中 η∈（0，1）称为学习率，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。</p><p>由于感知机模型只有一层功能神经元，因此其功能十分有限，只能处理线性可分的问题，对于这类问题，感知机的学习过程一定会收敛（converge），因此总是可以求出适当的权值。但是对于像书上提到的异或问题，只通过一层功能神经元往往不能解决，因此要解决非线性可分问题，需要考虑使用多层功能神经元，即神经网络。多层神经网络的拓扑结构如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb58ec6.png" srcset="/img/loading.gif" alt="6.png"></p><p>在神经网络中，输入层与输出层之间的层称为隐含层或隐层（hidden layer），隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“多层前馈神经网络”（multi-layer feedforward neural network），该结构满足以下几个特点：</p><pre><code>* 每层神经元与下一层神经元之间完全互连* 神经元之间不存在同层连接* 神经元之间不存在跨层连接</code></pre><p><img src="https://i.loli.net/2018/10/17/5bc72cbb47ff8.png" srcset="/img/loading.gif" alt="7.png"></p><p>根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在环或回路，而不是指该网络只能向前传播而不能向后传播（下节中的BP神经网络正是基于前馈神经网络而增加了反馈调节机制）。神经网络的学习过程就是根据训练数据来调整神经元之间的“连接权”以及每个神经元的阈值，换句话说：神经网络所学习到的东西都蕴含在网络的连接权与阈值中。</p><p>##<strong>5.3 BP神经网络算法</strong></p><p>由上面可以得知：神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。</p><p>一般而言，只需包含一个足够多神经元的隐层，就能以任意精度逼近任意复杂度的连续函数[Hornik et al.,1989]，故下面以训练单隐层的前馈神经网络为例，介绍BP神经网络的算法思想。</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb92ff5.png" srcset="/img/loading.gif" alt="8.png"></p><p>上图为一个单隐层前馈神经网络的拓扑结构，BP神经网络算法也使用梯度下降法（gradient descent），以单个样本的均方误差的负梯度方向对权重进行调节。可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb86229.png" srcset="/img/loading.gif" alt="9.png"></p><p>学习率η∈（0，1）控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把η设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。BP算法的基本流程如下所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb59e99.png" srcset="/img/loading.gif" alt="10.png"></p><p>BP算法的更新规则是基于每个样本的预测值与真实类标的均方误差来进行权值调节，即BP算法每次更新只针对于单个样例。需要注意的是：BP算法的最终目标是要最小化整个训练集D上的累积误差，即：</p><p><img src="https://i.loli.net/2018/10/17/5bc72ce222a96.png" srcset="/img/loading.gif" alt="11.png"></p><p>如果基于累积误差最小化的更新规则，则得到了累积误差逆传播算法（accumulated error backpropagation），即每次读取全部的数据集一遍，进行一轮学习，从而基于当前的累积误差进行权值调整，因此参数更新的频率相比标准BP算法低了很多，但在很多任务中，尤其是在数据量很大的时候，往往标准BP算法会获得较好的结果。另外对于如何设置隐层神经元个数的问题，至今仍然没有好的解决方案，常使用“试错法”进行调整。</p><p>前面提到，BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：</p><ul><li>早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。</li><li>引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中λ∈（0,1）用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc72ce227ff1.png" srcset="/img/loading.gif" alt="12.png"></p><p>##<strong>5.4 全局最小与局部最小</strong></p><p>模型学习的过程实质上就是一个寻找最优参数的过程，例如BP算法试图通过最速下降来寻找使得累积经验误差最小的权值与阈值，在谈到最优时，一般会提到局部极小（local minimum）和全局最小（global minimum）。</p><pre><code>* 局部极小解：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。* 全局最小解：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。</code></pre><p><img src="https://i.loli.net/2018/10/17/5bc72ce2803dc.png" srcset="/img/loading.gif" alt="13.png"></p><p>要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。因此在现实任务中，通常使用以下策略尽可能地去接近全局最小。</p><pre><code>* 以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。* 使用“模拟退火”技术，这里不做具体介绍。* 使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。</code></pre><p>##<strong>5.5 深度学习</strong></p><p>理论上，参数越多，模型复杂度就越高，容量（capability）就越大，从而能完成更复杂的学习任务。深度学习（deep learning）正是一种极其复杂而强大的模型。</p><p>怎么增大模型复杂度呢？两个办法，一是增加隐层的数目，二是增加隐层神经元的数目。前者更有效一些，因为它不仅增加了功能神经元的数量，还增加了激活函数嵌套的层数。但是对于多隐层神经网络，经典算法如标准BP算法往往会在误差逆传播时发散（diverge），无法收敛达到稳定状态。</p><p>那要怎么有效地训练多隐层神经网络呢？一般来说有以下两种方法：</p><ul><li><p>无监督逐层训练（unsupervised layer-wise training）：每次训练一层隐节点，把上一层隐节点的输出当作输入来训练，本层隐结点训练好后，输出再作为下一层的输入来训练，这称为预训练（pre-training）。全部预训练完成后，再对整个网络进行微调（fine-tuning）训练。一个典型例子就是深度信念网络（deep belief network，简称DBN）。这种做法其实可以视为把大量的参数进行分组，先找出每组较好的设置，再基于这些局部最优的结果来训练全局最优。</p></li><li><p>权共享（weight sharing）：令同一层神经元使用完全相同的连接权，典型的例子是卷积神经网络（Convolutional Neural Network，简称CNN）。这样做可以大大减少需要训练的参数数目。</p></li></ul><p><img src="https://i.loli.net/2018/10/17/5bc72ce28d756.png" srcset="/img/loading.gif" alt="14.png"></p><p>深度学习可以理解为一种特征学习（feature learning）或者表示学习（representation learning），无论是DBN还是CNN，都是通过多个隐层来把与输出目标联系不大的初始输入转化为与输出目标更加密切的表示，使原来只通过单层映射难以完成的任务变为可能。即通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示，从而使得最后可以用简单的模型来完成复杂的学习任务。</p><p>传统任务中，样本的特征需要人类专家来设计，这称为特征工程（feature engineering）。特征好坏对泛化性能有至关重要的影响。而深度学习为全自动数据分析带来了可能，可以自动产生更好的特征。</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(5)--决策树</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法–决策树（Decision Tree）。</p><p>#<strong>4、决策树</strong></p><p>##<strong>4.1 决策树基本概念</strong></p><p>顾名思义，决策树是基于树结构来进行决策的，在网上看到一个例子十分有趣，放在这里正好合适。现想象一位捉急的母亲想要给自己的女娃介绍一个男朋友，于是有了下面的对话：</p><hr><pre><code>  女儿：多大年纪了？  母亲：26。  女儿：长的帅不帅？  母亲：挺帅的。  女儿：收入高不？  母亲：不算很高，中等情况。  女儿：是公务员不？  母亲：是，在税务局上班呢。  女儿：那好，我去见见。</code></pre><hr><p>这个女孩的挑剔过程就是一个典型的决策树，即相当于通过年龄、长相、收入和是否公务员将男童鞋分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么使用下图就能很好地表示女孩的决策逻辑（即一颗决策树）。</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec84a77.png" srcset="/img/loading.gif" alt="1.png"></p><p>在上图的决策树中，决策过程的每一次判定都是对某一属性的“测试”，决策最终结论则对应最终的判定结果。一般一颗决策树包含：一个根节点、若干个内部节点和若干个叶子节点，易知：</p><pre><code>* 每个非叶节点表示一个特征属性测试。* 每个分支代表这个特征属性在某个值域上的输出。* 每个叶子节点存放一个类别。* 每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。</code></pre><p>##<strong>4.2 决策树的构造</strong></p><p>决策树的构造是一个递归的过程，有三种情形会导致递归返回：(1) 当前结点包含的样本全属于同一类别，这时直接将该节点标记为叶节点，并设为相应的类别；(2) 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别；(3) 当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。算法的基本流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ecc27fe.png" srcset="/img/loading.gif" alt="2.png"></p><p>可以看出：决策树学习的关键在于如何选择划分属性，不同的划分属性得出不同的分支结构，从而影响整颗决策树的性能。属性划分的目标是让各个划分出来的子节点尽可能地“纯”，即属于同一类别。因此下面便是介绍量化纯度的具体方法，决策树最常用的算法有三种：ID3，C4.5和CART。</p><p>###<strong>4.2.1 ID3算法</strong></p><p>ID3算法使用信息增益为准则来选择划分属性，“信息熵”(information entropy)是度量样本结合纯度的常用指标，假定当前样本集合D中第k类样本所占比例为pk，则样本集合D的信息熵定义为：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec515a5.png" srcset="/img/loading.gif" alt="3.png"></p><p>假定通过属性划分样本集D，产生了V个分支节点，v表示其中第v个分支节点，易知：分支节点包含的样本数越多，表示该分支节点的影响力越大。故可以计算出划分后相比原始数据集D获得的“信息增益”（information gain）。</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec3e067.png" srcset="/img/loading.gif" alt="4.png"></p><p>信息增益越大，表示使用该属性划分样本集D的效果越好，因此ID3算法在递归过程中，每次选择最大信息增益的属性作为当前的划分属性。</p><p>###<strong>4.2.2 C4.5算法</strong></p><p>ID3算法存在一个问题，就是偏向于取值数目较多的属性，例如：如果存在一个唯一标识，这样样本集D将会被划分为|D|个分支，每个分支只有一个样本，这样划分后的信息熵为零，十分纯净，但是对分类毫无用处。因此C4.5算法使用了“增益率”（gain ratio）来选择划分属性，来避免这个问题带来的困扰。首先使用ID3算法计算出信息增益高于平均水平的候选属性，接着C4.5计算这些候选属性的增益率，增益率定义为：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec69647.png" srcset="/img/loading.gif" alt="5.png"></p><p>###<strong>4.2.3 CART算法</strong></p><p>CART决策树使用“基尼指数”（Gini index）来选择划分属性，基尼指数反映的是从样本集D中随机抽取两个样本，其类别标记不一致的概率，因此Gini(D)越小越好，基尼指数定义如下：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec5a2ff.png" srcset="/img/loading.gif" alt="6.png"></p><p>进而，使用属性α划分后的基尼指数为：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec62eaf.png" srcset="/img/loading.gif" alt="7.png"></p><p>##<strong>4.3 剪枝处理</strong></p><p>从决策树的构造流程中我们可以直观地看出：不管怎么样的训练集，决策树总是能很好地将各个类别分离开来，这时就会遇到之前提到过的问题：过拟合（overfitting），即太依赖于训练样本。剪枝（pruning）则是决策树算法对付过拟合的主要手段，剪枝的策略有两种如下：</p><pre><code>* 预剪枝（prepruning）：在构造的过程中先评估，再考虑是否分支。* 后剪枝（post-pruning）：在构造好一颗完整的决策树后，自底向上，评估分支的必要性。</code></pre><p>评估指的是性能度量，即决策树的泛化性能。之前提到：可以使用测试集作为学习器泛化性能的近似，因此可以将数据集划分为训练集和测试集。预剪枝表示在构造数的过程中，对一个节点考虑是否分支时，首先计算决策树不分支时在测试集上的性能，再计算分支之后的性能，若分支对性能没有提升，则选择不分支（即剪枝）。后剪枝则表示在构造好一颗完整的决策树后，从最下面的节点开始，考虑该节点分支对模型的性能是否有提升，若无则剪枝，即将该节点标记为叶子节点，类别标记为其包含样本最多的类别。</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec80d34.png" srcset="/img/loading.gif" alt="8.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc728ec9e330.png" srcset="/img/loading.gif" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc728ec9d497.png" srcset="/img/loading.gif" alt="10.png"></p><p>上图分别表示不剪枝处理的决策树、预剪枝决策树和后剪枝决策树。预剪枝处理使得决策树的很多分支被剪掉，因此大大降低了训练时间开销，同时降低了过拟合的风险，但另一方面由于剪枝同时剪掉了当前节点后续子节点的分支，因此预剪枝“贪心”的本质阻止了分支的展开，在一定程度上带来了欠拟合的风险。而后剪枝则通常保留了更多的分支，因此采用后剪枝策略的决策树性能往往优于预剪枝，但其自底向上遍历了所有节点，并计算性能，训练时间开销相比预剪枝大大提升。</p><p>##<strong>4.4 连续值与缺失值处理</strong></p><p>对于连续值的属性，若每个取值作为一个分支则显得不可行，因此需要进行离散化处理，常用的方法为二分法，基本思想为：给定样本集D与连续属性α，二分法试图找到一个划分点t将样本集D在属性α上分为≤t与＞t。</p><pre><code>* 首先将α的所有取值按升序排列，所有相邻属性的均值作为候选划分点（n-1个，n为α所有的取值数目）。* 计算每一个划分点划分集合D（即划分为两个分支）后的信息增益。* 选择最大信息增益的划分点作为最优划分点。</code></pre><p><img src="https://i.loli.net/2018/10/17/5bc72a0968fad.png" srcset="/img/loading.gif" alt="11.png"></p><p>现实中常会遇到不完整的样本，即某些属性值缺失。有时若简单采取剔除，则会造成大量的信息浪费，因此在属性值缺失的情况下需要解决两个问题：（1）如何选择划分属性。（2）给定划分属性，若某样本在该属性上缺失值，如何划分到具体的分支上。假定为样本集中的每一个样本都赋予一个权重，根节点中的权重初始化为1，则定义：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a098f3be.png" srcset="/img/loading.gif" alt="12.png"></p><p>对于（1）：通过在样本集D中选取在属性α上没有缺失值的样本子集，计算在该样本子集上的信息增益，最终的信息增益等于该样本子集划分后信息增益乘以样本子集占样本集的比重。即：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a096ccc3.png" srcset="/img/loading.gif" alt="13.png"></p><p>对于（2）：若该样本子集在属性α上的值缺失，则将该样本以不同的权重（即每个分支所含样本比例）划入到所有分支节点中。该样本在分支节点中的权重变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a093ed3c.png" srcset="/img/loading.gif" alt="14.png"></p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(4)--线性模型</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>笔记的前一部分主要是对机器学习预备知识的概括，包括机器学习的定义/术语、学习器性能的评估/度量以及比较，本篇之后将主要对具体的学习算法进行理解总结，本篇则主要是第3章的内容–线性模型。</p><p>#<strong>3、线性模型</strong></p><p>谈及线性模型，其实我们很早就已经与它打过交道，还记得高中数学必修3课本中那个顽皮的“最小二乘法”吗？这就是线性模型的经典算法之一：根据给定的（x，y）点对，求出一条与这些点拟合效果最好的直线y=ax+b，之前我们利用下面的公式便可以计算出拟合直线的系数a,b（3.1中给出了具体的计算过程），从而对于一个新的x，可以预测它所对应的y值。前面我们提到：在机器学习的术语中，当预测值为连续值时，称为“回归问题”，离散值时为“分类问题”。本篇先从线性回归任务开始，接着讨论分类和多分类问题。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b068e48.png" srcset="/img/loading.gif" alt="1.png"></p><p>##<strong>3.1 线性回归</strong></p><p>线性回归问题就是试图学到一个线性模型尽可能准确地预测新样本的输出值，例如：通过历年的人口数据预测2017年人口数量。在这类问题中，往往我们会先得到一系列的有标记数据，例如：2000–&gt;13亿…2016–&gt;15亿，这时输入的属性只有一个，即年份；也有输入多属性的情形，假设我们预测一个人的收入，这时输入的属性值就不止一个了，例如：（学历，年龄，性别，颜值，身高，体重）–&gt;15k。</p><p>有时这些输入的属性值并不能直接被我们的学习模型所用，需要进行相应的处理，对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；对于离散值的属性，可作下面的处理：</p><ul><li><p>若属性值之间存在“序关系”，则可以将其转化为连续值，例如：身高属性分为“高”“中等”“矮”，可转化为数值：{1， 0.5， 0}。</p></li><li><p>若属性值之间不存在“序关系”，则通常将其转化为向量的形式，例如：性别属性分为“男”“女”，可转化为二维向量：{（1，0），（0，1）}。</p></li></ul><p>（1）当输入属性只有一个的时候，就是最简单的情形，也就是我们高中时最熟悉的“最小二乘法”（Euclidean distance），首先计算出每个样本预测值与真实值之间的误差并求和，通过最小化均方误差MSE，使用求偏导等于零的方法计算出拟合直线y=wx+b的两个参数w和b，计算过程如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0ccec4.png" srcset="/img/loading.gif" alt="2.png"></p><p>（2）当输入属性有多个的时候，例如对于一个样本有d个属性{（x1,x2…xd）,y}，则y=wx+b需要写成：</p><p><img src="https://i.loli.net/2018/10/17/5bc72567b8bcd.png" srcset="/img/loading.gif" alt="0.png"></p><p>通常对于多元问题，常常使用矩阵的形式来表示数据。在本问题中，将具有m个样本的数据集表示成矩阵X，将系数w与b合并成一个列向量，这样每个样本的预测值以及所有样本的均方误差最小化就可以写成下面的形式：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0ad8f7.png" srcset="/img/loading.gif" alt="3.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b0af652.png" srcset="/img/loading.gif" alt="4.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b090543.png" srcset="/img/loading.gif" alt="5.png"></p><p>同样地，我们使用最小二乘法对w和b进行估计，令均方误差的求导等于0，需要注意的是，当一个矩阵的行列式不等于0时，我们才可能对其求逆，因此对于下式，我们需要考虑矩阵（X的转置*X）的行列式是否为0，若不为0，则可以求出其解，若为0，则需要使用其它的方法进行计算，书中提到了引入正则化，此处不进行深入。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0cde33.png" srcset="/img/loading.gif" alt="6.png"></p><p>另一方面，有时像上面这种原始的线性回归可能并不能满足需求，例如：y值并不是线性变化，而是在指数尺度上变化。这时我们可以采用线性模型来逼近y的衍生物，例如lny，这时衍生的线性模型如下所示，实际上就是相当于将指数曲线投影在一条直线上，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b103cbf.png" srcset="/img/loading.gif" alt="7.png"></p><p>更一般地，考虑所有y的衍生物的情形，就得到了“广义的线性模型”（generalized linear model），其中，g（*）称为联系函数（link function）。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0a2841.png" srcset="/img/loading.gif" alt="8.png"></p><p>##<strong>3.2 线性几率回归</strong></p><p>回归就是通过输入的属性值得到一个预测值，利用上述广义线性模型的特征，是否可以通过一个联系函数，将预测值转化为离散值从而进行分类呢？线性几率回归正是研究这样的问题。对数几率引入了一个对数几率函数（logistic function）,将预测值投影到0-1之间，从而将线性回归问题转化为二分类问题。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0c7748.png" srcset="/img/loading.gif" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b0a655d.png" srcset="/img/loading.gif" alt="10.png"></p><p>若将y看做样本为正例的概率，（1-y）看做样本为反例的概率，则上式实际上使用线性回归模型的预测结果器逼近真实标记的对数几率。因此这个模型称为“对数几率回归”（logistic regression），也有一些书籍称之为“逻辑回归”。下面使用最大似然估计的方法来计算出w和b两个参数的取值，下面只列出求解的思路，不列出具体的计算过程。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b824f0c.png" srcset="/img/loading.gif" alt="11.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc723b817961.png" srcset="/img/loading.gif" alt="12.png"></p><p>##<strong>3.3 线性判别分析</strong></p><p>线性判别分析（Linear Discriminant Analysis，简称LDA）,其基本思想是：将训练样本投影到一条直线上，使得同类的样例尽可能近，不同类的样例尽可能远。如图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc723b863ebb.png" srcset="/img/loading.gif" alt="13.png">)<img src="https://i.loli.net/2018/10/17/5bc723b85bfa9.png" srcset="/img/loading.gif" alt="14.png"></p><p>想让同类样本点的投影点尽可能接近，不同类样本点投影之间尽可能远，即：让各类的协方差之和尽可能小，不用类之间中心的距离尽可能大。基于这样的考虑，LDA定义了两个散度矩阵。</p><ul><li>类内散度矩阵（within-class scatter matrix）</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b8156e1.png" srcset="/img/loading.gif" alt="15.png"></p><ul><li>类间散度矩阵(between-class scaltter matrix)</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b7e9db3.png" srcset="/img/loading.gif" alt="16.png"></p><p>因此得到了LDA的最大化目标：“广义瑞利商”（generalized Rayleigh quotient）。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b7e8a61.png" srcset="/img/loading.gif" alt="17.png"></p><p>从而分类问题转化为最优化求解w的问题，当求解出w后，对新的样本进行分类时，只需将该样本点投影到这条直线上，根据与各个类别的中心值进行比较，从而判定出新样本与哪个类别距离最近。求解w的方法如下所示，使用的方法为λ乘子。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b83d5e0.png" srcset="/img/loading.gif" alt="18.png"></p><p>若将w看做一个投影矩阵，类似PCA的思想，则LDA可将样本投影到N-1维空间（N为类簇数），投影的过程使用了类别信息（标记信息），因此LDA也常被视为一种经典的监督降维技术。<br>​<br>##<strong>3.4 多分类学习</strong></p><p>现实中我们经常遇到不只两个类别的分类问题，即多分类问题，在这种情形下，我们常常运用“拆分”的策略，通过多个二分类学习器来解决多分类问题，即将多分类问题拆解为多个二分类问题，训练出多个二分类学习器，最后将多个分类结果进行集成得出结论。最为经典的拆分策略有三种：“一对一”（OvO）、“一对其余”（OvR）和“多对多”（MvM），核心思想与示意图如下所示。</p><ul><li><p>OvO：给定数据集D，假定其中有N个真实类别，将这N个类别进行两两配对（一个正类/一个反类），从而产生N（N-1）/2个二分类学习器，在测试阶段，将新样本放入所有的二分类学习器中测试，得出N（N-1）个结果，最终通过投票产生最终的分类结果。</p></li><li><p>OvM：给定数据集D，假定其中有N个真实类别，每次取出一个类作为正类，剩余的所有类别作为一个新的反类，从而产生N个二分类学习器，在测试阶段，得出N个结果，若仅有一个学习器预测为正类，则对应的类标作为最终分类结果。</p></li><li><p>MvM：给定数据集D，假定其中有N个真实类别，每次取若干个类作为正类，若干个类作为反类（通过ECOC码给出，编码），若进行了M次划分，则生成了M个二分类学习器，在测试阶段（解码），得出M个结果组成一个新的码，最终通过计算海明/欧式距离选择距离最小的类别作为最终分类结果。</p></li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b862bfb.png" srcset="/img/loading.gif" alt="19.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc723b8300d5.png" srcset="/img/loading.gif" alt="20.png"></p><p>##<strong>3.5 类别不平衡问题</strong></p><p>类别不平衡（class-imbanlance）就是指分类问题中不同类别的训练样本相差悬殊的情况，例如正例有900个，而反例只有100个，这个时候我们就需要进行相应的处理来平衡这个问题。常见的做法有三种：</p><ol><li>在训练样本较多的类别中进行“欠采样”（undersampling）,比如从正例中采出100个，常见的算法有：EasyEnsemble。</li><li>在训练样本较少的类别中进行“过采样”（oversampling）,例如通过对反例中的数据进行插值，来产生额外的反例，常见的算法有SMOTE。</li><li>直接基于原数据集进行学习，对预测值进行“再缩放”处理。其中再缩放也是代价敏感学习的基础。<img src="https://i.loli.net/2018/10/17/5bc726fe87ae2.png" srcset="/img/loading.gif" alt="21.png"></li></ol><p>​<br>​      </p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(3)--假设检验&amp;方差&amp;偏差</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<p>在上两篇中，我们介绍了多种常见的评估方法和性能度量标准，这样我们就可以根据数据集以及模型任务的特征，选择出最合适的评估和性能度量方法来计算出学习器的“测试误差“。但由于“测试误差”受到很多因素的影响，例如：算法随机性(例如常见的K-Means)或测试集本身的选择，使得同一模型每次得到的结果不尽相同，同时测试误差是作为泛化误差的近似，并不能代表学习器真实的泛化性能，那如何对单个或多个学习器在不同或相同测试集上的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。本篇延续上一篇的内容，主要讨论了比较检验、方差与偏差。</p><p>##<strong>2.6 比较检验</strong></p><p>在比较学习器泛化性能的过程中，统计假设检验（hypothesis test）为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。 为方便论述，本篇中都是以“错误率”作为性能度量的标准。</p><p>###<strong>2.6.1 假设检验</strong></p><p>“假设”指的是对样本总体的分布或已知分布中某个参数值的一种猜想，例如：假设总体服从泊松分布，或假设正态总体的期望u=u0。回到本篇中，我们可以通过测试获得测试错误率，但直观上测试错误率和泛化错误率相差不会太远，因此可以通过测试错误率来推测泛化错误率的分布，这就是一种假设检验。</p><p><img src="https://i.loli.net/2018/10/17/5bc7211aed8e3.png" srcset="/img/loading.gif" alt="1.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc7211a5817d.png" srcset="/img/loading.gif" alt="2.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc7211a336b5.png" srcset="/img/loading.gif" alt="3.png"></p><p>###<strong>2.6.2 交叉验证t检验</strong></p><p><img src="https://i.loli.net/2018/10/17/5bc7211a68ef9.png" srcset="/img/loading.gif" alt="4.png"></p><p>###<strong>2.6.3 McNemar检验</strong></p><p>MaNemar主要用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即e01=e10，且|e01-e10|服从N（1，e01+e10）分布。</p><p><img src="https://i.loli.net/2018/10/17/5bc7211a2c7f9.png" srcset="/img/loading.gif" alt="5.png"></p><p>因此，如下所示的变量服从自由度为1的卡方分布，即服从标准正态分布N（0,1）的随机变量的平方和，下式只有一个变量，故自由度为1，检验的方法同上：做出假设–&gt;求出满足显著度的临界点–&gt;给出拒绝域–&gt;验证假设。</p><p><img src="https://i.loli.net/2018/10/17/5bc7211a34e96.png" srcset="/img/loading.gif" alt="6.png"></p><p>###<strong>2.6.4 Friedman检验与Nemenyi后续检验</strong></p><p>上述的三种检验都只能在一组数据集上，F检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予序值1,2,3…，相同则平分序值，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc7211a2db45.png" srcset="/img/loading.gif" alt="7.png"></p><p>若学习器的性能相同，则它们的平均序值应该相同，且第i个算法的平均序值ri服从正态分布N（（k+1）/2，（k+1）(k-1)/12），则有：</p><p><img src="https://i.loli.net/2018/10/17/5bc7211a45349.png" srcset="/img/loading.gif" alt="8.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc7211a2684c.png" srcset="/img/loading.gif" alt="9.png"></p><p>服从自由度为k-1和(k-1)(N-1)的F分布。下面是F检验常用的临界值：</p><p><img src="https://i.loli.net/2018/10/17/5bc7211a7e3f0.png" srcset="/img/loading.gif" alt="10.png"></p><p>若“H0：所有算法的性能相同”这个假设被拒绝，则需要进行后续检验，来得到具体的算法之间的差异。常用的就是Nemenyi后续检验。Nemenyi检验计算出平均序值差别的临界值域，下表是常用的qa值，若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设。</p><p><img src="https://i.loli.net/2018/10/17/5bc722232932b.png" srcset="/img/loading.gif" alt="11.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc7222348519.png" srcset="/img/loading.gif" alt="12.png"></p><p>##<strong>2.7 偏差与方差</strong></p><p>偏差-方差分解是解释学习器泛化性能的重要工具。在学习算法中，偏差指的是预测的期望值与真实值的偏差，方差则是每一次预测值与预测值得期望之间的差均方。实际上，偏差体现了学习器预测的准确度，而方差体现了学习器预测的稳定性。通过对泛化误差的进行分解，可以得到：</p><ul><li><strong>期望泛化误差=方差+偏差</strong>    </li><li><strong>偏差刻画学习器的拟合能力</strong></li><li><strong>方差体现学习器的稳定性</strong></li></ul><p>易知：方差和偏差具有矛盾性，这就是常说的偏差-方差窘境（bias-variance dilamma），随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差。因此训练也不要贪杯，适度辄止。</p><p><img src="https://i.loli.net/2018/10/17/5bc722234b09f.png" srcset="/img/loading.gif" alt="13.png"></p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(2)--性能度量</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>本篇主要是对第二章剩余知识的理解，包括：性能度量、比较检验和偏差与方差。在上一篇中，我们解决了评估学习器泛化性能的方法，即用测试集的“测试误差”作为“泛化误差”的近似，当我们划分好训练/测试集后，那如何计算“测试误差”呢？这就是性能度量，例如：均方差，错误率等，即“测试误差”的一个评价标准。有了评估方法和性能度量，就可以计算出学习器的“测试误差”，但由于“测试误差”受到很多因素的影响，例如：算法随机性或测试集本身的选择，那如何对两个或多个学习器的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。写到后面发现冗长之后读起来十分没有快感，故本篇主要知识点为性能度量。</p><p><strong>2.5 性能度量</strong></p><p>性能度量（performance measure）是衡量模型泛化能力的评价标准，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。本节除2.5.1外，其它主要介绍分类模型的性能度量。</p><p><strong>2.5.1 最常见的性能度量</strong></p><p>在回归任务中，即预测连续值的问题，最常用的性能度量是“均方误差”（mean squared error）,很多的经典算法都是采用了MSE作为评价函数，想必大家都十分熟悉。</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf76276.png" srcset="/img/loading.gif" alt="1.png"></p><p>在分类任务中，即预测离散值的问题，最常用的是错误率和精度，错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例，易知：错误率+精度=1。</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf4c704.png" srcset="/img/loading.gif" alt="2.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71daf6fb84.png" srcset="/img/loading.gif" alt="3.png"></p><p><strong>2.5.2 查准率/查全率/F1</strong></p><p>错误率和精度虽然常用，但不能满足所有的需求，例如：在推荐系统中，我们只关心推送给用户的内容用户是否感兴趣（即查准率），或者说所有用户感兴趣的内容我们推送出来了多少（即查全率）。因此，使用查准/查全率更适合描述这类问题。对于二分类问题，分类结果混淆矩阵与查准/查全率定义如下：</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf885a4.png" srcset="/img/loading.gif" alt="4.png"></p><p>初次接触时，FN与FP很难正确的理解，按照惯性思维容易把FN理解成：False-&gt;Negtive，即将错的预测为错的，这样FN和TN就反了，后来找到一张图，描述得很详细，为方便理解，把这张图也贴在了下边：</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf871a6.png" srcset="/img/loading.gif" alt="5.png"></p><p>正如天下没有免费的午餐，查准率和查全率是一对矛盾的度量。例如我们想让推送的内容尽可能用户全都感兴趣，那只能推送我们把握高的内容，这样就漏掉了一些用户感兴趣的内容，查全率就低了；如果想让用户感兴趣的内容都被推送，那只有将所有内容都推送上，宁可错杀一千，不可放过一个，这样查准率就很低了。</p><p>“P-R曲线”正是描述查准/查全率变化的曲线，P-R曲线定义如下：根据学习器的预测结果（一般为一个实值或概率）对测试样本进行排序，将最可能是“正例”的样本排在前面，最不可能是“正例”的排在后面，按此顺序逐个把样本作为“正例”进行预测，每次计算出当前的P值和R值，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc71dafc4411.png" srcset="/img/loading.gif" alt="6.png"></p><p>P-R曲线如何评估呢？若一个学习器A的P-R曲线被另一个学习器B的P-R曲线完全包住，则称：B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了“平衡点”（Break-Event Point，简称BEP），即当P=R时的取值，平衡点的取值越高，性能更优。</p><p>P和R指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，即：</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf40ff6.png" srcset="/img/loading.gif" alt="7.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71daf75407.png" srcset="/img/loading.gif" alt="8.png"></p><p>特别地，当β=1时，也就是常见的F1度量，是P和R的调和平均，当F1较高时，模型的性能越好。</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf20885.png" srcset="/img/loading.gif" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71daf4b90a.png" srcset="/img/loading.gif" alt="10.png"></p><p>有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。简单理解，宏观就是先算出每个混淆矩阵的P值和R值，然后取得平均P值macro-P和平均R值macro-R，在算出Fβ或F1，而微观则是计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出Fβ或F1。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed70230e.png" srcset="/img/loading.gif" alt="11.png"></p><p><strong>2.5.3 ROC与AUC</strong></p><p>如上所述：学习器对测试样本的评估结果一般为一个实值或概率，设定一个阈值，大于阈值为正例，小于阈值为负例，因此这个实值的好坏直接决定了学习器的泛化性能，若将这些实值排序，则排序的好坏决定了学习器的性能高低。ROC曲线正是从这个角度出发来研究学习器的泛化性能，ROC曲线与P-R曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是ROC曲线以“真正例率”（True Positive Rate，简称TPR）为横轴，纵轴为“假正例率”（False Positive Rate，简称FPR），ROC偏重研究基于测试样本评估值的排序好坏。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6bee91.png" srcset="/img/loading.gif" alt="12.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71ed75cefe.png" srcset="/img/loading.gif" alt="13.png"></p><p>简单分析图像，可以得知：当FN=0时，TN也必须0，反之也成立，我们可以画一个队列，试着使用不同的截断点（即阈值）去分割队列，来分析曲线的形状，（0,0）表示将所有的样本预测为负例，（1,1）则表示将所有的样本预测为正例，（0,1）表示正例全部出现在负例之前的理想情况，（1,0）则表示负例全部出现在正例之前的最差情况。限于篇幅，这里不再论述。</p><p>现实中的任务通常都是有限个测试样本，因此只能绘制出近似ROC曲线。绘制方法：首先根据测试样本的评估值对测试样本排序，接着按照以下规则进行绘制。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed740a24.png" srcset="/img/loading.gif" alt="14.png"></p><p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。ROC曲线下的面积定义为AUC（Area Uder ROC Curve），不同于P-R的是，这里的AUC是可估算的，即AOC曲线下每一个小矩形的面积之和。易知：AUC越大，证明排序的质量越好，AUC为1时，证明所有正例排在了负例的前面，AUC为0时，所有的负例排在了正例的前面。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6e2c57.png" srcset="/img/loading.gif" alt="15.png"></p><p><strong>2.5.4 代价敏感错误率与代价曲线</strong></p><p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6ed582.png" srcset="/img/loading.gif" alt="16.png"></p><p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”的错误率（2.5.1节介绍）为：</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed70bebe.png" srcset="/img/loading.gif" alt="17.png"></p><p>同样对于ROC曲线，在非均等错误代价下，演变成了“代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6e952e.png" srcset="/img/loading.gif" alt="18.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6eee7b.png" srcset="/img/loading.gif" alt="19.png"></p><p>代价曲线的绘制很简单：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC 曲线土的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed716e0d.png" srcset="/img/loading.gif" alt="20.png"></p><p>在此模型的性能度量方法就介绍完了，以前一直以为均方误差和精准度就可以了，现在才发现天空如此广阔~</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(1)--绪论</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)--%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)--%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>机器学习是目前信息技术中最激动人心的方向之一，其应用已经深入到生活的各个层面且与普通人的日常生活密切相关。本文为清华大学最新出版的《机器学习》教材的Learning Notes，书作者是南京大学周志华教授，多个大陆首位彰显其学术奢华。本篇主要介绍了该教材前两个章节的知识点以及自己一点浅陋的理解。</p><p><strong>1  绪论</strong></p><p>傍晚小街路面上沁出微雨后的湿润，和熙的细风吹来，抬头看看天边的晚霞，嗯，明天又是一个好天气。走到水果摊旁，挑了个根蒂蜷缩、敲起来声音浊响的青绿西瓜，一边满心期待着皮薄肉厚瓢甜的爽落感，一边愉快地想着，这学期狠下了工夫，基础概念弄得清清楚楚，算法作业也是信手拈来，这门课成绩一定差不了！哈哈，也希望自己这学期的machine learning课程取得一个好成绩！</p><p><strong>1.1 机器学习的定义</strong></p><p>正如我们根据过去的经验来判断明天的天气，吃货们希望从购买经验中挑选一个好瓜，那能不能让计算机帮助人类来实现这个呢？机器学习正是这样的一门学科，人的“经验”对应计算机中的“数据”，让计算机来学习这些经验数据，生成一个算法模型，在面对新的情况中，计算机便能作出有效的判断，这便是机器学习。</p><p>另一本经典教材的作者Mitchell给出了一个形式化的定义，假设：</p><ul><li>P：计算机程序在某任务类T上的性能。</li><li>T：计算机程序希望实现的任务类。</li><li>E：表示经验，即历史的数据集。</li></ul><p>若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。</p><p><strong>1.2 机器学习的一些基本术语</strong></p><p>假设我们收集了一批西瓜的数据，例如：（色泽=青绿;根蒂=蜷缩;敲声=浊响)， (色泽=乌黑;根蒂=稍蜷;敲声=沉闷)， (色泽=浅自;根蒂=硬挺;敲声=清脆)……每对括号内是一个西瓜的记录，定义：     </p><ul><li><p>所有记录的集合为：数据集。</p></li><li><p>每一条记录为：一个实例（instance）或样本（sample）。</p></li><li><p>例如：色泽或敲声，单个的特点为特征（feature）或属性（attribute）。</p></li><li><p>对于一条记录，如果在坐标轴上表示，每个西瓜都可以用坐标轴中的一个点表示，一个点也是一个向量，例如（青绿，蜷缩，浊响），即每个西瓜为：一个特征向量（feature vector）。</p></li><li><p>一个样本的特征数为：维数（dimensionality），该西瓜的例子维数为3，当维数非常大时，也就是现在说的“维数灾难”。</p><p> 计算机程序学习经验数据生成算法模型的过程中，每一条记录称为一个“训练样本”，同时在训练好模型后，我们希望使用新的样本来测试模型的效果，则每一个新的样本称为一个“测试样本”。定义：    </p></li><li><p>所有训练样本的集合为：训练集（trainning set），[特殊]。</p></li><li><p>所有测试样本的集合为：测试集（test set），[一般]。  </p></li><li><p>机器学习出来的模型适用于新样本的能力为：泛化能力（generalization），即从特殊到一般。</p><p> 西瓜的例子中，我们是想计算机通过学习西瓜的特征数据，训练出一个决策模型，来判断一个新的西瓜是否是好瓜。可以得知我们预测的是：西瓜是好是坏，即好瓜与差瓜两种，是离散值。同样地，也有通过历年的人口数据，来预测未来的人口数量，人口数量则是连续值。定义：    </p></li><li><p>预测值为离散值的问题为：分类（classification）。</p></li><li><p>预测值为连续值的问题为：回归（regression）。</p><p> 我们预测西瓜是否是好瓜的过程中，很明显对于训练集中的西瓜，我们事先已经知道了该瓜是否是好瓜，学习器通过学习这些好瓜或差瓜的特征，从而总结出规律，即训练集中的西瓜我们都做了标记，称为标记信息。但也有没有标记信息的情形，例如：我们想将一堆西瓜根据特征分成两个小堆，使得某一堆的西瓜尽可能相似，即都是好瓜或差瓜，对于这种问题，我们事先并不知道西瓜的好坏，样本没有标记信息。定义：    </p></li><li><p>训练数据有标记信息的学习任务为：监督学习（supervised learning），容易知道上面所描述的分类和回归都是监督学习的范畴。</p></li><li><p>训练数据没有标记信息的学习任务为：无监督学习（unsupervised learning），常见的有聚类和关联规则。</p></li></ul><p><strong>2  模型的评估与选择</strong></p><p><strong>2.1 误差与过拟合</strong></p><p>我们将学习器对样本的实际预测结果与样本的真实值之间的差异成为：误差（error）。定义：    </p><ul><li>在训练集上的误差称为训练误差（training error）或经验误差（empirical error）。</li><li>在测试集上的误差称为测试误差（test error）。</li><li>学习器在所有新样本上的误差称为泛化误差（generalization error）。</li></ul><p>显然，我们希望得到的是在新样本上表现得很好的学习器，即泛化误差小的学习器。因此，我们应该让学习器尽可能地从训练集中学出普适性的“一般特征”，这样在遇到新样本时才能做出正确的判别。然而，当学习器把训练集学得“太好”的时候，即把一些训练样本的自身特点当做了普遍特征；同时也有学习能力不足的情况，即训练集的基本特征都没有学习出来。我们定义：</p><ul><li>学习能力过强，以至于把训练样本所包含的不太一般的特性都学到了，称为：过拟合（overfitting）。</li><li>学习能太差，训练样本的一般性质尚未学好，称为：欠拟合（underfitting）。</li></ul><p>可以得知：在过拟合问题中，训练误差十分小，但测试误差教大；在欠拟合问题中，训练误差和测试误差都比较大。目前，欠拟合问题比较容易克服，例如增加迭代次数等，但过拟合问题还没有十分好的解决方案，过拟合是机器学习面临的关键障碍。</p><p><img src="https://i.loli.net/2018/10/17/5bc7181172996.png" srcset="/img/loading.gif" alt=""></p><p><strong>2.2 评估方法</strong></p><p>在现实任务中，我们往往有多种算法可供选择，那么我们应该选择哪一个算法才是最适合的呢？如上所述，我们希望得到的是泛化误差小的学习器，理想的解决方案是对模型的泛化误差进行评估，然后选择泛化误差最小的那个学习器。但是，泛化误差指的是模型在所有新样本上的适用能力，我们无法直接获得泛化误差。</p><p>因此，通常我们采用一个“测试集”来测试学习器对新样本的判别能力，然后以“测试集”上的“测试误差”作为“泛化误差”的近似。显然：我们选取的测试集应尽可能与训练集互斥，下面用一个小故事来解释why：</p><p>假设老师出了10 道习题供同学们练习，考试时老师又用同样的这10道题作为试题，可能有的童鞋只会做这10 道题却能得高分，很明显：这个考试成绩并不能有效地反映出真实水平。回到我们的问题上来，我们希望得到泛化性能好的模型，好比希望同学们课程学得好并获得了对所学知识”举一反三”的能力；训练样本相当于给同学们练习的习题，测试过程则相当于考试。显然，若测试样本被用作训练了，则得到的将是过于”乐观”的估计结果。</p><p><strong>2.3 训练集与测试集的划分方法</strong></p><p>如上所述：我们希望用一个“测试集”的“测试误差”来作为“泛化误差”的近似，因此我们需要对初始数据集进行有效划分，划分出互斥的“训练集”和“测试集”。下面介绍几种常用的划分方法：</p><p><strong>2.3.1 留出法</strong></p><p>将数据集D划分为两个互斥的集合，一个作为训练集S，一个作为测试集T，满足D=S∪T且S∩T=∅，常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。需要注意的是：训练/测试集的划分要尽可能保持数据分布的一致性，以避免由于分布的差异引入额外的偏差，常见的做法是采取分层抽样。同时，由于划分的随机性，单次的留出法结果往往不够稳定，一般要采用若干次随机划分，重复实验取平均值的做法。</p><p><strong>2.3.2 交叉验证法</strong></p><p>将数据集D划分为k个大小相同的互斥子集，满足D=D1∪D2∪…∪Dk，Di∩Dj=∅（i≠j），同样地尽可能保持数据分布的一致性，即采用分层抽样的方法获得这些子集。交叉验证法的思想是：每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就有K种训练集/测试集划分的情况，从而可进行k次训练和测试，最终返回k次测试结果的均值。交叉验证法也称“k折交叉验证”，k最常用的取值是10，下图给出了10折交叉验证的示意图。</p><p><img src="https://i.loli.net/2018/10/17/5bc718115d224.png" srcset="/img/loading.gif" alt=""></p><p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p><p><strong>2.3.3 自助法</strong></p><p>我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。“自助法”正是解决了这样的问题。</p><p>自助法的基本思想是：给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。可以得知在m次采样中，样本始终不被采到的概率取极限为：</p><p><img src="https://i.loli.net/2018/10/17/5bc71811246dd.png" srcset="/img/loading.gif" alt=""></p><p>这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。自助法在数据集较小，难以有效划分训练集/测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。</p><p><strong>2.4 调参</strong></p><p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p><p>学习算法的很多参数是在实数范围内取值，因此，对每种参数取值都训练出模型来是不可行的。常用的做法是：对每个参数选定一个范围和步长λ，这样使得学习的过程变得可行。例如：假定算法有3 个参数，每个参数仅考虑5 个候选值，这样对每一组训练/测试集就有5<em>5</em>5= 125 个模型需考察，由此可见：拿下一个参数（即经验值）对于算法人员来说是有多么的happy。</p><p>最后需要注意的是：当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。用上面考试的例子来比喻：就像高中时大家每次考试完，要将考卷的题目消化掉（大多数题目都还是之前没有见过的吧？），这样即使考差了也能开心的玩耍了~。</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(17)--强化学习</title>
    <link href="/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/02/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了概率图模型，首先从生成式模型与判别式模型的定义出发，引出了概率图模型的基本概念，即利用图结构来表达变量之间的依赖关系；接着分别介绍了隐马尔可夫模型、马尔可夫随机场、条件随机场、精确推断方法以及LDA话题模型：HMM主要围绕着评估/解码/学习这三个实际问题展开论述；MRF基于团和势函数的概念来定义联合概率分布；CRF引入两种特征函数对状态序列进行评价打分；变量消去与信念传播在给定联合概率分布后计算特定变量的边际分布；LDA话题模型则试图去推断给定文档所蕴含的话题分布。本篇将介绍最后一种学习算法–强化学习。</p><p>#<strong>16、强化学习</strong></p><p><strong>强化学习</strong>（Reinforcement Learning，简称<strong>RL</strong>）是机器学习的一个重要分支，前段时间人机大战的主角AlphaGo正是以强化学习为核心技术。在强化学习中，包含两种基本的元素：<strong>状态</strong>与<strong>动作</strong>，<strong>在某个状态下执行某种动作，这便是一种策略</strong>，学习器要做的就是通过不断地探索学习，从而获得一个好的策略。例如：在围棋中，一种落棋的局面就是一种状态，若能知道每种局面下的最优落子动作，那就攻无不克/百战不殆了~</p><p>若将状态看作为属性，动作看作为标记，易知：<strong>监督学习和强化学习都是在试图寻找一个映射，从已知属性/状态推断出标记/动作</strong>，这样强化学习中的策略相当于监督学习中的分类/回归器。但在实际问题中，<strong>强化学习并没有监督学习那样的标记信息</strong>，通常都是在<strong>尝试动作后才能获得结果</strong>，因此强化学习是通过反馈的结果信息不断调整之前的策略，从而算法能够学习到：在什么样的状态下选择什么样的动作可以获得最好的结果。</p><p>##<strong>16.1 基本要素</strong></p><p>强化学习任务通常使用<strong>马尔可夫决策过程</strong>（Markov Decision Process，简称<strong>MDP</strong>）来描述，具体而言：机器处在一个环境中，每个状态为机器对当前环境的感知；机器只能通过动作来影响环境，当机器执行一个动作后，会使得环境按某种概率转移到另一个状态；同时，环境会根据潜在的奖赏函数反馈给机器一个奖赏。综合而言，强化学习主要包含四个要素：状态、动作、转移概率以及奖赏函数。</p><blockquote><p><strong>状态（X）</strong>：机器对环境的感知，所有可能的状态称为状态空间；<br><strong>动作（A）</strong>：机器所采取的动作，所有能采取的动作构成动作空间；<br><strong>转移概率（P）</strong>：当执行某个动作后，当前状态会以某种概率转移到另一个状态；<br><strong>奖赏函数（R）</strong>：在状态转移的同时，环境给反馈给机器一个奖赏。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwYOud.png" srcset="/img/loading.gif" alt="iwYOud.png"></p><p>因此，<strong>强化学习的主要任务就是通过在环境中不断地尝试，根据尝试获得的反馈信息调整策略，最终生成一个较好的策略π，机器根据这个策略便能知道在什么状态下应该执行什么动作</strong>。常见的策略表示方法有以下两种：</p><blockquote><p><strong>确定性策略</strong>：π（x）=a，即在状态x下执行a动作；<br><strong>随机性策略</strong>：P=π（x,a），即在状态x下执行a动作的概率。</p></blockquote><p><strong>一个策略的优劣取决于长期执行这一策略后的累积奖赏</strong>，换句话说：可以使用累积奖赏来评估策略的好坏，最优策略则表示在初始状态下一直执行该策略后，最后的累积奖赏值最高。长期累积奖赏通常使用下述两种计算方法：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYH3D.png" srcset="/img/loading.gif" alt="iwYH3D.png"></p><p>##<strong>16.2 K摇摆赌博机</strong></p><p>首先我们考虑强化学习最简单的情形：仅考虑一步操作，即在状态x下只需执行一次动作a便能观察到奖赏结果。易知：欲最大化单步奖赏，我们需要知道每个动作带来的期望奖赏值，这样便能选择奖赏值最大的动作来执行。若每个动作的奖赏值为确定值，则只需要将每个动作尝试一遍即可，但大多数情形下，一个动作的奖赏值来源于一个概率分布，因此需要进行多次的尝试。</p><p>单步强化学习实质上是<strong>K-摇臂赌博机</strong>（K-armed bandit）的原型，一般我们<strong>尝试动作的次数是有限的</strong>，那如何利用有限的次数进行有效地探索呢？这里有两种基本的想法：</p><blockquote><p><strong>仅探索法</strong>：将尝试的机会平均分给每一个动作，即轮流执行，最终将每个动作的平均奖赏作为期望奖赏的近似值。<br><strong>仅利用法</strong>：将尝试的机会分给当前平均奖赏值最大的动作，隐含着让一部分人先富起来的思想。</p></blockquote><p>可以看出：上述<strong>两种方法是相互矛盾的</strong>，仅探索法能较好地估算每个动作的期望奖赏，但是没能根据当前的反馈结果调整尝试策略；仅利用法在每次尝试之后都更新尝试策略，符合强化学习的思（tao）维（lu），但容易找不到最优动作。因此需要在这两者之间进行折中。</p><p>###<strong>16.2.1 ε-贪心</strong></p><p><strong>ε-贪心法基于一个概率来对探索和利用进行折中</strong>，具体而言：在每次尝试时，以ε的概率进行探索，即以均匀概率随机选择一个动作；以1-ε的概率进行利用，即选择当前最优的动作。ε-贪心法只需记录每个动作的当前平均奖赏值与被选中的次数，便可以增量式更新。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYzUP.png" srcset="/img/loading.gif" alt="iwYzUP.png"></p><p>###<strong>16.2.2 Softmax</strong></p><p><strong>Softmax算法则基于当前每个动作的平均奖赏值来对探索和利用进行折中，Softmax函数将一组值转化为一组概率</strong>，值越大对应的概率也越高，因此当前平均奖赏值越高的动作被选中的几率也越大。Softmax函数如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYbge.png" srcset="/img/loading.gif" alt="iwYbge.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYqjH.png" srcset="/img/loading.gif" alt="iwYqjH.png"></p><p>##<strong>16.3 有模型学习</strong></p><p>若学习任务中的四个要素都已知，即状态空间、动作空间、转移概率以及奖赏函数都已经给出，这样的情形称为“<strong>有模型学习</strong>”。假设状态空间和动作空间均为有限，即均为离散值，这样我们不用通过尝试便可以对某个策略进行评估。</p><p>###<strong>16.3.1 策略评估</strong></p><p>前面提到：<strong>在模型已知的前提下，我们可以对任意策略的进行评估</strong>（后续会给出演算过程）。一般常使用以下两种值函数来评估某个策略的优劣：</p><blockquote><p><strong>状态值函数（V）</strong>：V（x），即从状态x出发，使用π策略所带来的累积奖赏；<br><strong>状态-动作值函数（Q）</strong>：Q（x,a），即从状态x出发，执行动作a后再使用π策略所带来的累积奖赏。</p></blockquote><p>根据累积奖赏的定义，我们可以引入T步累积奖赏与r折扣累积奖赏：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYjHI.png" srcset="/img/loading.gif" alt="iwYjHI.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYXDA.png" srcset="/img/loading.gif" alt="iwYXDA.png"></p><p>由于MDP具有马尔可夫性，即现在决定未来，将来和过去无关，我们很容易找到值函数的递归关系：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtS4f.png" srcset="/img/loading.gif" alt="iwtS4f.png"></p><p>类似地，对于r折扣累积奖赏可以得到：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYxEt.png" srcset="/img/loading.gif" alt="iwYxEt.png"></p><p>易知：<strong>当模型已知时，策略的评估问题转化为一种动态规划问题</strong>，即以填表格的形式自底向上，先求解每个状态的单步累积奖赏，再求解每个状态的两步累积奖赏，一直迭代逐步求解出每个状态的T步累积奖赏。算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwt9C8.png" srcset="/img/loading.gif" alt="iwt9C8.png"></p><p>对于状态-动作值函数，只需通过简单的转化便可得到：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwt3r9.png" srcset="/img/loading.gif" alt="iwt3r9.png"></p><p>###<strong>16.3.2 策略改进</strong></p><p>理想的策略应能使得每个状态的累积奖赏之和最大，简单来理解就是：不管处于什么状态，只要通过该策略执行动作，总能得到较好的结果。因此对于给定的某个策略，我们需要对其进行改进，从而得到<strong>最优的值函数</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtm5V.png" srcset="/img/loading.gif" alt="iwtm5V.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwtZEq.png" srcset="/img/loading.gif" alt="iwtZEq.png"></p><p>最优Bellman等式改进策略的方式为：<strong>将策略选择的动作改为当前最优的动作</strong>，而不是像之前那样对每种可能的动作进行求和。易知：选择当前最优动作相当于将所有的概率都赋给累积奖赏值最大的动作，因此每次改进都会使得值函数单调递增。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtEbn.png" srcset="/img/loading.gif" alt="iwtEbn.png"></p><p>将策略评估与策略改进结合起来，我们便得到了生成最优策略的方法：先给定一个随机策略，现对该策略进行评估，然后再改进，接着再评估/改进一直到策略收敛、不再发生改变。这便是策略迭代算法，算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwteU0.png" srcset="/img/loading.gif" alt="iwteU0.png"></p><p>可以看出：策略迭代法在每次改进策略后都要对策略进行重新评估，因此比较耗时。若从最优化值函数的角度出发，即先迭代得到最优的值函数，再来计算如何改变策略，这便是值迭代算法，算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtuCT.png" srcset="/img/loading.gif" alt="iwtuCT.png"></p><p>##<strong>16.4 蒙特卡罗强化学习</strong></p><p>在现实的强化学习任务中，<strong>环境的转移函数与奖赏函数往往很难得知</strong>，因此我们需要考虑在不依赖于环境参数的条件下建立强化学习模型，这便是<strong>免模型学习</strong>。蒙特卡罗强化学习便是其中的一种经典方法。</p><p>由于模型参数未知，状态值函数不能像之前那样进行全概率展开，从而运用动态规划法求解。一种直接的方法便是通过采样来对策略进行评估/估算其值函数，<strong>蒙特卡罗强化学习正是基于采样来估计状态-动作值函数</strong>：对采样轨迹中的每一对状态-动作，记录其后的奖赏值之和，作为该状态-动作的一次累积奖赏，通过多次采样后，使用累积奖赏的平均作为状态-动作值的估计，并<strong>引入ε-贪心策略保证采样的多样性</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwt1KJ.png" srcset="/img/loading.gif" alt="iwt1KJ.png"></p><p>在上面的算法流程中，被评估和被改进的都是同一个策略，因此称为<strong>同策略蒙特卡罗强化学习算法</strong>。引入ε-贪心仅是为了便于采样评估，而在使用策略时并不需要ε-贪心，那能否仅在评估时使用ε-贪心策略，而在改进时使用原始策略呢？这便是<strong>异策略蒙特卡罗强化学习算法</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtK8U.png" srcset="/img/loading.gif" alt="iwtK8U.png"></p><p>##<strong>16.5 AlphaGo原理浅析</strong></p><p>本篇一开始便提到强化学习是AlphaGo的核心技术之一，刚好借着这个东风将AlphaGo的工作原理了解一番。正如人类下棋那般“<strong>手下一步棋，心想三步棋</strong>”，Alphago也正是这个思想，<strong>当处于一个状态时，机器会暗地里进行多次的尝试/采样，并基于反馈回来的结果信息改进估值函数，从而最终通过增强版的估值函数来选择最优的落子动作。</strong></p><p>其中便涉及到了三个主要的问题：<strong>（1）如何确定估值函数（2）如何进行采样（3）如何基于反馈信息改进估值函数</strong>，这正对应着AlphaGo的三大核心模块：<strong>深度学习</strong>、<strong>蒙特卡罗搜索树</strong>、<strong>强化学习</strong>。</p><blockquote><p><strong>1.深度学习（拟合估值函数）</strong></p></blockquote><p>由于围棋的状态空间巨大，像蒙特卡罗强化学习那样通过采样来确定值函数就行不通了。在围棋中，<strong>状态值函数可以看作为一种局面函数，状态-动作值函数可以看作一种策略函数</strong>，若我们能获得这两个估值函数，便可以根据这两个函数来完成：(1)衡量当前局面的价值；(2)选择当前最优的动作。那如何精确地估计这两个估值函数呢？<strong>这就用到了深度学习，通过大量的对弈数据自动学习出特征，从而拟合出估值函数。</strong></p><blockquote><p><strong>2.蒙特卡罗搜索树（采样）</strong></p></blockquote><p>蒙特卡罗树是一种经典的搜索框架，它通过反复地采样模拟对局来探索状态空间。具体表现在：从当前状态开始，利用策略函数尽可能选择当前最优的动作，同时也引入随机性来减小估值错误带来的负面影响，从而模拟棋局运行，使得棋盘达到终局或一定步数后停止。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtM2F.png" srcset="/img/loading.gif" alt="iwtM2F.png"></p><blockquote><p><strong>3.强化学习（调整估值函数）</strong></p></blockquote><p>在使用蒙特卡罗搜索树进行多次采样后，每次采样都会反馈后续的局面信息（利用局面函数进行评价），根据反馈回来的结果信息自动调整两个估值函数的参数，这便是强化学习的核心思想，最后基于改进后的策略函数选择出当前最优的落子动作。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtQv4.png" srcset="/img/loading.gif" alt="iwtQv4.png"></p><p>在此，强化学习就介绍完毕。同时也意味着大口小口地啃完了这个西瓜，十分记得去年双11之后立下这个Flag，现在回想起来，大半年的时间里在嚼瓜上还是花费了不少功夫。有人说：当你阐述的能让别人看懂才算是真的理解，有人说：在写的过程中能发现那些只看书发现不了的东西，自己最初的想法十分简单：当健忘症发作的时候，如果能看到之前按照自己思路写下的文字，回忆便会汹涌澎湃一些~</p><p>最后，感谢自己这大半年以来的坚持~Get busy living, or get busy dying!</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tarjan算法</title>
    <link href="/2020/04/26/Tarjan%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/26/Tarjan%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><p><img src="https://img-blog.csdnimg.cn/20200426155322525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10010;int dfn[MAXN],low[MAXN],Stack[MAXN];vector&lt;int&gt; graph[MAXN];//遍历深度以及栈顶指针(指向最后一个元素)int deep=0,top=-1;//标记元素是否在栈中int tag[MAXN];//强连通分量个数int cnt=0;//为不同的强连通分量上色区分int color[MAXN];void tarjan(int u){    dfn[u]=low[u]=++deep;    Stack[++top]=u;    tag[u]=1;    for(int i=0;i&lt;graph[u].size();i++){        int v=graph[u][i];        //if(v==fa) continue;统计强连通分量个数不需要这个        if(dfn[v]==0){            tarjan(v);            low[u]=min(low[u],low[v]);        }        //在栈中才进行更新        else if(tag[v]==1){            low[u]=min(low[u],dfn[v]);        }    }    //cout&lt;&lt;u&lt;&lt;&quot;:&quot;&lt;&lt;dfn[u]&lt;&lt;&quot; &quot;&lt;&lt;low[u]&lt;&lt;endl;    //已经出现了一个强连通分量    if(dfn[u]==low[u]){        cnt++;        //将同一个连通分量中的结点全部出栈        while(tag[u]==1){            tag[Stack[top]]=0;//置标记            color[Stack[top]]=cnt;            top--;        }    }}int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    memset(dfn,0,sizeof(dfn));    memset(tag,0,sizeof(tag));    fill(low,low+n+1,INT_MAX);    for(int i=0;i&lt;m;i++){        int from,to;        cin&gt;&gt;from&gt;&gt;to;        graph[from].push_back(to);    }    tarjan(1);    cout&lt;&lt;cnt&lt;&lt;endl;    for(int i=1;i&lt;=n;i++){        cout&lt;&lt;i&lt;&lt;&quot; color &quot;&lt;&lt;color[i]&lt;&lt;endl;    }}//测试用例/*6 81 21 32 43 43 54 14 65 6*/*/</code></pre><h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><p><img src="https://img-blog.csdnimg.cn/20200425214222817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>思路一：依次删除每个割点，然后DFS<br>思路二：Tarjan算法</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10010;int deep=0,child=0,root=1,cnt=0;vector&lt;int&gt; graph[MAXN];int dfn[MAXN],low[MAXN],tag[MAXN];vector&lt;int&gt; ans;/*访问过  当前是根结点  当前不是根结点 且 通过儿子能访问到更早访问过的结点没访问过且此边不指向父亲节点*///low找到更早的结点一定是不能违背dfs的遍历顺序的//比如你已经访问过的一条边肯定是不能逆向访问的//fa为当前结点的父节点void tarjan(int u,int fa){    dfn[u]=low[u]=++deep;    for(int i=0;i&lt;graph[u].size();i++){        int v=graph[u][i];        if(v==fa) continue;        if(dfn[v]==0){//没有遍历过            tarjan(v,u);            low[u]=min(low[u],low[v]);//转换1            //对于根结点是否为割点的判定，记录子树个数            if(u==root) child++;            //其他结点u若符合该条件，u就是割点            //这里改为low[v]&gt;dfn[u] ,则(u,v)是一条割边            else if(dfn[u]&lt;=low[v]){//理解:不能访问到比自己更先遍历的结点,等于则是刚好成环的那种情况                tag[u]=1;            }        }        else if{//遍历过且不是指向父亲            low[u]=min(low[u],dfn[v]);        }    }}int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    memset(dfn,0,sizeof(dfn));    fill(low,low+n,INT_MAX);    memset(tag,0,sizeof(tag));    for(int i=0;i&lt;m;i++){        int from,to;        cin&gt;&gt;from&gt;&gt;to;        graph[from].push_back(to);        graph[to].push_back(from);    }    tarjan(root,0);    if(child&gt;=2) tag[root]=1;    for(int i=0;i&lt;n;i++){        if(tag[i]){            cnt++; ans.push_back(i);        }    }    cout&lt;&lt;cnt&lt;&lt;endl;    for(int i=0;i&lt;ans.size();i++){        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>Tarjan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2020/04/25/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/25/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int nextval[1000];//这里面所有的i和j都是序号void get_nextval(string T){    //j表示前缀的结尾，i表示后缀的结尾    int i=1,j=0;    nextval[1]=0;    while(i&lt;T.size()){        if(j==0||T[i]==T[j]){            i++; j++;            //两个字符相同则跳过,这里进行了改进            //优化点，防止T串为aaaab这种类型，需要一个一个往前翻，利用下面两行，可以直接找到最初等价位置            if(T[i]==T[j]) nextval[i]=nextval[j];            else nextval[i]=j;//T[i]!=T[j]        }        else{            j=nextval[j];        }    }}int Index_KMP(string S,string T){    //i是指向主串的指针，j是模式串的指针    int i=1,j=1;    while(i&lt;=S.size()&amp;&amp;j&lt;=T.size()){        if(j==0||S[i]==T[j]){//持续比较后继字符            i++; j++;        }        else{            j=nextval[j];//模式串向右移动        }    }    //如果j指针已经超出了模式串的末尾，则返回匹配成功的起始点    if(j&gt;T.size()) return i-T.size();    else return 0;}int main(){    string S,T;    cin&gt;&gt;S&gt;&gt;T;    get_nextval(T);    cout&lt;&lt;Index_KMP(S,T)&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题最终总结</title>
    <link href="/2020/04/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>常见的背包问题有<br>1、组合问题：   dp[i] += dp[i-num]<br>2、True、False问题：dp[i] = dp[i] or dp[i-num]<br>3、最大最小问题：dp[i] = min(dp[i], dp[i-num]+1)<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;dp[i] = max(dp[i], dp[i-num]+1)</p><p><font color=red><strong>注意dp的初始化!!!</strong></font></p><h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><h2 id="1-采药问题"><a href="#1-采药问题" class="headerlink" title="1.采药问题"></a>1.采药问题</h2><p><strong>题目描述</strong><br>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><p><strong>输入格式</strong><br>第一行有2个整数T(1≤T≤1000)和M(1≤M≤100)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。<br>接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><p><strong>输出格式</strong><br>1个整数，表示在规定的时间内可以采到的草药的最大总价值。</p><p>输入输出样例<br><strong>输入</strong></p><blockquote><p>70 3<br>71 100<br>69 1<br>1 2</p></blockquote><p><strong>输出</strong> </p><blockquote><p>3</p></blockquote><p><strong>分析</strong><br>普通的0-1背包，求最大的收益</p><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000;int w[MAXN],v[MAXN];int dp[MAXN];int main(){    int n,m;//容量为n,物品有m个    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=1;i&lt;=m;i++){//上到下,关于第i个物品选与不选        for(int j=n;j&gt;=w[i];j--){//右到左，关于选与不选对应的收益            dp[j]=max(dp[j-w[i]]+v[i],dp[j]);        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="2-装箱问题"><a href="#2-装箱问题" class="headerlink" title="2.装箱问题"></a>2.装箱问题</h2><p><strong>题目描述</strong><br>有一个箱子容量为V（200000≤V≤20000），同时有n个物品（300&lt;n≤30），每个物品有一个体积（正整数）。<br>要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p><p><strong>输入格式</strong><br>1个整数，表示箱子容量<br>1个整数，表示有n个物品<br>接下来n行，分别表示这n个物品的各自体积</p><p><strong>输出格式</strong><br>1个整数，表示箱子剩余空间。</p><p><strong>输入</strong></p><blockquote><p>24 6<br>8<br>3<br>12<br>7<br>9<br>7</p></blockquote><p><strong>输出</strong> </p><blockquote><p>0</p></blockquote><p><strong>分析</strong><br>注意分析什么是模板中的变量的转换，比如什么是背包容量，什么是价值，什么是重量，这道题转化为求装入若干个物品使其体积和最大</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=50;int w[MAXN],v[MAXN];int dp[30005];int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;w[i];        v[i]=w[i];//这个题的物品重量等同于价值    }    for(int i=1;i&lt;=m;i++){        for(int j=n;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;n-dp[n]&lt;&lt;endl;}</code></pre><h2 id="3-最大约数和"><a href="#3-最大约数和" class="headerlink" title="3.最大约数和"></a>3.最大约数和</h2><p><strong>题目描述</strong><br>选取和不超过S的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。</p><p><strong>输入格式</strong><br>输入一个正整数S。</p><p><strong>输出格式</strong><br>输出最大的约数之和。</p><p>输入</p><blockquote><p>11</p></blockquote><p>输出</p><blockquote><p>9</p></blockquote><p><strong>说明/提示</strong><br>取数字4和6，可以得到最大值(1+2)+(1+2+3)=9。</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=2000;int v[MAXN];int dp[10000];int main(){    int n,m;    cin&gt;&gt;m;    n=m;    for(int i=1;i&lt;=m;i++){        for(int j=1;j&lt;i;j++){            if(i%j==0) v[i]+=j;        }        //cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;v[i]&lt;&lt;endl;    }    for(int i=1;i&lt;=m;i++){        for(int j=n;j&gt;=i;j--){            dp[j]=max(dp[j],dp[j-i]+v[i]);//数字本身为重量,数字的约数之和为价值        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="4-精卫填海"><a href="#4-精卫填海" class="headerlink" title="4.精卫填海"></a>4.精卫填海</h2><p><strong>题目描述</strong><br>发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》<br>精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？<br>事实上，东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。</p><p><strong>输入格式</strong><br>输入文件的第一行是三个整数：v、n、c。<br>从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。</p><p><strong>输出格式</strong><br>输出文件只有一行，如果精卫能把东海填平，则输出她把东海填平后剩下的最大的体力，否则输出’Impossible’（不带引号）。</p><p><strong>输入</strong></p><blockquote><p>100 2 10<br>50 5<br>50 5</p></blockquote><p><strong>输出</strong></p><blockquote><p>0</p></blockquote><p><strong>输入</strong></p><blockquote><p>10 2 1<br>50 5<br>10 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>Impossible</p></blockquote><p><strong>分析</strong><br>这道题稍微有点不同，这道题是算背包容量能剩下多少，所以在计算出各个dp后，要背包容量从1开始递增看是否能够满足，然后输出剩下的最大体力.</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=10005;int w[MAXN]; int v[MAXN];int dp[20000];int main(){    int s,m,n;//s为剩下没填的体积,m为物品件数,n为背包容量    cin&gt;&gt;s&gt;&gt;m&gt;&gt;n;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;v[i]&gt;&gt;w[i];    }    for(int i=1;i&lt;=m;i++){        for(int j=n;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);//计算当前剩余体力能搬的最大体积数        }    }    for(int i=1;i&lt;=n;i++){//遍历各个背包容量        if(dp[i]&gt;=s) {cout&lt;&lt;n-i&lt;&lt;endl; return 0;}    }    //if(dp[n]&gt;=s) cout&lt;&lt;dp[n]-s&lt;&lt;endl; //错误，因为在之前就可能已经满足了，没求到剩下的最大体力    cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="5-集合-Subset-Sums-组合数"><a href="#5-集合-Subset-Sums-组合数" class="headerlink" title="5.集合 Subset Sums(组合数)"></a>5.集合 Subset Sums(组合数)</h2><p><strong>题目描述</strong><br>对于从 1∼n 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 n=3，对于{1,2,3} 能划分成两个子集合，每个子集合的所有数字和是相等的：{3} 和 {1,2} 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）如果n=7，有四种方法能划分集合 {1,2,3,4,5,6,7}，每一种分法的子集合各数字和是相等的:</p><p>{1,6,7} 和 {2,3,4,5}<br>{2,5,7} 和 {1,3,4,6}<br>{3,4,7} 和 {1,2,5,6}<br>{1,2,4,7} 和 {3,5,6}</p><p>给出 n，你的程序应该输出划分方案总数。</p><p><strong>输入格式</strong><br>输入文件只有一行，且只有一个整数 n</p><p><strong>输出格式</strong><br>输出划分方案总数。</p><p><strong>输入</strong></p><blockquote><p>7</p></blockquote><p><strong>输出</strong></p><blockquote><p>4</p></blockquote><p><strong>分析</strong><br>方法类的背包问题，注意背包容量是总的和的一半，而最终求的是划分而不是集合，所以要除以2</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=100;long long dp[1000]={1};//方法种类的背包问题，初始化为1int main(){    int m,n;    cin&gt;&gt;m;    n=m;//n为物品数    if((1+m)*m/2%2==0) m=(1+m)*m/2;//总的和，其一半是背包的容量    else{        cout&lt;&lt;0; return 0;    }    for(int i=1;i&lt;=n;i++){        for(int j=m/2;j&gt;=i;j--){            dp[j]=dp[j]+dp[j-i];//选与不选        }    }    cout&lt;&lt;dp[m/2]/2&lt;&lt;endl;//因为求的是划分数而不是和为m/2的集合数}</code></pre><h2 id="6-目标和"><a href="#6-目标和" class="headerlink" title="6.目标和"></a>6.目标和</h2><p><img src="https://img-blog.csdnimg.cn/20200419174249875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>设P为正数集的和,N为负数集合的和,S为所有元素和,T为目标和<br>∵P+N=S<br>&ensp;&ensp;P-N=T<br>∴2P=S+T<br>所以只要找到在序列找到和为(S+T)/2的所有方案就行,此时转化成了0-1背包的组合数问题</p><pre><code class="cpp">class Solution {public:    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {        int n=nums.size();        int sum=0;        for(int i=0;i&lt;n;i++){            sum+=nums[i];        }        long long temp=(long long)sum+(long long)S;        if(temp%2==1||S-sum&gt;0) return 0;        int target=(sum+S)/2;        //初始化        vector&lt;int&gt; dp(10010,0);        dp[0]=1;;        //cout&lt;&lt;dp[S]&lt;&lt;endl;        for(int i=0;i&lt;n;i++){            for(int j=target;j&gt;=nums[i];j--){                //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;j-nums[i]&lt;&lt;endl;                dp[j]=dp[j]+dp[j-nums[i]];                //cout&lt;&lt;dp[j]&lt;&lt;endl;            }        }        return dp[target];    }};</code></pre><h2 id="7-分割等和子集-true-amp-false"><a href="#7-分割等和子集-true-amp-false" class="headerlink" title="7.分割等和子集(true&amp;false)"></a>7.分割等和子集(true&amp;false)</h2><p><img src="https://img-blog.csdnimg.cn/20200419170458826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    long long dp[10010];    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum=0;        for(int i=0;i&lt;nums.size();i++){            sum+=nums[i];        }        if(sum%2==1) return false;        int target=sum/2;        //初始化,注意初始化的方法        vector&lt;bool&gt; dp(target,false);        dp[0]=true;        cout&lt;&lt;dp[0]&lt;&lt;endl;        for(int i=0;i&lt;nums.size();i++){            for(int j=target;j&gt;=nums[i];j--){                dp[j]=dp[j]||dp[j-nums[i]];                //cout&lt;&lt;dp[j]&lt;&lt;endl;            }        }        return dp[target];    }};</code></pre><h2 id="8-一和零-双weight"><a href="#8-一和零-双weight" class="headerlink" title="8.一和零(双weight)"></a>8.一和零(双weight)</h2><p><img src="https://img-blog.csdnimg.cn/20200414182723147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注:这里的weight是二维的(对于每一个串都有自己0,1的weight)</p><pre><code class="cpp">    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {        //dp[i][j]表示i个0，j个1能够拼出的数组中的最大的字符串数量        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1));        vector&lt;vector&lt;int&gt;&gt; weight(strs.size(),vector&lt;int&gt;(2,0));        //cout&lt;&lt;dp[1][1]&lt;&lt;endl;        for(int i=0;i&lt;strs.size();i++){            for(int j=0;j&lt;strs[i].size();j++){                if(strs[i][j]==&#39;0&#39;) weight[i][0]++;                else weight[i][1]++;            }            //cout&lt;&lt;weight[i][0]&lt;&lt;&quot; &quot;&lt;&lt;weight[i][1]&lt;&lt;endl;        }        for(int k=0;k&lt;strs.size();k++){//从上到下每个物品选与不选            //cout&lt;&lt;weight[k][0]&lt;&lt;&quot; &quot;&lt;&lt;weight[k][1]&lt;&lt;endl;            for(int i=m;i&gt;=weight[k][0];i--){//遍历0的背包容量                for(int j=n;j&gt;=weight[k][1];j--){//遍历1的背包容量                    dp[i][j]=max(dp[i][j],dp[i-weight[k][0]][j-weight[k][1]]+1);                    //cout&lt;&lt;dp[i][j]&lt;&lt;endl;                }            }        }        return dp[m][n];    }</code></pre><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="1-疯狂的采药"><a href="#1-疯狂的采药" class="headerlink" title="1.疯狂的采药"></a>1.疯狂的采药</h2><p><strong>题目描述</strong><br>LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是LiYuxiang，你能完成这个任务吗？<br>此题和原题的不同点：<br>1.每种草药可以无限制地疯狂采摘。<br>2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p><p><strong>输入格式</strong><br>输入第一行有两个整数T（1 &lt;= T &lt;= 100000）和M（1 &lt;= M &lt;= 10000），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间（包括1和10000）的整数，分别表示采摘某种草药的时间和这种草药的价值。</p><p><strong>输出格式</strong><br>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><p><strong>输入</strong></p><blockquote><p>70 3<br>71 100<br>69 1<br>1 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>140</p></blockquote><p><strong>分析</strong><br>完全背包要修改j的遍历方式，需要反着来</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=10005;int w[MAXN],v[MAXN];int dp[100005];int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=1;i&lt;=m;i++){        for(int j=w[i];j&lt;=n;j++){//完全背包和0-1背包这里是反着的            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="2-神奇的四次方数"><a href="#2-神奇的四次方数" class="headerlink" title="2.神奇的四次方数"></a>2.神奇的四次方数</h2><p><strong>题目描述</strong><br>将一个整数m分解为n个四次方数的和的形式，要求n最小。例如，m=706,706=5^4+3^4,则n=2。</p><p><strong>输入格式</strong><br>一行，一个整数m。</p><p><strong>输出格式</strong><br>一行，一个整数n。</p><p><strong>输入</strong></p><blockquote><p>706</p></blockquote><p><strong>输出</strong></p><blockquote><p>2</p></blockquote><p><strong>分析</strong><br>这道题因为求的是最小，所以要将dp初始化为一个比较大的数，并且dp[0]=0；<br>相当于给一个初始值，含义为容量为0时最少选择0个数.</p><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;math.h&gt;using namespace std;const int MAXN=100;int w[MAXN];//每个的w都是1int dp[1000001];int main(){    //下面这两步一定要写    memset(dp,63,sizeof(dp));    //给了一个初始值，不然结果会是一个很大的数，其含义代表容量为0时最少选择0个数    dp[0]=0;    int n,m;//n为背包容量    cin&gt;&gt;n;    for(int i=1;pow(i,4)&lt;=n;i++){        w[i]=i*i*i*i;        m=i;//m表示物品的数目    }    for(int i=1;i&lt;=m;i++){        for(int j=w[i];j&lt;=n;j++){//v[i]是1            dp[j]=min(dp[j],dp[j-w[i]]+1);//            cout&lt;&lt;dp[j]&lt;&lt;endl;        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="3-零钱兑换-II-组合数"><a href="#3-零钱兑换-II-组合数" class="headerlink" title="3.零钱兑换 II(组合数)"></a>3.零钱兑换 II(组合数)</h2><p><img src="https://img-blog.csdnimg.cn/20200419161911317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>是求组合数，因为{1,2},{2,1}是同一个<br>求组合数模板是<strong>先遍历物品，再遍历背包</strong></p><pre><code class="cpp">class Solution {public:    int dp[10010];    int change(int amount, vector&lt;int&gt;&amp; coins) {        memset(dp,0,sizeof(dp));        dp[0]=1;        for(int i=0;i&lt;coins.size();i++){            for(int j=coins[i];j&lt;=amount;j++){                dp[j]=dp[j]+dp[j-coins[i]];            }        }        return dp[amount];    }};</code></pre><h2 id="4-组合总和-Ⅳ-排列数-反向嵌套"><a href="#4-组合总和-Ⅳ-排列数-反向嵌套" class="headerlink" title="4.组合总和 Ⅳ(排列数,反向嵌套)"></a>4.组合总和 Ⅳ(排列数,反向嵌套)</h2><p><img src="https://img-blog.csdnimg.cn/20200419154823970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>是求排列数，因为{1,2},{2,1}不是同一个<br>求组合数模板是<strong>先遍历背包，再遍历物品</strong></p><pre><code class="cpp">class Solution {public:    int combinationSum4(vector&lt;int&gt;&amp; nums, int target)     {        if(nums.size() == 0)            return 0;        vector&lt;unsigned int&gt; dp(target + 1, 0);        dp[0] = 1;//组成0的方案只能是全部都不选择，所以方案数为1.        for(int i = 0; i &lt;= target; i++)        {            for(int j = 0; j &lt; nums.size(); j++)            {                if(i - nums[j] &gt;= 0)                    dp[i] += dp[i - nums[j]];            }        }        return dp[target];    }};</code></pre><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="1-通天之分组背包"><a href="#1-通天之分组背包" class="headerlink" title="1.通天之分组背包"></a>1.通天之分组背包</h2><p><strong>题目描述</strong><br>自01背包问世之后，小A对此深感兴趣。一天，小A去远游，却发现他的背包不同于01背包，他的物品大致可分为k组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。</p><p><strong>输入格式</strong><br>两个数m,n，表示一共有n件物品，总重量为m<br>接下来n行，每行3个数ai,bi,ci，表示物品的重量，利用价值，所属组数</p><p><strong>输出格式</strong><br>一个数，最大的利用价值</p><p><strong>输入</strong></p><blockquote><p>45 3<br>10 10 1<br>10 5 1<br>50 400 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>10</p></blockquote><p><strong>分析</strong><br>分组背包采用结构体数组，其下标代表组数，内部的w，v数组存的是组内的元素情况，总组数要在输入中算出，第二次遍历也是先遍历所有组，其本质相当于0-1背包的问题</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=2000;struct group{    int group_size;//组的大小    int w[MAXN],v[MAXN];}G[1000];//下标代表组号int dp[10000];int main(){    int n,m,s=0;//s代表组数    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int a,b,c;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        s=max(c,s);//统计总的组数        G[c].group_size++;//c组内的成员增加        int ci=G[c].group_size;        G[c].w[ci]=a;        G[c].v[ci]=a;    }    for(int i=1;i&lt;=s;i++){//从上到下遍历所有组        for(int j=n;j&gt;=0;j--){            for(int k=1;k&lt;=G[i].group_size;k++){//组内成员竞争，注意j不会变化                if(j-G[i].w[k]&gt;=0){//注意                    dp[j]=max(dp[j],dp[j-G[i].w[k]]+G[i].v[k]);                }            }        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre><h2 id="2-金明的预算方案"><a href="#2-金明的预算方案" class="headerlink" title="2.金明的预算方案"></a>2.金明的预算方案</h2><p><strong>题目描述</strong><br>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>主件 附件</p><p>电脑 打印机，扫描仪</p><p>书柜 图书</p><p>书桌 台灯，文具</p><p>工作椅 无</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分5等：用整数1−5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br>请你帮助金明设计一个满足要求的购物单。</p><p><strong>输入格式</strong><br>第11行，为两个正整数，用一个空格隔开：</p><p>n m（其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第j行给出了编号为j−1的物品的基本数据，每行有3个非负整数</p><p>v p q（其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1-5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）</p><p><strong>输出格式</strong><br>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。</p><p><strong>输入</strong></p><blockquote><p>1000 5<br>800 2 0<br>400 5 1<br>300 5 1<br>400 3 0<br>500 2 0</p></blockquote><p><strong>输出</strong></p><blockquote><p>2200</p></blockquote><p><strong>分析</strong><br>先转化为分组问题，假设有主(①)，从(②)，从(③)<br>所以得到一个组内四个相斥的成员：<br>①、①②、①③、①③</p><pre><code class="clike">#include&lt;iostream&gt;using namespace std;const int MAXN=100;struct group{    int group_size;    int w[MAXN],v[MAXN];}G[2000];int dp[32005];//因为每个主件可以有0个、1个或2个附件,所以对于组内只有四种相互排斥的情况，所以可以转化为分组背包int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int v,p,q;        cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;        if(q==0){//是这组的第一个,i就代表了组号            G[i].group_size=1;            G[i].w[1]=v;            G[i].v[1]=p*v;        }        else{            if(G[q].group_size==1){//一主一从,q代表所从属的组                G[q].group_size=2;                G[q].w[2]=G[q].w[1]+v;//一个主，从一号                G[q].v[2]=G[q].v[1]+p*v;            }            else{                G[q].group_size=4;//                G[q].w[3]=G[q].w[1]+v;//一个主，从二号                G[q].v[3]=G[q].v[1]+p*v;                G[q].w[4]=G[q].w[2]+v;//一个主，从一号，从二号                G[q].v[4]=G[q].v[2]+p*v;            }        }    }    for(int i=1;i&lt;=m;i++){//遍历所有组        for(int j=n;j&gt;=0;j--){            for(int k=1;k&lt;=G[i].group_size;k++){//组内成员竞争                if(j&gt;=G[i].w[k]){//                    dp[j]=max(dp[j],dp[j-G[i].w[k]]+G[i].v[k]);                    //cout&lt;&lt;dp[j]&lt;&lt;endl;                }            }        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票问题总结</title>
    <link href="/2020/04/16/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/16/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>注意:这里面dp[①][②][③]的理解<br>①第几天<br>②还剩几次交易机会<br>③1：当前持股；   0：当前不持股<br>1.<strong>dp的含义是当前这个状态下能达到的最大的收益</strong></p><p>2.因为是状态转移，所以已经满足了不会连续买入</p><p>3.也因为是状态转移，所以情况多了后，初始化为0位造成影响，比如dp[i][0][0]这个时候是没有持股，并且没有再买入的机会，这个时候若直接用max(dp[i-1][0][0],dp[i-1][0][1]+prices[i]);会是0+prices[i]就会造成误判，所以要<strong>初始化为int_min</strong></p><p>4.只买一次max(dp[i-1][1],<strong>-prices[i]</strong>);<br> &nbsp;&nbsp;&nbsp;无穷次max(dp[i-1][1],<strong>dp[i-1][0]-prices[i]</strong>);</p><h2 id="1-买卖股票的最佳时机"><a href="#1-买卖股票的最佳时机" class="headerlink" title="1.买卖股票的最佳时机"></a>1.买卖股票的最佳时机</h2><p><img src="https://img-blog.csdnimg.cn/20200416150639901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        int dp[1000010][2];        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                dp[i][0]=0;                dp[i][1]=-prices[i];            }            else{                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);                //写成-prices[i]保证了计算出来的利润只包含了一次的买卖                dp[i][1]=max(dp[i-1][1],-prices[i]);                //cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][0]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][1]&lt;&lt;endl;            }        }        for(int i=0;i&lt;prices.size();i++){            //对卖出所赚的钱进行比较            max_profit=max(max_profit,dp[i][0]);        }        return max_profit;    }};</code></pre><h2 id="2-买卖股票的最佳时机-II"><a href="#2-买卖股票的最佳时机-II" class="headerlink" title="2.买卖股票的最佳时机 II"></a>2.买卖股票的最佳时机 II</h2><p><img src="https://img-blog.csdnimg.cn/20200416152331656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        int dp[100010][2];//[天数][是否持有]        if(prices.size()==0) return 0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                //初始化                                dp[i][0]=0;                dp[i][1]=-prices[i];            }            else{                //状态变换                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);                //因为可以交易无限次，所以这里写成dp[i-1][0]-prices[i]                dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);            }        }        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);    }};</code></pre><h2 id="3-买卖股票的最佳时机-III"><a href="#3-买卖股票的最佳时机-III" class="headerlink" title="3.买卖股票的最佳时机 III"></a>3.买卖股票的最佳时机 III</h2><p><img src="https://img-blog.csdnimg.cn/20200416162655992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(prices.size()==0) return 0;        //注意:应该将初始dp值设为int_min,不然有的第二次卖出是用一个空的状态(0)+prices[i](实际上在这之前根本没买)        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(prices.size(),vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(2,INT_MIN)));        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                dp[i][2][0]=0;                dp[i][1][1]=-prices[i];            }            else{                //每当买入才进行一次k--，所以在持股到卖出的这个过程中不用考虑k的变化                //没有买入                //dp[i][2][0]=0;                //第一次卖出                dp[i][1][0]=max(dp[i-1][1][0],dp[i-1][1][1]+prices[i]);                //第二次卖出                if(i&gt;2) dp[i][0][0]=max(dp[i-1][0][0],dp[i-1][0][1]+prices[i]);                //第一次买入                dp[i][1][1]=max(dp[i-1][1][1],-prices[i]);                //第二次买入                if(i&gt;=2) dp[i][0][1]=max(dp[i-1][0][1],dp[i-1][1][0]-prices[i]);            }            //cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][1][0]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][0][0]&lt;&lt;&quot;       &quot;&lt;&lt;dp[i][1][1]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][0][1]&lt;&lt;endl;        }        //交易一次和交易两次        max_profit=max(dp[prices.size()-1][0][0],dp[prices.size()-1][1][0]);        //不交易        max_profit=max(max_profit,0);        return max_profit;    }};</code></pre><p>若是允许k次交易</p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(prices.size()==0) return 0;        //注意:应该将初始dp值设为int_min,不然有的第二次卖出是用一个空的状态(0)+prices[i](实际上在这之前根本没买)        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(prices.size(),vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(2,0)));        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            //注意这个初始化!!            for(int j=1;j&gt;=0;j--){                if(i==0){                    dp[i][j][0]=0;                    dp[i][j][1]=-prices[i];                }                else{                    dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);                    dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j+1][0]-prices[i]);                }            }        }        //交易一次和交易两次        max_profit=max(dp[prices.size()-1][0][0],dp[prices.size()-1][1][0]);        //不交易        max_profit=max(max_profit,0);        return max_profit;    }};</code></pre><h2 id="4-最佳买卖股票时机含冷冻期"><a href="#4-最佳买卖股票时机含冷冻期" class="headerlink" title="4.最佳买卖股票时机含冷冻期"></a>4.最佳买卖股票时机含冷冻期</h2><p><img src="https://img-blog.csdnimg.cn/20200416174642900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(prices.size()==0) return 0;        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(),vector&lt;int&gt;(2,0));        int max_profit=0;        for(int i=0;i&lt;prices.size();i++){            if(i==0){                dp[i][0]=0;                dp[i][1]=-prices[i];            }            else{                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);                if(i&gt;=2) dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i]);                //若在第二个之前持有股票那么就只可能在0处买或在1处买                else dp[i][1]=max(dp[i-1][1],-prices[i]);            }        }        return dp[prices.size()-1][0];    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度计算</title>
    <link href="/2020/04/16/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/04/16/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="高进度加法"><a href="#高进度加法" class="headerlink" title="高进度加法"></a>高进度加法</h2><pre><code class="cpp">void add(string aa,string bb){    la=aa.size();    lb=bb.size();    for(int i=0;i&lt;la;i++){        a[la-i]=aa[i]-&#39;0&#39;;    }    for(int i=0;i&lt;lb;i++){        b[lb-i]=bb[i]-&#39;0&#39;;    }    lc=max(la,lb);    for(int i=1;i&lt;=lc;i++){        c[i]+=(a[i]+b[i])%10;        c[i+1]=(a[i]+b[i])/10;    }    if(c[lc+1]) lc++;    for(int i=lc;i&gt;=1;i--){        cout&lt;&lt;c[i];    }}</code></pre><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><pre><code class="cpp">//相等返回0，大于返回1，小于返回-1int compare(string s1,string s2){    if(s1.size()&gt;s2.size()) return 1;    else if(s1.size()&lt;s2.size()) return -1;    else return s1.compare(s2);//位数相同用compare函数进行比较}void sub(string aa,string bb){    //比较大小    if(compare(aa,bb)==-1){        swap(aa,bb);        cout&lt;&lt;&quot;-&quot;;    }    else if(compare(aa,bb)==0){        cout&lt;&lt;0; return;    }    la=aa.size();    lb=bb.size();    //string-&gt;int数组,低位排在前面    for(int i=0;i&lt;la;i++){        a[la-i]=aa[i]-&#39;0&#39;;    }    for(int i=0;i&lt;lb;i++){        b[lb-i]=bb[i]-&#39;0&#39;;    }    //计算    for(int i=1;i&lt;=la;i++){        if(a[i]&lt;b[i]){            a[i]+=10;            a[i+1]--;        }        c[i]=a[i]-b[i];    }    //去除多余的0,la&gt;1防止去掉全0的情况    while(c[la]==0&amp;&amp;la&gt;1) la--;    for(int i=la;i&gt;=1;i--){        cout&lt;&lt;c[i];    }    }</code></pre><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><pre><code class="cpp">void mul(string a,string b){    la=a.size();    lb=b.size();    //string-&gt;int数组,低位排在前面    for(int i=0;i&lt;la;i++){        a[la-i]=x[i]-&#39;0&#39;;    }    for(int i=0;i&lt;lb;i++){        b[lb-i]=y[i]-&#39;0&#39;;    }    //乘法计算    for(int i=1;i&lt;=la;i++){//从1开始        for(int j=1;j&lt;=lb;j++){            //别忘了+号，同一个结果为是多个乘积叠加的            c[i+j-1]+=a[i]*b[j];            c[i+j]+=c[i+j-1]/10;            c[i+j-1]%=10;        }    }    //计算结果的长度(消去没有用的)，方便打印    lc=la+lb;    while(c[lc]==0&amp;&amp;lc&gt;1){        lc--;    }    //反向输出    for(int i=lc;i&gt;=1;i--){        cout&lt;&lt;c[i];    }}</code></pre><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><pre><code class="cpp">//高精度除单精度string div(string a,int b)//高精度a除以单精度b{    string r,ans;    int d=0;    if(a==&quot;0&quot;) return a;//特判    for(int i=0;i&lt;a.size();i++)    {                        //上一步余数*10相当与此时的被除数            r+=(d*10+a[i]-&#39;0&#39;)/b+&#39;0&#39;;//求出商            d=(d*10+(a[i]-&#39;0&#39;))%b;//求出余数    }    int p=0;    for(int i=0;i&lt;r.size();i++)    if(r[i]!=&#39;0&#39;) {p=i;break;}    return r.substr(p);}int main(){    string a;    int b;    while(cin&gt;&gt;a&gt;&gt;b)    {        cout&lt;&lt;div(a,b)&lt;&lt;endl;    }    return 0;}</code></pre><h2 id="高精度取模"><a href="#高精度取模" class="headerlink" title="高精度取模"></a>高精度取模</h2><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int mod(string a,int b)//高精度a除以单精度b{    int d=0;    for(int i=0;i&lt;a.size();i++)  d=(d*10+(a[i]-&#39;0&#39;))%b;  //求出余数    return d;}int main(){    string a;    int b;    while(cin&gt;&gt;a&gt;&gt;b)    {        cout&lt;&lt;mod(a,b)&lt;&lt;endl;    }    return 0;</code></pre><h2 id="高精度阶乘"><a href="#高精度阶乘" class="headerlink" title="高精度阶乘"></a>高精度阶乘</h2><pre><code class="cpp">const int L=100005;int a[L];string fac(int n){    string ans;    if(n==0) return &quot;1&quot;;    fill(a,a+L,0);    int s=0,m=n;    while(m) a[++s]=m%10,m/=10;    for(int i=n-1;i&gt;=2;i--)    {        int w=0;        for(int j=1;j&lt;=s;j++) a[j]=a[j]*i+w,w=a[j]/10,a[j]=a[j]%10;        while(w) a[++s]=w%10,w/=10;    }    while(!a[s]) s--;    while(s&gt;=1) ans+=a[s--]+&#39;0&#39;;    return ans;}int main(){    int n;    while(cin&gt;&gt;n) cout&lt;&lt;fac(n)&lt;&lt;endl;    return 0;}</code></pre><h2 id="大数进制转换"><a href="#大数进制转换" class="headerlink" title="大数进制转换"></a>大数进制转换</h2><p><img src="https://img-blog.csdnimg.cn/20200416120150116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1020char map[40]=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;int main(){    int m,n,i,j,sum,len,point,answer;    char ans[N],str[N];    int a[N];    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF)    {        memset(ans,0,sizeof(ans));        memset(a,0,sizeof(a));        scanf(&quot;%s&quot;,str);        len=strlen(str);        if(len==1&amp;&amp;str[0]==&#39;0&#39;)        {            printf(&quot;0\n&quot;);            continue;        }        for(i=0;str[i]!=&#39;\0&#39;;i++)        {            if(str[i]&gt;=&#39;A&#39;&amp;&amp;str[i]&lt;=&#39;Z&#39;)                a[i]=str[i]-&#39;A&#39;+10;            else a[i]=str[i]-&#39;0&#39;;        }        j=0;        while(1)        {            answer=0;            for(i=0;i&lt;len;i++)            if(a[i]!=0)            {                answer=1;                break;            }            if(answer==0)            break;            sum=0;            for(i=0;i&lt;len;i++)            {                sum=sum*m+a[i];                sum=sum%n;            }            ans[j++]=map[sum];            point=0;            for(i=0;i&lt;len;i++)            {                a[i]+=point*m;                point=a[i]%n;                a[i]/=n;            }        }        for(j--;j&gt;=0;j--)        printf(&quot;%c&quot;,ans[j]);        printf(&quot;\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>高精度计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS和DFS</title>
    <link href="/2020/04/15/BFS%E5%92%8CDFS/"/>
    <url>/2020/04/15/BFS%E5%92%8CDFS/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="填涂颜色"><a href="#填涂颜色" class="headerlink" title="填涂颜色"></a>填涂颜色</h2><p><strong>题目描述</strong><br>由数字00组成的方阵中，有一任意形状闭合圈，闭合圈由数字11构成，围圈时只走上下左右44个方向。现要求把闭合圈内的所有空间都填写成22.例如：6 \times 66×6的方阵（n=6n=6），涂色前和涂色后的方阵如下：<br><img src="https://img-blog.csdnimg.cn/20200305115131657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>输入格式</strong><br>每组测试数据第一行一个整数n(1≤n≤30)<br>接下来n行，由0和1组成的n×n的方阵。<br>方阵内只有一个闭合圈，圈内至少有一个0。</p><p><strong>输出格式</strong><br>已经填好数字22的完整方阵。</p><p><strong>输入</strong></p><blockquote><p>6<br>0 0 0 0 0 0<br>0 0 1 1 1 1<br>0 1 1 0 0 1<br>1 1 0 0 0 1<br>1 0 0 0 0 1<br>1 1 1 1 1 1</p></blockquote><p><strong>输出</strong></p><blockquote><p>0 0 0 0 0 0<br>0 0 1 1 1 1<br>0 1 1 2 2 1<br>1 1 2 2 2 1<br>1 2 2 2 2 1<br>1 1 1 1 1 1</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int MAXN=100;int Map[MAXN][MAXN];int vis[MAXN][MAXN];//访问标记，为0表示没被访问//能走的四个方向int way[4][2]={{0,1},{0,-1},{1,0},{-1,0}};struct position{    int x,y;    position(int x,int y):x(x),y(y){};};queue&lt;position&gt; q;int main(){    int n;    cin&gt;&gt;n;    //最开始应该在外面再加一圈零(从1开始输入),因为(0,0)这个点若是1就完蛋    //所以要注意遍历初始点的选取    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            cin&gt;&gt;Map[i][j];        }    }    q.push(position(0,0));//初始点进队列    vis[0][0]=1;    while(!q.empty()){        position current=q.front();        for(int i=0;i&lt;4;i++){            //沿着每个方向变化后的横纵坐标            int x=current.x+way[i][0];            int y=current.y+way[i][1];            //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;            //加了Map[x][y]==0的条件，将1围成的圈外部的0全部置已访问            if(x&gt;=0&amp;&amp;x&lt;=n+1&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n+1&amp;&amp;Map[x][y]==0&amp;&amp;vis[x][y]==0){                q.push(position(x,y));                vis[x][y]=1;            }        }        q.pop();    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(Map[i][j]==0&amp;&amp;vis[i][j]==0){                cout&lt;&lt;2&lt;&lt;&quot; &quot;;            }            else  cout&lt;&lt;Map[i][j]&lt;&lt;&quot; &quot;;        }        cout&lt;&lt;endl;    }}</code></pre><h2 id="马的遍历"><a href="#马的遍历" class="headerlink" title="马的遍历"></a>马的遍历</h2><p><strong>题目描述</strong><br>有一个n*m的棋盘(1&lt;n,m&lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步</p><p><strong>输入格式</strong><br>一行四个数据，棋盘的大小和马的坐标</p><p><strong>输出格式</strong><br>一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）</p><p><strong>输入</strong></p><blockquote><p>3 3 1 1</p></blockquote><p><strong>输出</strong></p><blockquote><p>0    3    2<br>3    -1   1<br>2    1    4</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=500;int Map[MAXN][MAXN];int vis[MAXN][MAXN];struct position{    int x,y;    int steps;    position(int x,int y,int steps):x(x),y(y),steps(steps){};};//马跳的8个方向int way[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};queue&lt;position&gt; q;int main(){    int n,m,x1,y1;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x1&gt;&gt;y1;    q.push(position(x1-1,y1-1,0));//初始点    vis[x1-1][y1-1]=1;//这一步别忘了    while(!q.empty()){        position current=q.front();        for(int i=0;i&lt;8;i++){            int x=current.x+way[i][0];            int y=current.y+way[i][1];            if(x&gt;=0&amp;&amp;x&lt;=n-1&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n-1&amp;&amp;vis[x][y]==0){                q.push(position(x,y,current.steps+1));                Map[x][y]=current.steps+1;                vis[x][y]=1;            }        }        q.pop();    }    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            if(vis[i][j]!=0) printf(&quot;%-5d&quot;,Map[i][j]);            else printf(&quot;%-5d&quot;,-1);        }        cout&lt;&lt;endl;    }}</code></pre><h2 id="奇怪的电梯"><a href="#奇怪的电梯" class="headerlink" title="奇怪的电梯"></a>奇怪的电梯</h2><p><strong>题目描述</strong><br>呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第ii层楼(1≤i≤N)上有一个数字Ki(0≤Ki≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3, 3 ,1 ,2 ,5代表了Ki(K1=3,K2=3,…)，从1楼开始。在1楼，按“上”可以到4楼，按“下”是不起作用的，因为没有−2楼。那么，从A楼到B楼至少要按几次按钮呢？</p><p><strong>输入格式</strong><br>共二行。<br>第一行为3个用空格隔开的正整数，表示N,A,B(1≤N≤200, 1≤A,B≤N)。<br>第二行为N个用空格隔开的非负整数，表示Ki</p><p><strong>输出格式</strong><br>一行，即最少按键次数,若无法到达，则输出−1。</p><p>输入</p><blockquote><p>5 1 5<br>3 3 1 2 5</p></blockquote><p>输出</p><blockquote><p>3</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct sta{    int f;    int steps;    sta(int f,int steps):f(f),steps(steps){};};const int MAXN=300;int way[MAXN];//记录可以移动的步数int vis[MAXN];queue&lt;sta&gt; q;int main(){    int n,a,b;//a为起点,b为终点    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;way[i];    }    q.push(sta(a,0));    vis[a]=1;    while(!q.empty()){        sta current=q.front();        //cout&lt;&lt;current.f&lt;&lt;endl;        if(current.f==b){//出口            cout&lt;&lt;current.steps&lt;&lt;endl;            return 0;        }        int down=current.f-way[current.f];//向下        if(down&gt;=1&amp;&amp;vis[down]==0){            q.push(sta(down,current.steps+1));            vis[down]=1;        }        int up=current.f+way[current.f];//向下        if(up&lt;=n&amp;&amp;vis[up]==0){            q.push(sta(up,current.steps+1));            vis[up]=1;        }        q.pop();    }    cout&lt;&lt;-1&lt;&lt;endl;}</code></pre><h2 id="01迷宫"><a href="#01迷宫" class="headerlink" title="01迷宫"></a>01迷宫</h2><p><strong>题目描述</strong><br>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。<br>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p><p><strong>输入格式</strong><br>第1行为两个正整数n,m。<br>下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。<br>接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。</p><p><strong>输出格式</strong><br>m行，对于每个询问输出相应答案。</p><p><strong>输入</strong></p><blockquote><p>2 2<br>01<br>10<br>1 1<br>2 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>4<br>4</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int MAXN=2000;struct position{    int x,y;    position(int x,int y):x(x),y(y){};};int Map[MAXN][MAXN];int vis[MAXN][MAXN];int ans[10000000];//存的是各个颜色区域的结点数int color=0,n,m;int way[4][2]={{0,1},{0,-1},{1,0},{-1,0}};queue&lt;position&gt; q;void bfs(int x1,int y1){    int cnt=0;//用来对当前颜色的区域来计数    q.push(position(x1,y1));    vis[x1][y1]=color;    while(!q.empty()){        position current=q.front();        //cout&lt;&lt;current.x&lt;&lt;&quot; &quot;&lt;&lt;current.y&lt;&lt;endl;        for(int k=0;k&lt;4;k++){            int x=current.x+way[k][0];            int y=current.y+way[k][1];            if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n&amp;&amp;vis[x][y]==0&amp;&amp;Map[x][y]!=Map[current.x][current.y]){                q.push(position(x,y));                vis[x][y]=color;            }        }        cnt++;        q.pop();    }    //cout&lt;&lt;color&lt;&lt;endl;    ans[color]=cnt;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            char c;            cin&gt;&gt;c;            Map[i][j]=c-&#39;0&#39;;            //cout&lt;&lt;Map[i][j]&lt;&lt;endl;        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(vis[i][j]==0){                color++;//每一个color来区分一块互相可以到达的区域                //cout&lt;&lt;color&lt;&lt;endl;                bfs(i,j);//注意函数中不能出现i,j            }        }    }    for(int i=1;i&lt;=m;i++){        int xx,yy;        cin&gt;&gt;xx&gt;&gt;yy;        cout&lt;&lt;ans[vis[xx][yy]]&lt;&lt;endl;    }}</code></pre><h2 id="墙与门"><a href="#墙与门" class="headerlink" title="墙与门"></a>墙与门</h2><p><img src="https://img-blog.csdnimg.cn/20200415115105402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注:这是一道多源bfs的题，将终点看做第0层，然后逐层遍历</p><pre><code class="cpp">int way[4][2]={{1,0},{0,1},{-1,0},{0,-1}};    void wallsAndGates(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) {        int m=rooms.size();        if(m==0) return;        int n=rooms[0].size();        vector&lt;vector&lt;int&gt;&gt; vis(m,vector&lt;int&gt;(n,0));        queue&lt;pair&lt;int,int&gt;&gt; q;        //将第0层的所有结点push进队列        for(int i=0;i&lt;m;i++){            for(int j=0;j&lt;n;j++){                if(rooms[i][j]==0){                    vis[i][j]=1;                    q.push({i,j});                }            }        }        //q一直保存当前层以及下一层的结点(除了在最开始只保存第0层的结点)        int step=0;        while(!q.empty()){            int k=q.size();            step++;            while(k--){                for(int i=0;i&lt;4;i++){                    int xd=q.front().first+way[i][0];                    int yd=q.front().second+way[i][1];                    if(xd&gt;=0&amp;&amp;xd&lt;m&amp;&amp;yd&gt;=0&amp;&amp;yd&lt;n&amp;&amp;vis[xd][yd]==0&amp;&amp;rooms[xd][yd]!=-1){                        vis[xd][yd]=1;                        rooms[xd][yd]=step;                        q.push({xd,yd});                    }                }                q.pop();            }        }    }</code></pre><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p><strong>题目描述</strong><br>一个如下的6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。<br><img src="https://img-blog.csdnimg.cn/20200305121201768.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>上面的布局可以用序列2 4 6 1 3 5 来描述，第 i 个数字表示在第 i 行的相应位置有一个棋子，如下：<br>行号 1 2 3 4 5 6<br>列号 2 4 6 1 3 5<br>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br>并把它们以上面的序列方法输出，解按字典顺序排列。<br>请输出前 3 个解。最后一行是解的总个数。</p><p><strong>输入格式</strong><br>一行一个正整数 nn，表示棋盘是 n \times nn×n 大小的。</p><p><strong>输出格式</strong><br>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。</p><p><strong>输入</strong></p><blockquote><p>6</p></blockquote><p><strong>输出</strong></p><blockquote><p>2 4 6 1 3 5<br>3 6 2 5 1 4<br>4 1 5 2 6 3<br>4</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int ans[13];//作为每次深搜出来的序列的结果int vis[13];int u[40];//正对角线int v[40];//副对角线int n;int Count=0;void print(){    for(int i=1;i&lt;=n;i++){        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;    }    cout&lt;&lt;endl;}void dfs(int x){//dfs中的参数是行号    if(x&gt;n){        Count++;        if(Count&lt;=3) print();        return ;    }    for(int i=1;i&lt;=n;i++){//i表示尝试列号        if(!vis[i]&amp;&amp;!u[x-i+n]&amp;&amp;!v[x+i]){//vis能保证不在同一列,u表示不在同一主对角(+n为了不为负数),v表示不在同一副对角            //i-ans[j]为列差,x-j为行差            vis[i]=1;            u[x-i+n]=1;            v[x+i]=1;            ans[x]=i;            dfs(x+1);            //为了回溯            vis[i]=0;            u[x-i+n]=0;            v[x+i]=0;        }    }}int main(){    cin&gt;&gt;n;    dfs(1);    cout&lt;&lt;Count&lt;&lt;endl;}</code></pre><h2 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h2><p><strong>题目背景</strong><br>给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p><p><strong>题目描述</strong><br>无</p><p><strong>输入格式</strong><br>第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。</p><p><strong>输出格式</strong><br>给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。</p><p><strong>输入</strong></p><blockquote><p>2 2 1<br>1 1 2 2<br>1 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>1</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;using namespace std;int n,m,t,sx,sy,fx,fy,Count=0;int Map[10][10];//相当于vis数组int way[4][2]={{0,1},{0,-1},{1,0},{-1,0}};void dfs(int x,int y){    if(x==fx&amp;&amp;y==fy){        Count++;        return;    }    for(int i=0;i&lt;4;i++){        int dx=x+way[i][0];        int dy=y+way[i][1];        if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=n&amp;&amp;!Map[dx][dy]){            Map[dx][dy]=1;            dfs(dx,dy);            Map[dx][dy]=0;        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;    while(t--){        int x,y;        cin&gt;&gt;x&gt;&gt;y;        Map[x][y]=1;    }    Map[sx][sy]=1;    dfs(sx,sy);    cout&lt;&lt;Count&lt;&lt;endl;}</code></pre><h2 id="单词方阵"><a href="#单词方阵" class="headerlink" title="单词方阵"></a>单词方阵</h2><p><strong>题目描述</strong><br>给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：<br><img src="https://img-blog.csdnimg.cn/20200305121648322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>输入格式<br>第一行输入一个数nn。(7 \le n \le 1007≤n≤100)。</p><p>第二行开始输入n \times nn×n的字母矩阵。</p><p>输出格式<br>突出显示单词的n \times nn×n矩阵。</p><p><strong>输入</strong></p><blockquote><p>8<br>qyizhong<br>gydthkjy<br>nwidghji<br>orbzsfgz<br>hhgrhwth<br>zzzzzozo<br>iwdfrgng<br>yyyygggg</p></blockquote><p><strong>输出</strong></p><blockquote><p><em>yizhong<br>gy<strong>**</strong><br>n<em>i****</em><br>o<strong>z**</strong><br>h<strong><em>h</em></strong><br>z<strong>**o</strong><br>i*****n</em><br>y<strong>**</strong>g</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;using namespace std;char Map[300][300];int vis[300][300];int way[8][2]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};string yz=&quot;yizhong&quot;;//是从i开始比较int n;void dfs(int x,int y){    for(int i=0;i&lt;8;i++){//8个方向        bool flag=true;        for(int j=1;j&lt;=6;j++){//需要比较的6，也相当于走的步数            int dx=x+j*way[i][0];            int dy=y+j*way[i][1];            if(!(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=n)||yz[j]!=Map[dx][dy]){                flag=false;            }        }        if(flag){            for(int j=0;j&lt;7;j++){                int dx=x+j*way[i][0];                int dy=y+j*way[i][1];                vis[dx][dy]=1;            }        }    }}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            cin&gt;&gt;Map[i][j];        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(Map[i][j]==&#39;y&#39;){                dfs(i,j);            }        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(vis[i][j]==1) cout&lt;&lt;Map[i][j];            else cout&lt;&lt;&#39;*&#39;;        }        cout&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>BFS和DFS最终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="/2020/04/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2020/04/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2><p>1、删除的结点无左右子节点，那么直接将其父节点指向NULL；<br>2、删除的结点只有1个子节点，分左右两种情况，直接将其父节点指向删除节点的子节点；<br>3、删除节点有2个子节点，这是最麻烦的情况了，最好是画个图理解，具体而言：</p><pre><code class="cpp">    TreeNode* deleteNode(TreeNode* root, int key) {        if(root==NULL) return NULL;        if(root-&gt;val==key){            //情况一和情况二            if(root-&gt;left==NULL) return root-&gt;right;            if(root-&gt;right==NULL) return root-&gt;left;            //情况三:此时需要找到最近的一个大于当前结点值的元素            TreeNode* RminNode=FindMin(root-&gt;right);            root-&gt;val=RminNode-&gt;val;            root-&gt;right=deleteNode(root-&gt;right,RminNode-&gt;val);        }        else if(key&lt;root-&gt;val){            root-&gt;left=deleteNode(root-&gt;left,key);        }        else if(key&gt;root-&gt;val){            root-&gt;right=deleteNode(root-&gt;right,key);        }        return root;    }    TreeNode* FindMin(TreeNode* root){        if(root-&gt;left) return FindMin(root-&gt;left);        else return root;    }};</code></pre><h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>利用中序求出有序的序列，然后基于这个序列来找</p><pre><code class="cpp">int Max_time=0,Max_number,n=0;    vector&lt;int&gt; v;    map&lt;int,int&gt; m;    vector&lt;int&gt; findMode(TreeNode* root) {        InOrder(root);        map&lt;int,int&gt;::iterator it;        for(it=m.begin();it!=m.end();it++){            if(it-&gt;second&gt;Max_time){                Max_time=it-&gt;second;                Max_number=it-&gt;first;            }        }        for(it=m.begin();it!=m.end();it++){            if(it-&gt;second==Max_time){                v.push_back(it-&gt;first);            }        }        return v;    }    void InOrder(TreeNode* root){        if(root==NULL) return ;        InOrder(root-&gt;left);        if(m.find(root-&gt;val)!=m.end()) m[root-&gt;val]++;//已经存在map中了        else m.insert(pair&lt;int,int&gt;(root-&gt;val,1));        InOrder(root-&gt;right);    }</code></pre><h2 id="根据二叉树创建字符串"><a href="#根据二叉树创建字符串" class="headerlink" title="根据二叉树创建字符串"></a>根据二叉树创建字符串</h2><p><img src="https://img-blog.csdnimg.cn/20200413160034387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>利用先序遍历，注意下按照递归的思想去加括号，注意只有右子树存在也要加两对括号</p><pre><code class="cpp">    string ans=&quot;&quot;;    string tree2str(TreeNode* t) {        PreOrder(t);        return ans;    }    void PreOrder(TreeNode* root){//pos代表当前根结点的位置        if(root==NULL) return;        ostringstream os;        os&lt;&lt;root-&gt;val;        ans+=os.str();        if(root-&gt;right){//右子树存在，则左右都要有括号            ans+=&#39;(&#39;;            PreOrder(root-&gt;left);            ans+=&#39;)&#39;;            ans+=&#39;(&#39;;            PreOrder(root-&gt;right);            ans+=&#39;)&#39;;        }        else if(root-&gt;left){//只有左子树存在,右子树的括号不用写            ans+=&#39;(&#39;;            PreOrder(root-&gt;left);            ans+=&#39;)&#39;;        }    }</code></pre><h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><p><img src="https://img-blog.csdnimg.cn/20200413163023186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>就是一个计算和的递归就行，很简单</p><pre><code class="cpp">    int ans=0;    int findTilt(TreeNode* root) {        SumTree(root);        return ans;    }    int SumTree(TreeNode* root){        if(root==NULL) return 0;        int lsum=SumTree(root-&gt;left);        int rsum=SumTree(root-&gt;right);        ans+=abs(lsum-rsum);        return root-&gt;val+lsum+rsum;    }</code></pre><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p><img src="https://img-blog.csdnimg.cn/20200413163829449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>用双指针(left,right)+递归实现,注意传参的类型！！</p><pre><code class="cpp">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {        return solve(nums.begin(),nums.end());    }    TreeNode* solve(vector&lt;int&gt;::iterator left, vector&lt;int&gt;::iterator right){        if(left == right) return NULL;        auto it = max_element(left,right);        TreeNode* node = new TreeNode(*it);        node-&gt;left = solve(left,it);        node-&gt;right = solve(it+1,right);        return node;    }</code></pre><h2 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h2><p><img src="https://img-blog.csdnimg.cn/20200413172420264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这里递归就是先拆分，得到最底层的值后再合并，<br>拆分就是分成左右子树，最终就是start&gt;end 返回{NULL}。<br>合并的时候要用两个for循环来实现不同的排列。。。<br>注:若只是求种数，可以用卡塔兰数计算<br><img src="https://img-blog.csdnimg.cn/2020041317455984.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">vector&lt;TreeNode*&gt; generateTrees(int n) {        vector&lt;TreeNode*&gt; res;        if(n==0) return res;        return generateTreesCore(1, n);    }    vector&lt;TreeNode*&gt; generateTreesCore(int start, int end){        vector&lt;TreeNode*&gt; res;        if(start&gt;end){            return {NULL};        }        else{            for(int i = start;i&lt;=end;++i){//表示以i为节点构建树                vector&lt;TreeNode*&gt; left = generateTreesCore(start, i-1);//构建左子树                vector&lt;TreeNode*&gt; right = generateTreesCore(i+1, end);//构建右子树                //此时左右子树都有值.要把他们合并在一起。                for(auto r: right){                    for(auto l: left){                        TreeNode* temp = new TreeNode(i);//把每个节点构建出来。                        temp-&gt;left = l;                        temp-&gt;right = r;                        res.push_back(temp);                    }                }            }        }        return res;    }</code></pre><h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h2><p><img src="https://img-blog.csdnimg.cn/20200413175800603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">     vector&lt;int&gt; order;    void recoverTree(TreeNode* root) {        InOrder(root);        //先得到正确的序列        sort(order.begin(),order.end());        recover(root,order);    }    void InOrder(TreeNode* root){        if(root==NULL) return ;        InOrder(root-&gt;left);        order.push_back(root-&gt;val);        InOrder(root-&gt;right);    }    void recover(TreeNode* root,vector&lt;int&gt;&amp; rec){        if(root ==NULL){            return;        }        recover(root-&gt;left,rec);        //        if(root-&gt;val == rec[0]){            rec.erase(rec.begin());        }else{            //若不同则修改为相同            root-&gt;val = rec[0];            rec.erase(rec.begin());        };        recover(root-&gt;right,rec);    }</code></pre><h2 id="二叉树的锯齿形层次遍历"><a href="#二叉树的锯齿形层次遍历" class="headerlink" title="二叉树的锯齿形层次遍历"></a>二叉树的锯齿形层次遍历</h2><pre><code class="cpp">//q1记录正序，q2记录反序    queue&lt;TreeNode*&gt; q1;    queue&lt;TreeNode*&gt; q2;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {        if(root==NULL) return ans;        q1.push(root);        q2.push(root);        TreeNode* pre_last1=root;        TreeNode* last1=root;        TreeNode* pre_last2=root;        TreeNode* last2=root;        int level=0;        vector&lt;int&gt; temp;        while(!q1.empty()&amp;&amp;!q2.empty()){            TreeNode* p1=q1.front();            q1.pop();            TreeNode* p2=q2.front();            q2.pop();            if(p1-&gt;left){                last1=p1-&gt;left;                q1.push(p1-&gt;left);            }            if(p1-&gt;right){                last1=p1-&gt;right;                q1.push(p1-&gt;right);            }            if(p2-&gt;right){                last2=p2-&gt;right;                q2.push(p2-&gt;right);            }            if(p2-&gt;left){                last2=p2-&gt;left;                q2.push(p2-&gt;left);            }            if(level==0) temp.push_back(p1-&gt;val);            else temp.push_back(p2-&gt;val);            //两个同时到达当前行的最后一个            if(p1==pre_last1){                pre_last1=last1;                pre_last2=last2;                if(level==0){                    ans.push_back(temp);                    temp.clear();                    level=1;                }                else{                    ans.push_back(temp);                    temp.clear();                    level=1-level;                }            }        }        return ans;    }</code></pre><h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p><img src="https://img-blog.csdnimg.cn/20200413200247524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">    int target;    bool flag=false;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {        if(root==NULL) return ans;        target=sum;        vector&lt;int&gt; temp;        temp.push_back(root-&gt;val);        dfs(root,0,temp);        return ans;    }    void dfs(TreeNode* root,int sum,vector&lt;int&gt;&amp; temp){        int cur_sum=sum+root-&gt;val;        //cout&lt;&lt;cur_sum&lt;&lt;endl;        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL){            if(sum+root-&gt;val==target){                ans.push_back(temp);                flag=true;                return ;            }        }            if(root-&gt;left){                temp.push_back(root-&gt;left-&gt;val);                dfs(root-&gt;left,cur_sum,temp);                temp.pop_back();            }            if(root-&gt;right){                temp.push_back(root-&gt;right-&gt;val);                dfs(root-&gt;right,cur_sum,temp);                temp.pop_back();            }    }</code></pre><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p><img src="https://img-blog.csdnimg.cn/20200413200600549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">public:    int maxh;    int maxPathSum(TreeNode* root) {        //if(root==NULL) return 0;        maxh=root-&gt;val;        max_path(root);        return maxh;    }    int max_path(TreeNode* root){        if(root==NULL) return 0;        int cur=root-&gt;val;        int l=max_path(root-&gt;left)+cur;        int r=max_path(root-&gt;right)+cur;        //cout&lt;&lt;&quot;root&quot;&lt;&lt;root-&gt;val&lt;&lt;endl;        //cout&lt;&lt;&quot;left:&quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;&quot;right&quot;&lt;&lt;r&lt;&lt;endl;        if(l&gt;maxh) maxh=l;        if(r&gt;maxh) maxh=r;        if(l+r-cur&gt;maxh) maxh=l+r-cur;        //加上这个是因为有的防止每次计算最大路径都必须包括叶结点(对于已经小于0的分支可以直接抛弃)        if(l&lt;0&amp;&amp;r&lt;0) return 0;        else return max(l,r);    }</code></pre><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><img src="https://img-blog.csdnimg.cn/20200413201038318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="cpp">/*两个节点p,q分为两种情况：p和q在相同子树中p和q在不同子树中从根节点遍历，递归向左右子树查询节点信息递归终止条件：如果当前节点为空或等于p或q，则返回当前节点递归遍历左右子树，如果左右子树查到节点都不为空，则表明p和q分别在左右子树中，因此，当前节点即为最近公共祖先；如果左右子树其中一个不为空，则返回非空节点。*/    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        if(root==NULL||root==p||root==q) return root;         TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q);        TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q);        if(left&amp;&amp;right) return root;        if(left==NULL) return right;        else return left;    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>max_element和min_element</title>
    <link href="/2020/04/13/max_element%E5%92%8Cmin_element/"/>
    <url>/2020/04/13/max_element%E5%92%8Cmin_element/</url>
    
    <content type="html"><![CDATA[<p>auto min_values=min_element(v.begin(),v.end())<br>auto max_values=max_element(v.begin(),v.end())<br>会分别返回一个指向输入序列的最小元素以及最大元素的迭代器(里面存的是对应的物理地址)；<br>1.取 * 可以去除具体的最大以及最小值<br>2.不取 * 减去起始地址就能知道索引的位置</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){int n[]={1,4,5,7,22,3,8,5};int len=sizeof(n)/sizeof(int);//返回索引cout&lt;&lt;max_element(n,n+len)-n&lt;&lt;endl;//返回值cout&lt;&lt;*max_element(n,n+len)&lt;&lt;endl;return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换函数(atoi系列&amp;&amp;stringstream)</title>
    <link href="/2020/04/13/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <url>/2020/04/13/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="atoi，atol，atof-amp-amp-c-str"><a href="#atoi，atol，atof-amp-amp-c-str" class="headerlink" title="(atoi，atol，atof)&amp;&amp;c_str()"></a>(atoi，atol，atof)&amp;&amp;c_str()</h2><p>atoi:  char* → int<br>atol: char* → long<br>atof: char* → double<br>注意要用c_str将string转化成c语言中的char*类型</p><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>具体来说就是C++标准库中的<sstream>提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，即单纯性、类型安全和可扩展性。在本文中，我将展示怎样使用这些库来实现安全和自动的类型转换。还有是如果你打算在多次转换中使用同一个stringstream对象，记住再每次转换前要使用clear()方法。下面就是我的一个小实验。</p><pre><code class="cpp">#include &quot;stdafx.h&quot;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;/************************************************************************//* 使用stringstream对象简化类型转换                                     *//*C++标准库中的&lt;sstream&gt;提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，     *//*即单纯性、类型安全和可扩展性。在本文中，我将展示怎样使用这些库来实现  *//*安全和自动的类型转换。                                                *//*如果你打算在多次转换中使用同一个stringstream对象，                    *//*记住再每次转换前要使用clear()方法；                                   *//************************************************************************/int _tmain(int argc, _TCHAR* argv[]){    //stringstream通常是用来做数据转换的。    //1.int 与 string的转换    std::stringstream m_sstream;    std::string result;    int i=1000;    m_sstream&lt;&lt;i;    m_sstream&gt;&gt;result;    std::cout&lt;&lt;result&lt;&lt;&quot;\n&quot;;     //2.int 与 char[]的转换    m_sstream.clear();    char res[8];    m_sstream&lt;&lt;8888;    m_sstream&gt;&gt;res;    std::cout&lt;&lt;res&lt;&lt;&quot;\n&quot;;     //3.string 与 int的转换(并且可以按照空格进行读取)    m_sstream.clear();    int first,second;    m_sstream&lt;&lt;&quot;666&quot;;    m_sstream&gt;&gt;first;    std::cout&lt;&lt;first&lt;&lt;std::endl;     //4.bool 与 int的转换    m_sstream.clear();    m_sstream&lt;&lt;true;    m_sstream&gt;&gt;second;    std::cout&lt;&lt;second&lt;&lt;std::endl;    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP模板</title>
    <link href="/2020/03/23/KMP%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/03/23/KMP%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>KMP是一种字符串匹配算法，可以求出一个字符串在另一个字符串中出现的次数。时间复杂度为O(N+M)</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>算法分为预处理next数组和查询两步进行。</p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>next数组表示从起始位置到当前位置最长的前缀和后缀的长度<br>那么，在处理时，我们就拿当前位置和原来匹配的最长前缀的后一位比较：</p><p>如果相同，那么长度+1,next[j−1]+1</p><p>如果不相同，那么根据此数组的性质，显而易见，你的相等的部分只能向前找也就是说，你的这个位置的next值会减小也就是去原来的最长相等前缀去找<br>所以，我们可以得到next数组的求解方法：每一次检查上一次最长前缀的后一个位置如果相等则next[j]=next[i]+1,否则令i=next[i−1]+1，继续循环匹配<br>其实这就是自己匹配自己的过程。这是最难理解的地方，多手算几遍就好了</p><h3 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h3><p>本算法难在于next预处理，如果你已经懂了，就很简单了<br>我们设定两个指针i，j，指向两个字符串。<br>如果i==j那么i++，j++如果失配，就令i=next[i−1]+1</p><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;char str1[1000005],str2[1000005];//str1是被匹配字符串，str2是匹配字符串int Next[1000005];vector &lt;int&gt; Ans;inline void init(char *str){ //计算next数组    int len,t;    len = strlen(str);    Next[0] = -1;    for(int i = 1;i &lt; len;i++){        t = Next[i-1];        while(str[t+1] != str[i] &amp;&amp; t &gt;= 0)            t = Next[t];        if(str[t+1] == str[i])            Next[i] = t+1;        else            Next[i] = -1;    }}void kmp(char *str1,char *str2){ //kmp查找    init(str2);    int len1 = strlen(str1);    int len2 = strlen(str2);    int i = 0,j = 0;    while(j &lt; len1){        if(str2[i] == str1[j]){  //相同            i++;j++;            if(i == len2){                Ans.push_back(j-len2+1);                i = Next[i-1]+1;            }        }        else{  //失配，根据next数组寻找下一个位置            if(i == 0)                j++;            else                i = Next[i-1] + 1;        }    }}int main(){    cin &gt;&gt; str1 &gt;&gt; str2;    int l = strlen(str2);    kmp(str1,str2);    for(int i = 0;i &lt; Ans.size();i++)        printf(&quot;%d%c&quot;,Ans[i],&#39;\n&#39;);    for(int i = 0;i &lt; l;i++){ //洛谷题目需要的输出next数组        printf(&quot;%d &quot;,Next[i] + 1);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>KMP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs技巧与优化</title>
    <link href="/2020/03/21/%E6%B7%B1%E6%90%9C%E6%8A%80%E5%B7%A7%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2020/03/21/%E6%B7%B1%E6%90%9C%E6%8A%80%E5%B7%A7%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一-DFS的实现"><a href="#一-DFS的实现" class="headerlink" title="一. DFS的实现"></a>一. DFS的实现</h1><pre><code class="cpp">int dfs(int t){    if(满足输出条件) //dfs出口    {        输出解;    }    else    {        for(int i=1;i&lt;=尝试方法数;i++)            if(满足进一步搜索条件)            {                为进一步搜索所需要的状态打上标记; //记忆化                dfs(t+1);                恢复到打标记前的状态; //也就是说：回溯一步            }    }}</code></pre><p><strong>【需要注意的地方】</strong><br>1.第一个if是符合输出解的条件，第二个if是符合进一步搜索的条件。</p><p>2.下一步搜索时，不是使用return search(t+1)，直接search(t+1)。</p><p>3.for循环之后的if可以是多个。</p><p>4.for循环边界，例如：</p><p>方向是四个，那么边界肯定就是4；（注意，数组一般从0开始）<br>素数环需要尝试1至20，那么边界就是20。</p><h1 id="二-剪枝技巧的实现"><a href="#二-剪枝技巧的实现" class="headerlink" title="二. 剪枝技巧的实现"></a>二. 剪枝技巧的实现</h1><h2 id="1-可行性剪枝。"><a href="#1-可行性剪枝。" class="headerlink" title="1.可行性剪枝。"></a>1.可行性剪枝。</h2><p>如果当前条件不合法就不再继续搜索，直接return。又称“上下界剪枝”，一般的搜索都会加上。</p><pre><code class="cpp">dfs(int x){    if(x&gt;n)return;    if(!check1(x))return;    ....    return;}</code></pre><h2 id="2-最优性剪枝。"><a href="#2-最优性剪枝。" class="headerlink" title="2.最优性剪枝。"></a>2.最优性剪枝。</h2><p> 如果当前条件所花费的代价已经超过了当前搜到的最优解，那么剩下的搜索就可以剪掉。</p><p>我们利用某个函数估计出此时条件下答案的当前最值，继续下一步判断。</p><pre><code class="cpp">long long ans=987474477434487ll;... Dfs(int x,...){    if(x... &amp;&amp; ...){ ans=....; return ...;}    if(check2(x)&gt;=ans) return ...;    //最优性剪枝     for(int i=1;...;++i){        vis[...]=1;         dfs(...);        vis[...]=0;    }}</code></pre><p>一般实现：在搜索取和最大值时，如果后面的全部取最大仍然不比当前答案大就可以返回。</p><p>在搜和最小时同理，可以预处理后缀最大/最小和进行快速查询。</p><h2 id="3-记忆化搜索。"><a href="#3-记忆化搜索。" class="headerlink" title="3.记忆化搜索。"></a>3.记忆化搜索。</h2><p>如果对于相同情况下必定答案相同，就可以把这个情况的答案值存储下来，以后再次搜到可以直接调用。</p><p>注意不能搜出环来，不同情况间不能互相依赖。或者是排除等效冗余的情况。</p><pre><code class="cpp">long long ans=987474477434487ll;... Dfs(int x,...){        if(x... &amp;&amp; ...){ ans=....; return ...;}        if(vis[x]!=0) return f[x]; vis[x]=1; //记忆化剪枝        for(int i=1;...;++i){            vis[...]=1;             dfs(...);            vis[...]=0;            f[x]=...;        }}</code></pre><h2 id="4-搜索顺序剪枝"><a href="#4-搜索顺序剪枝" class="headerlink" title="4.搜索顺序剪枝"></a>4.搜索顺序剪枝</h2><p>在一些迷宫题，网格题，或者其他搜索中可以贪心的题，搜索顺序显得十分重要。</p><p>在迷宫、网格类的题目中，以左上-&gt;右下为例，右下左上就明显比左上右下优秀。</p><p>在一些推断搜索题中，从已知信息最多的地方开始搜索显然更加优秀。</p><p>在一些题中，先搜某个值大的，再搜某个值小的(比如树的度数，产生答案的预计(A*))，速度明显更快。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="codevs1288-埃及分数"><a href="#codevs1288-埃及分数" class="headerlink" title="codevs1288 埃及分数"></a>codevs1288 埃及分数</h2><p>在古埃及，人们使用单位分数的和(形如1/a的, a是自然数)表示一切有理数。</p><p>如：2/3=1/2+1/6,但不允许2/3=1/3+1/3,因为加数中有相同的。</p><p>对于一个分数a/b,表示方法有很多种，但是哪种最好呢？</p><p>首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越 好。</p><p>如：19/45=1/3 + 1/12 + 1/180 19/45=1/3 + 1/15 + 1/45 19/45=1/3 + 1/18 + 1/30,</p><p>19/45=1/4 + 1/6 + 1/180 19/45=1/5 + 1/6 + 1/18. 最好的是最后一种，因为1/18最大。</p><p>给出a,b(0&lt;a&lt;b&lt;1000),编程计算最好的表达方式。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define LL long long intusing namespace std;LL a,b,depth,FLAG=1,zZ[101010],Ans[101010],Maxx=10101000;LL gcd(LL a,LL b){return b&gt;0?gcd(b,a%b):a;} //辗转相除法求最大公约数 void dfs(LL now,LL a,LL b,LL last,LL depth){    if(now==depth-1){        if(a!=1)return;        if(b&lt;Maxx &amp;&amp; b&gt;last){                zZ[now+1]=b;FLAG=0;Maxx=b;                for(LL i=1;i&lt;=now+1;++i){Ans[i]=zZ[i];}        }        return;    }    if(a*(last+1)&gt;=b*(depth-now) || last&gt;Maxx || a==0)return; //第一个是可行性剪枝，是个十字相乘式，建议移项看    for(LL i=last+1,K=(depth-now)*b/a;i&lt;K;++i)    {        LL newa=a*i-b,newb=b*i,G=gcd(newb,newa);        newa/=G,newb/=G;zZ[now+1]=i;        dfs(now+1,newa,newb,i,depth);zZ[now+1]=0;    }}int main() {    scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);    if(a==1){printf(&quot;%lld&quot;,b);return 0;}    for(int i=2;FLAG;++i)dfs(0,a,b,(b/a),i);                        //迭代搜索，i为深度     for(int i=1;Ans[i]!=0;++i)printf(&quot;%lld &quot;,Ans[i]);    return 0;}</code></pre><p>这道题可行性和最优性剪枝都要加，最后一个是因为要除a，是零就得剪掉。搜索顺序是按分母从小到大枚举的。</p><h2 id="poj1011-Sticks"><a href="#poj1011-Sticks" class="headerlink" title="poj1011 Sticks"></a>poj1011 Sticks</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;/*【Sticks】题意：给出n根小棒的长度stick[i]，已知这n根小棒原本由若干根长度相同的长木棒（原棒）分解而来。求出原棒的最小可能长度。思路：dfs+剪枝。蛮经典的题目，重点在于dfs剪枝的设计。先说先具体的实现：求出总长度sum和小棒最长的长度max，则原棒可能的长度必在max~sum之间，然后从小到大枚举max~sum之间能被sum整除的长度len，用dfs求出所有的小棒能否拼凑成这个长度，如果可以，第一个len就是答案。下面就是关键的了，就是这道题dfs的实现和剪枝的设计：1.以一个小棒为开头，用dfs看看能否把这个小棒拼凑成len长，用vis[i]记录下用过的小棒，然后继续以另外一个小棒为开头，以此类推。2.小棒的长度从大到小排序。3.如果当前最长的小棒不能拼成len长，那么就返回前一步,不用再继续搜索这一种情况。4.最重要的，就是比如说17,9,9,9,9,8,8,5,2……17与第一个9组合之后dfs发现不能拼成len，那么17就不和后面9组合了，而直接和8开始组合。  */const int Max = 65;int n, len, stick[Max];bool flag, vis[Max];bool cmp(int a,int b) { return a&gt;b; }void dfs(int dep, int now_len, int u){   // dep为当前已被用过的小棒数，u为当前要处理的小棒。    if(flag) return;    if(now_len == 0){   //  当前长度为0，寻找下一个当前最长小棒。        int k = 0;        while(vis[k]) k ++;  //  寻找第一个当前最长小棒。        vis[k] = true;        dfs(dep + 1, stick[k], k + 1);        vis[k] = false;        return;    }    if(now_len == len){  //  当前长度为len，即又拼凑成了一根原棒。        if(dep == n) flag = true;   //  完成的标志：所有的n根小棒都有拼到了。        else dfs(dep, 0, 0);        return;    }    for(int i = u; i &lt; n; i ++)        if(!vis[i] &amp;&amp; now_len + stick[i] &lt;= len){            if(!vis[i-1] &amp;&amp; stick[i] == stick[i-1]) continue;  //  不重复搜索：最重要的剪枝。            vis[i] = true;            dfs(dep + 1, now_len + stick[i], i + 1);            vis[i] = false;        }}int main(){    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n != 0){        int sum = 0;        flag = false;        for(int i = 0; i &lt; n; i ++){            scanf(&quot;%d&quot;, &amp;stick[i]);            sum += stick[i];        }        sort(stick,stick+n,cmp); //从大到小排序。        for(len = stick[0]; len &lt; sum; len ++)            if(sum % len == 0){  //  枚举能被sum整除的长度。                memset(vis, 0, sizeof(vis));                dfs(0, 0, 0);                if(flag) break;            }        printf(&quot;%d\n&quot;, len);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>dfs优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中缀转后缀与后缀表达式计算</title>
    <link href="/2020/03/12/%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/03/12/%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="中缀表达式直接计算-带括号"><a href="#中缀表达式直接计算-带括号" class="headerlink" title="中缀表达式直接计算(带括号)"></a>中缀表达式直接计算(带括号)</h2><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;//中缀表达式求值string mid;stack&lt;double&gt; data_stack;stack&lt;char&gt; op_stack;int Priority(char op){    if(op==&#39;+&#39;||op==&#39;-&#39;) return 1;    else if(op==&#39;*&#39;||op==&#39;/&#39;) return 2;    else if(op==&#39;(&#39;) return 0;//注意}double Calculate(double a,double b,char op){    if(op==&#39;+&#39;) return a+b;    else if(op==&#39;-&#39;) return a-b;    else if(op==&#39;*&#39;) return a*b;    else if(op==&#39;/&#39;) return a/b;}double getNumber(string str,int&amp; pos){//pos是共享的    double ans=0.0;    while(isdigit(str[pos])){        ans=ans*10+(double)(str[pos++]-&#39;0&#39;);    }    pos--;    return ans;}//1+2*3int main(){    cin&gt;&gt;mid;    for(int i=0;i&lt;mid.size();i++){        if(isdigit(mid[i])){            //cout&lt;&lt;(double)(mid[i]-&#39;0&#39;)&lt;&lt;endl;            //cout&lt;&lt;&quot;data &quot;&lt;&lt;data_stack.size()&lt;&lt;endl;            double number=getNumber(mid,i);            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;number&lt;&lt;endl;            data_stack.push(number);        }        else if(mid[i]==&#39;(&#39;){            op_stack.push(mid[i]);        }        else if(mid[i]==&#39;)&#39;){            while(op_stack.top()!=&#39;(&#39;){                char op=op_stack.top();  op_stack.pop();                double b=data_stack.top(); data_stack.pop();                double a=data_stack.top(); data_stack.pop();                double temp=Calculate(a,b,op);                data_stack.push(temp);            }            op_stack.pop();        }        else{            //cout&lt;&lt;&quot;op &quot;&lt;&lt;mid[i]&lt;&lt;endl;            while((!op_stack.empty())&amp;&amp;Priority(op_stack.top())&gt;=Priority(mid[i])){//顺序不能变，一定是先判栈空                char op=op_stack.top();  op_stack.pop();                double b=data_stack.top(); data_stack.pop();                double a=data_stack.top(); data_stack.pop();                double temp=Calculate(a,b,op);                //cout&lt;&lt;a&lt;&lt;op&lt;&lt;b&lt;&lt;&quot;结果&quot;&lt;&lt;temp&lt;&lt;endl;                data_stack.push(temp);            }            op_stack.push(mid[i]);        }    }    while(!op_stack.empty()){//别忘了将op清空        char op=op_stack.top();  op_stack.pop();        double b=data_stack.top(); data_stack.pop();        double a=data_stack.top(); data_stack.pop();        double temp=Calculate(a,b,op);        data_stack.push(temp);    }    cout&lt;&lt;data_stack.top()&lt;&lt;endl;}</code></pre><h2 id="中缀转后缀与后缀表达式计算-带括号"><a href="#中缀转后缀与后缀表达式计算-带括号" class="headerlink" title="中缀转后缀与后缀表达式计算(带括号)"></a>中缀转后缀与后缀表达式计算(带括号)</h2><p>PS:后缀表达式中两两之间一定要用空格隔开，不然getNumber函数就不起作用了</p><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;//中缀转后缀+后缀求值string post=&quot;&quot;,mid;stack&lt;char&gt; op_stack;stack&lt;double&gt; data_stack;int Priority(char op){    if(op==&#39;+&#39;||op==&#39;-&#39;) return 1;    else if(op==&#39;*&#39;||op==&#39;/&#39;) return 2;    else if(op==&#39;(&#39;) return 0;}double Calculate(double a,double b,char op){    if(op==&#39;+&#39;) return a+b;    else if(op==&#39;-&#39;) return a-b;    else if(op==&#39;*&#39;) return a*b;    else if(op==&#39;/&#39;) return a/b;}double getNumber(string str,int&amp; pos){//pos是共享的    double ans=0.0;    while(isdigit(str[pos])){        ans=ans*10+(double)(str[pos++]-&#39;0&#39;);    }    pos--;//不然会越过一个位置    return ans;}//9+(3-1)*3+10/2，转换的话不会用到getnumber得到多位的整数void Transform(){    for(int i=0;i&lt;mid.size();i++){        //cout&lt;&lt;post&lt;&lt;endl;        if(isdigit(mid[i])){//这里得到完整数直接写就行!!!            while(isdigit(mid[i])){                post=post+mid[i++];            }            i--;//不然会把下一个覆盖掉            post=post+&quot; &quot;;        }        else if(mid[i]==&#39; &#39;){            continue;        }        else if(mid[i]==&#39;(&#39;){            op_stack.push(mid[i]);        }        else if(mid[i]==&#39;)&#39;){            while(op_stack.top()!=&#39;(&#39;){                char op=op_stack.top();                op_stack.pop();                post=post+op+&quot; &quot;;            }            op_stack.pop();//将&#39;(&#39;pop出来        }        else{//为操作符            //cout&lt;&lt;&quot;操作符 &quot;&lt;&lt;mid[i]&lt;&lt;endl;            if(op_stack.empty()){                op_stack.push(mid[i]);                continue;            }            else{                //别忘了判栈空                while(!op_stack.empty()&amp;&amp;Priority(op_stack.top())&gt;=Priority(mid[i])){                    //cout&lt;&lt;op_stack.top()&lt;&lt;&quot;pop 出来&quot;&lt;&lt;endl;                    char op=op_stack.top();                    op_stack.pop();                    post=post+op+&quot; &quot;;                }                op_stack.push(mid[i]);            }        }    }    while(!op_stack.empty()){        char op=op_stack.top();        op_stack.pop();        post=post+op;    }}int  main(){    cin&gt;&gt;mid;    Transform();    cout&lt;&lt;&quot;后缀表达式:&quot;&lt;&lt;post&lt;&lt;endl;    for(int pos=0;pos&lt;post.size();pos++){        if(isdigit(post[pos])){            double number=getNumber(post,pos);            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;number;            data_stack.push(number);        }        else if(post[pos]==&#39; &#39;) continue;        else{            char op=post[pos];            double b=data_stack.top(); data_stack.pop();            double a=data_stack.top(); data_stack.pop();            double temp=Calculate(a,b,op);            //cout&lt;&lt;&quot;运算后 &quot;&lt;&lt;temp&lt;&lt;endl;            data_stack.push(temp);        }    }    cout&lt;&lt;&quot;运算结果:&quot;&lt;&lt;data_stack.top()&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>中缀后缀表达式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>中缀后缀表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形数据结构总结</title>
    <link href="/2020/03/11/%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/11/%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前序-中序-后序知二推一"><a href="#前序-中序-后序知二推一" class="headerlink" title="前序,中序,后序知二推一"></a>前序,中序,后序知二推一</h1><h2 id="求先序序列"><a href="#求先序序列" class="headerlink" title="求先序序列"></a>求先序序列</h2><p><strong>题目描述</strong><br>给出一棵二叉树的中序与后序排列,求出它的先序排列，(约定树结点用不同的大写字母表示,长度≤8)。</p><p><strong>输入格式</strong><br>2行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。</p><p><strong>输出格式</strong><br>1行，表示一棵二叉树的先序。</p><p><strong>输入</strong></p><blockquote><p>BADC<br>BDCA</p></blockquote><p><strong>输出</strong></p><blockquote><p>ABCD</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string in;string post;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};TreeNode* Tree[10000];TreeNode* CreatTree(int s1,int t1,int s2,int t2){    char c=post[t1];//后序的最后一个    if(s1==t1){//叶子结点        Tree[c-&#39;A&#39;]=new TreeNode(c);        return Tree[c-&#39;A&#39;];    }    Tree[c-&#39;A&#39;]=new TreeNode(c);    int pos=in.find(c);//在中序中找到对应的顶点以及左右长度    int llen=pos-s2;    int rlen=t2-pos;    //别忘了判左右长度    if(llen) Tree[c-&#39;A&#39;]-&gt;left=CreatTree(s1,s1+llen-1,s2,s2+llen-1);    if(rlen) Tree[c-&#39;A&#39;]-&gt;right=CreatTree(s1+llen,t1-1,s2+llen+1,t2);    return Tree[c-&#39;A&#39;];}void PreOrder(TreeNode* root){    if(root==NULL) return ;    cout&lt;&lt;root-&gt;data;    PreOrder(root-&gt;left);    PreOrder(root-&gt;right);}int main(){    cin&gt;&gt;in&gt;&gt;post;    TreeNode* root=CreatTree(0,post.size()-1,0,in.size()-1);    PreOrder(root);}</code></pre><h2 id="求可能中序序列"><a href="#求可能中序序列" class="headerlink" title="求可能中序序列"></a>求可能中序序列</h2><p><strong>题目描述</strong><br>已知前序和后序遍历的结果求出一种可能得中序遍历的结果,二叉树的结点名以大写字母(A,B,C…)表示，最多26个结点<br><strong>输入格式</strong><br>第一行为前序遍历结果<br>第二行为后序遍历结果<br><strong>输出格式</strong><br>一个字符串，表示一个可能的中序遍历<br><strong>输入</strong></p><blockquote><p>ABDCE<br>DBECA</p></blockquote><p><strong>输出</strong></p><blockquote><p>DBAEC</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string pre,post;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};TreeNode* PrePostCreat(string pre,string post){    TreeNode* root=new TreeNode(pre[0]);    if(pre.size()==0) return NULL;//返回    int pos=post.find(pre[1]);//先序顶点在后序的位置//    cout&lt;&lt;pre.substr(1,pos+1)&lt;&lt;&quot;   &quot;&lt;&lt;post.substr(0,pos+1)&lt;&lt;endl;//    cout&lt;&lt;pre.substr(pos+2)&lt;&lt;&quot;   &quot;&lt;&lt;post.substr(pos+1,post.size()-pos-2)&lt;&lt;endl;    root-&gt;left=PrePostCreat(pre.substr(1,pos+1),post.substr(0,pos+1));    root-&gt;right=PrePostCreat(pre.substr(pos+2),post.substr(pos+1,post.size()-pos-2));    return root;}void InOrder(TreeNode* T){    if(T==NULL) return ;    InOrder(T-&gt;left);    cout&lt;&lt;T-&gt;data;    InOrder(T-&gt;right);}int main(){    cin&gt;&gt;pre&gt;&gt;post;    TreeNode* root=PrePostCreat(pre,post);    InOrder(root);}</code></pre><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="构造二叉排序树"><a href="#构造二叉排序树" class="headerlink" title="构造二叉排序树"></a>构造二叉排序树</h2><p><strong>题目描述</strong><br>已知二叉排序树用二叉链表存储，结点的关键字为 1正整数。从键盘输入结点的关键字（以 0表示结束）建立一棵二叉排序树，并输出其后序遍历序列</p><pre><code class="clike">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;struct TreeNode{    int data;    TreeNode* left;    TreeNode* right;    TreeNode(int data):data(data),left(NULL),right(NULL){}};//x插入到以root为根结点的排序树中，从根结点不断的向下比TreeNode* Insert(TreeNode* root,int n){    if(root==NULL) root=new TreeNode(n);    else if(n&lt;root-&gt;data) root-&gt;left=Insert(root-&gt;left,n);    else if(n&gt;root-&gt;data) root-&gt;right=Insert(root-&gt;right,n);    return root;}void PostOrder(TreeNode* root){    if(root==NULL) return  ;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;}int main(){    int n;    TreeNode* root=NULL;    while(cin&gt;&gt;n){        if(n==0) break;        else root=Insert(root,n);    }    PostOrder(root);}</code></pre><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><strong>题目描述</strong><br>判断两序列是否为同一二叉搜索树序列</p><p><strong>输入描述:</strong><br>开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。<br><strong>输出描述:</strong><br>如果序列相同则输出YES，否则输出NO</p><p><strong>输入</strong></p><blockquote><p>2<br>567432<br>543267<br>576342`<br>0</p></blockquote><p>输出</p><blockquote><p>YES<br>NO</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;//前序遍历和中序遍历可以唯一确定一棵二叉树，//而对二叉排序树而言，相同元素的二叉排序树中//序遍历一定相同，而不同元素二叉排序树使用前//序遍历就可以发现不相同，所以只需要前序遍历//两个二叉树，比较一下就可以判断using namespace std;string pre,in;struct TreeNode{    char data;    TreeNode* leftchild;    TreeNode* rightchild;    TreeNode(char c):data(c),leftchild(NULL),rightchild(NULL){}};TreeNode* Insert(TreeNode* root,char x){    if(root==NULL){        root=new TreeNode(x);    }    else if(x&lt;root-&gt;data){        root-&gt;leftchild=Insert(root-&gt;leftchild,x);    }    else if(x&gt;root-&gt;data){        root-&gt;rightchild=Insert(root-&gt;rightchild,x);    }    return root;}string preorder(TreeNode* root){    if(root==NULL) return &quot;#&quot;;    return root-&gt;data+preorder(root-&gt;leftchild)+preorder(root-&gt;rightchild);}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        string s; TreeNode* root=NULL;        cin&gt;&gt;s;        //构建初始的排序树        for(int i=0;i&lt;s.size();i++){            root=Insert(root,s[i]);        }        string pre=preorder(root);        //构建用来比较的排序树        for(int i=0;i&lt;n;i++){            string str; TreeNode* T=NULL;            cin&gt;&gt;str;            for(int j=0;j&lt;str.size();j++){                T=Insert(T,str[j]);            }            string pre1=preorder(T);        //进行比较            if(pre1==pre) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre><h2 id="二叉排序树最大路径"><a href="#二叉排序树最大路径" class="headerlink" title="二叉排序树最大路径"></a>二叉排序树最大路径</h2><p><strong>题目描述</strong><br>求二叉排序树中的最大路径</p><p><strong>输入</strong></p><blockquote><p>16<br>30 45 2 69 36 14 52 23 31 90 57 32 33 34 91 92</p></blockquote><p><strong>输出</strong></p><blockquote><p>11</p></blockquote><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;struct TreeNode{    int data;    TreeNode* left;    TreeNode* right;    TreeNode(int data):data(data),left(NULL),right(NULL){}};int Max=0;int a[100];//测试数据//30 45 2 69 36 14 52 23 31 90 57 32 33 34 91 92TreeNode* CreatTree(TreeNode* root,int data){    if(root==NULL){        TreeNode* T=new TreeNode(data);        return T;    }    if(data&lt;root-&gt;data) root-&gt;left=CreatTree(root-&gt;left,data);    else if(data&gt;root-&gt;data) root-&gt;right=CreatTree(root-&gt;right,data);    return root;}int MaxPath(TreeNode* root){    if(root==NULL) return 0;    int lh,rh,sum;    //包括自己在内的长度    lh=MaxPath(root-&gt;left)+1;    rh=MaxPath(root-&gt;right)+1;    //cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;lh&lt;&lt;&quot; &quot;&lt;&lt;rh&lt;&lt;endl;    sum=lh+rh-1;    Max=max(Max,sum);    return lh&gt;rh?lh:rh;}void PreOrder(TreeNode* T){    if(T==NULL) return ;    cout&lt;&lt;T-&gt;data;    PreOrder(T-&gt;left);    PreOrder(T-&gt;right);}int main(){    int n;    cin&gt;&gt;n;    TreeNode* root=NULL;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];        root=CreatTree(root,a[i]);    }    MaxPath(root);    cout&lt;&lt;endl;    cout&lt;&lt;Max;}</code></pre><h1 id="huffman树"><a href="#huffman树" class="headerlink" title="huffman树"></a>huffman树</h1><h2 id="huffman编码"><a href="#huffman编码" class="headerlink" title="huffman编码"></a>huffman编码</h2><p><strong>题目描述</strong><br>哈弗曼树问题：在”7.in”中<br>有几个数，和为1，进行哈弗曼编码，并把编码结果输出到”7.out”中。</p><p><strong>输入</strong></p><blockquote><p>0.1 0.15 0.2 0.25 0.3</p></blockquote><p><strong>输出</strong></p><blockquote><p>000<br>001<br>01<br>10<br>11</p></blockquote><p>PS:这道题我写了特别久，主要是优先队列存指针的问题，西八，太难了。</p><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;const int eps=1e-6;struct HfNode{    double weight;    HfNode* left;    HfNode* right;    string code;    HfNode(double weight):weight(weight),left(NULL),right(NULL),code(&quot;&quot;){}    bool operator &gt;(const HfNode&amp; e)const{        return weight&gt;e.weight;    }};HfNode* Tree[10000];void Huffman(HfNode* T){//遍历huffman树设编码    //cout&lt;&lt;T.code&lt;&lt;endl;    if(T-&gt;left!=NULL) {T-&gt;left-&gt;code=T-&gt;code+&quot;1&quot;;  Huffman(T-&gt;left);}    if(T-&gt;right!=NULL) {T-&gt;right-&gt;code=T-&gt;code+&quot;0&quot;;  Huffman(T-&gt;right);}    if(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL) cout&lt;&lt;T-&gt;weight&lt;&lt;&quot; &quot;&lt;&lt;T-&gt;code&lt;&lt;endl;//叶子结点    return ;}//重要：std::priority_queue 存放的是自定义类型的指针时,解决方法是使用Compare//类似于sort中定义的cmpclass Compare{public:    bool operator () (HfNode* &amp;a,HfNode* &amp;b) const{        return a-&gt;weight&gt;b-&gt;weight;    }};int main(){    priority_queue &lt;HfNode*,vector&lt;HfNode*&gt;,Compare &gt; q;    ifstream infile(&quot;in.txt&quot;);    double n; string s;    getline(infile,s);    stringstream in(s);//这个在double会出现问题    while(in&gt;&gt;n){        HfNode* node=new HfNode(n);//在前面加new返回指针，不加new就是node的类型        q.push(node);    }    int point;    while(q.size()&gt;1){//建huffman树        //分配空间        HfNode* a=(HfNode*)malloc(sizeof(HfNode));        HfNode* b=(HfNode*)malloc(sizeof(HfNode));        HfNode* c=(HfNode*)malloc(sizeof(HfNode));        a=q.top(); q.pop();        b=q.top(); q.pop();        double x=a-&gt;weight+b-&gt;weight;        c=new HfNode(x);        c-&gt;left=a; c-&gt;right=b;        //cout&lt;&lt;c-&gt;left-&gt;weight&lt;&lt;&quot; &quot;&lt;&lt;c-&gt;right-&gt;weight&lt;&lt;endl;        q.push(c);    }    Huffman(q.top());}</code></pre><h1 id="其余题型"><a href="#其余题型" class="headerlink" title="其余题型"></a>其余题型</h1><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p><strong>题目描述</strong><br>输出树的层次遍历的奇数层的所有结点。<br><strong>输入</strong></p><blockquote><p>A B C<br>B E<br>C F G</p></blockquote><p><strong>输出</strong></p><blockquote><p>第 1 层结点：A<br>第 3 层结点：E,F,G</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#include&lt;queue&gt;using namespace std;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    int deep;    TreeNode(char data,int deep):data(data),deep(deep),left(NULL),right(NULL){}};const int MAXN=100;TreeNode* Tree[MAXN];//建树时一定要用这个，方便用内容去找到结点;vector&lt;char&gt; v;void Level_Order(TreeNode* T){    queue&lt;TreeNode*&gt; q;    q.push(T);    while(!q.empty()){        TreeNode* p=q.front();        q.pop();        if(p-&gt;deep%2==1) cout&lt;&lt;&quot;第&quot;&lt;&lt;p-&gt;deep&lt;&lt;&quot;层:&quot;&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;endl;        if(p-&gt;left){            q.push(p-&gt;left);        }        if(p-&gt;right){            q.push(p-&gt;right);        }    }}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    int i=1;    while(getline(infile,s)){        v.clear();        char c;        stringstream in(s);        while(in&gt;&gt;c){            v.push_back(c);        }        if(!Tree[v[0]-&#39;A&#39;]) Tree[v[0]-&#39;A&#39;]=new TreeNode(v[0],1);        int deep=Tree[v[0]-&#39;A&#39;]-&gt;deep;        for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]-&#39;A&#39;&lt;&lt;&quot; &quot;&lt;&lt;endl;        if(v.size()==3){//参照这样的方法建树            if(!Tree[v[1]-&#39;A&#39;]){//可以这样判断数组该处有没有值                Tree[v[1]-&#39;A&#39;]=new TreeNode(v[1],deep+1);            }            if(!Tree[v[2]-&#39;A&#39;]){                Tree[v[2]-&#39;A&#39;]=new TreeNode(v[2],deep+1);            }            Tree[v[0]-&#39;A&#39;]-&gt;left=Tree[v[1]-&#39;A&#39;];            Tree[v[0]-&#39;A&#39;]-&gt;right=Tree[v[2]-&#39;A&#39;];        }        else if(v.size()==2){            if(!Tree[v[1]-&#39;A&#39;]){                Tree[v[1]-&#39;A&#39;]=new TreeNode(v[1],deep+1);            }            Tree[v[0]-&#39;A&#39;]-&gt;left=Tree[v[1]-&#39;A&#39;];        }        i++;    }    Level_Order(Tree[0]);    //cout&lt;&lt;Tree[0]-&gt;left-&gt;left-&gt;data&lt;&lt;endl;//用这种方法来测试树是否建立成功}</code></pre><h2 id="FBI树"><a href="#FBI树" class="headerlink" title="FBI树"></a>FBI树</h2><p><strong>题目描述</strong><br>我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。FBI树是一种二叉树，它的结点类型也包括FF结点，BB结点和I结点三种。由一个长度为 2 ^N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：</p><ol><li>T的根结点为R，其类型与串S的类型相同；</li><li>若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。</li></ol><p>现在给定一个长度为2^N 的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。</p><p><strong>输入格式</strong><br>第一行是一个整数N(0≤N≤10)，</p><p>第二行是一个长度为2^N的“01”串。</p><p><strong>输出格式</strong><br>一个字符串，即FBI树的后序遍历序列。</p><p><strong>输入</strong></p><blockquote><p>3<br>10001011</p></blockquote><p><strong>输出</strong></p><blockquote><p>IBFBBBFIBFIIIFF</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;int n;string str;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};TreeNode* Tree[100000];int p=0;TreeNode* CreatTree(int Start,int End){    string s=str.substr(Start,End-Start+1);    //cout&lt;&lt;s&lt;&lt;endl;    TreeNode* T=(TreeNode*)malloc(sizeof(TreeNode*));//为了防止指针被覆盖    if(s.find(&quot;0&quot;)!=string::npos&amp;&amp;s.find(&quot;1&quot;)!=string::npos){        //cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;&quot;F&quot;&lt;&lt;endl;        Tree[p]=new TreeNode(&#39;F&#39;);        T=Tree[p];    }    else if(s.find(&quot;0&quot;)!=string::npos&amp;&amp;s.find(&quot;1&quot;)==string::npos){        //cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;&quot;B&quot;&lt;&lt;endl;        Tree[p]=new TreeNode(&#39;B&#39;);        T=Tree[p];    }    else if(s.find(&quot;0&quot;)==string::npos&amp;&amp;s.find(&quot;1&quot;)!=string::npos){        //cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;&quot;I&quot;&lt;&lt;endl;        Tree[p]=new TreeNode(&#39;I&#39;);        T=Tree[p];    }    p++;    if(s.size()==1){        return T;    }    else{        T-&gt;left=CreatTree(Start,Start+(End-Start)/2);        T-&gt;right=CreatTree(End-(End-Start)/2,End);    }    return T;}void PostOrder(TreeNode* root){    if(root==NULL) return ;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=pow(2,n);i++){        char c;        cin&gt;&gt;c;        str=str+c;    }    //cout&lt;&lt;str&lt;&lt;endl;    TreeNode* root=CreatTree(0,str.size()-1);    PostOrder(Tree[0]);}</code></pre><h2 id="新二叉树"><a href="#新二叉树" class="headerlink" title="新二叉树"></a>新二叉树</h2><p><strong>题目描述</strong><br>输入一串二叉树，输出其前序遍历。</p><p><strong>输入格式</strong><br>第一行为二叉树的节点数 n。(1≤n≤26)<br>后面 n 行，每一个字母为节点，后两个字母分别为其左右儿子。空节点用 * 表示</p><p><strong>输出格式</strong><br>二叉树的前序遍历。</p><p><strong>输入</strong></p><blockquote><p>6<br>abc<br>bdi<br>cj*<br>d**<br>i**<br>j**</p></blockquote><p><strong>输出</strong></p><blockquote><p>abdicj</p></blockquote><pre><code class="clike">#include&lt;iostream&gt;using namespace std;int n;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){};};TreeNode* Tree[10000];void PreOrder(TreeNode* root){    if(root==NULL) return ;    cout&lt;&lt;root-&gt;data;    PreOrder(root-&gt;left);    PreOrder(root-&gt;right);}int main(){    cin&gt;&gt;n;    string s;    char T=0; int i=n;//因为Tree[0]不一定是根结点!!!!    while(n--){        cin&gt;&gt;s;        if(i==n+1) T=s[0];//记录根结点        //别忘了每一个结点都要判断是否已经存在        if(!Tree[s[0]-&#39;a&#39;]) Tree[s[0]-&#39;a&#39;]=new TreeNode(s[0]);        if(s[1]!=&#39;*&#39;){            if(!Tree[s[1]-&#39;a&#39;]) Tree[s[1]-&#39;a&#39;]=new TreeNode(s[1]);            Tree[s[0]-&#39;a&#39;]-&gt;left=Tree[s[1]-&#39;a&#39;];        }        if(s[2]!=&#39;*&#39;){            if(!Tree[s[2]-&#39;a&#39;]) Tree[s[2]-&#39;a&#39;]=new TreeNode(s[2]);            Tree[s[0]-&#39;a&#39;]-&gt;right=Tree[s[2]-&#39;a&#39;];        }    }    PreOrder(Tree[T-&#39;a&#39;]);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂最终总结</title>
    <link href="/2020/03/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="原理（两种理解）"><a href="#原理（两种理解）" class="headerlink" title="原理（两种理解）"></a>原理（两种理解）</h2><p><img src="https://img-blog.csdnimg.cn/20200309165655161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200309165758513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这jjj">)<img src="https://img-blog.csdnimg.cn/20200309170236327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309170526572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200309170609480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309170641994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309170705631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>题目描述</strong><br>给你三个整数 b,p,k,求 $b^p$mod k 。</p><p><strong>输入格式</strong><br>一行三个整数 b,p,kb,p,k</p><p><strong>输出格式</strong><br>输出 $b^p$ mod k=s<br>s 为运算结果</p><p><strong>输入</strong></p><blockquote><p>2 10 9</p></blockquote><p><strong>输出</strong></p><blockquote><p>2^10 mod 9=7</p></blockquote><pre><code class="clike">#include&lt;bits/stdc++.h&gt;using namespace std;long long QuickPower(long long base,long long n,long long k){    long long ans=1;    while(n!=0){        if(n&amp;1){            ans*=base;            ans%=k;        }        base*=base;        base%=k;        n&gt;&gt;=1;    }    return ans;}int main(){    long long base,n,k;    cin&gt;&gt;base&gt;&gt;n&gt;&gt;k;    //别忘了对最终的答案取模    printf(&quot;%lld^%lld mod %lld=%lld&quot;,base,n,k,QuickPower(base,n,k)%k);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>快速幂最终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_12</title>
    <link href="/2020/02/27/USTC%E6%9C%BA%E8%AF%95_12/"/>
    <url>/2020/02/27/USTC%E6%9C%BA%E8%AF%95_12/</url>
    
    <content type="html"><![CDATA[<p>1.字符串处理：从   string.in文件里读入两个字符串，字符串除了数字还可能包括    ‘—‘、’E’、’e’、’．’，相加之后输出到文件 string.out中，如果是浮点型，要求用科学计数法表示（最多包含 10个有效数字）。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;#include&lt;math.h&gt;using namespace std;int main(){    ifstream infile(&quot;in.txt&quot;);    string s1,s2;    double x,y;    getline(infile,s1);    getline(infile,s2);    if(s1.find(&#39;e&#39;)!=string::npos||s1.find(&#39;E&#39;)!=string::npos){        if(s1.find(&#39;e&#39;)!=string::npos){            int pos=s1.find(&#39;e&#39;);            double a=atof((char*)s1.substr(0,pos).data());//底数            double b=atof((char*)s1.substr(pos+1).data());//次数            x=a*pow(10,b);        }        else{            int pos=s1.find(&#39;E&#39;);            double a=atof((char*)s1.substr(0,pos).data());//底数            double b=atof((char*)s1.substr(pos+1).data());//次数            x=a*pow(10,b);        }    }    else{        x=atof((char*)s1.data());    }    if(s2.find(&#39;e&#39;)!=string::npos||s2.find(&#39;E&#39;)!=string::npos){        if(s2.find(&#39;e&#39;)!=string::npos){            int pos=s2.find(&#39;e&#39;);            double a=atof((char*)s2.substr(0,pos).data());//底数            double b=atof((char*)s2.substr(pos+1).data());//次数            y=a*pow(10,b);        }        else{            int pos=s2.find(&#39;e&#39;);            double a=atof((char*)s2.substr(0,pos).data());//底数            double b=atof((char*)s2.substr(pos+1).data());//次数            y=a*pow(10,b);        }    }    else{        y=atol((char*)s2.data());    }    printf(&quot;%e&quot;,x+y);    infile.close();}</code></pre><p>2.最大公约数：从    number.in文件中读入   n个数，求出这   n个数的最小值、最大值以及它们两的最大公约数，输出到文件 number.out中。number.in中第一行为     n，接下来为  n个大于零的整数。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;#include &lt;sstream&gt;using namespace std;const int MAXN=100;int a[MAXN];//若是最小公倍数则是两数乘积除以它们的最大公约数int gcd(int a,int b){//    if(b==0) return a;    else return gcd(b,a%b);}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    int n=atoi((char*)s.data());    getline(infile,s);    stringstream stringin(s);//实现按空格读取,需要导入sstream文件    int i=0;    while(stringin&gt;&gt;a[i]){        i++;    }    sort(a,a+n);    int Min=a[0],Max=a[n-1];    cout&lt;&lt;Min&lt;&lt;&quot; &quot;&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;gcd(Min,Max);}</code></pre><p>3.任务调度：从   task.in文件中读入任务调度序列，输出    n个任务适合的一种调度方式到 task.out中。每行第一个表示前序任务，括号中的任务为若干个后序任务，表示只有在前序任务完成的情况下，后序任务才能开始。若后序为 NULL则表示无后继任务。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];int indegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=0;i&lt;n;i++){        if(indegree[i]==0) q.push(i);    }    while(!q.empty()){        int T=q.top();        topology.push_back(T);        q.pop();        for(int i=0;i&lt;graph[T].size();i++){            int v=graph[T][i];            indegree[v]--;            if(indegree[v]==0) q.push(v);        }    }    return topology;}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    memset(indegree,0,sizeof(indegree));    int Count=0;    while(getline(infile,s)){        Count++;        int pos=s.find(&quot;Task&quot;);        int T=atoi((char*)s.substr(pos+4,1).data());        s=s.substr(pos+5);        while(s.find(&quot;Task&quot;)!=string::npos){            int pos1=s.find(&quot;Task&quot;);            int p=atoi((char*)s.substr(pos1+4,1).data());            indegree[p]++;            graph[T].push_back(p);            s=s.substr(pos1+5);        }    }    vector&lt;int&gt; v=TopologicalSort(Count);    for(int i=0;i&lt;v.size();i++){        cout&lt;&lt;&quot;Task&quot;&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre><p>4.火车票订购：火车经过   X站，火车最大载客人数为   m，有 n个订票请求，请求订购从 a站到  b站的  k张票，若能满足订购要求则输出   1，否则输出 0。数据从 ticket.in中输入，第一行有四个数，分别为 n，m。接下来有  n行，每行三个数分别为   a，b，k。结果输出到文件 ticket.out中</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;sstream&gt;using namespace std;const int MAXN=100;int station[MAXN];int n,m;int result[MAXN];bool jugde(int a,int b,int k){    bool flag=true;    for(int i=a;i&lt;=b;i++){        if(station[i]+k&gt;m){            flag=false;            break;        }    }    return flag;}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    stringstream stringin(s);    stringin&gt;&gt;n; stringin&gt;&gt;m;    int j=0;    for(int i=0;i&lt;n;i++){        int a,b,k;        getline(infile,s);        stringstream stringin1(s);        stringin1&gt;&gt;a; stringin1&gt;&gt;b; stringin1&gt;&gt;k;        if(jugde(a,b,k)){            for(int i=a;i&lt;=b;i++){                station[i]+=k;            }            result[j++]=1;        }        else{            result[j++]=0;        }    }    infile.close();    ofstream outfile(&quot;out.txt&quot;);    for(int i=0;i&lt;n;i++){        outfile&lt;&lt;result[i]&lt;&lt;endl;    }    outfile.close();}</code></pre><p>5.最短路径：有   n个城市   m条道路（n&lt;1000,   m&lt;10000)，每条道路有个长度，请找到从起点 s到终点  t的最短距离，并且输出经过的城市的名，如果有多条，输出字典序最小的那条；若从 s到   t没有路径，则输出“can’t   arrive”。从 road.in中读入数据，第一行有四个数，分别为 n，m，s，t。接下来 m行，每行三个数，分别为两个城市名和距离。输出结果到 road.out中。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;queue&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;cstdio&gt;using namespace std;const int INF=INT_MAX;//struct Edge{    int to;    int length;    Edge(int to,int length):to(to),length(length){}};const int MAXN=100;vector&lt;Edge&gt; graph[MAXN];int dis[MAXN];//存的最小距离int path[MAXN];//path[j]=i表示从i到j最短路的路径struct Point{    int number;    int distance;//到源点距离    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; e) const{        return distance&lt;e.distance;    }};void Dijkstra(int s){    priority_queue&lt;Point&gt; q;//若是逆向从时要对Point中的&gt;进行重载    dis[s]=0;    q.push(Point(s,dis[s]));    while(!q.empty()){        int u=q.top().number;//距离源点最近的点        q.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){//所以初始化应该是无穷                dis[v]=dis[u]+d;                q.push(Point(v,dis[v]));                path[v]=u;//由u到v是最短            }        }    }    return ;}int main(){    int n,m,s,t;    ifstream infile(&quot;in.txt&quot;);    string str;    getline(infile,str);    stringstream in(str);    in&gt;&gt;n; in&gt;&gt;m; in&gt;&gt;s; in&gt;&gt;t;    memset(graph,0,sizeof(graph));    //对int数组用fill初始化    fill(dis,dis+MAXN,INF);//注意初始化的范围    fill(path,path+MAXN,-1);    //cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl;    for(int i=0;i&lt;m;i++){        int a,b,l;        getline(infile,str);        stringstream in(str);        in&gt;&gt;a; in&gt;&gt;b; in&gt;&gt;l;        graph[a].push_back(Edge(b,l));        graph[b].push_back(Edge(a,l));    }    Dijkstra(s);    cout&lt;&lt;dis[t]&lt;&lt;endl;    vector&lt;int&gt; v;    while(path[t]!=-1){        v.push_back(t);        t=path[t];    }    v.push_back(s);    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_11</title>
    <link href="/2020/02/25/USTC%E6%9C%BA%E8%AF%95_11/"/>
    <url>/2020/02/25/USTC%E6%9C%BA%E8%AF%95_11/</url>
    
    <content type="html"><![CDATA[<p>1.给两个十进制数，先异或，然后输出其二进制形式</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;int main(){    int x,y;    cin&gt;&gt;x&gt;&gt;y;    int n=x^y;    while(n!=0){        v.push_back(n%2);        n/=2;    }    for(int i=v.size()-1;i&gt;=0;i--) cout&lt;&lt;v[i];}</code></pre><p>2.一共有十二个球，其颜色有红、黄、黑三种，红黄黑分别有想  x，y，k个，现在从其中取出八个球，共有多少种取法，输出到文件中？（x，y，k是从键盘输入，痛颜色的球不区分）</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;const int MAXN=1000;struct E{    int x,y,k;}E[MAXN];int main(){    int x,y,k;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;    int Count=0;    for(int i=1;i&lt;=x;i++){        for(int j=1;j&lt;=y;j++){            for(int m=1;m&lt;=k;m++){                if(i+j+m==8){                    E[Count].x=i;                    E[Count].y=j;                    E[Count].k=m;                    Count++;                }            }        }    }    cout&lt;&lt;&quot;共&quot;&lt;&lt;Count&lt;&lt;&quot;种取法&quot;;    for(int i=0;i&lt;Count;i++){        cout&lt;&lt;E[i].x&lt;&lt;&quot;红球 &quot;&lt;&lt;E[i].y&lt;&lt;&quot;黄球 &quot;&lt;&lt;E[i].k&lt;&lt;&quot;黑球&quot;&lt;&lt;endl;    }}</code></pre><p>3.在in.txt中查看是否有模式  abcde。若有，输出“找到 abc<em>d?e匹配”；若无，则输出“没有找到  abc</em>d?e匹配”</p><pre><code class="c">不会做...</code></pre><p>4.给你一个二叉树，每个节点有编号，给你一个序列，每个节点给了左孩子和右孩子的编号，让你输出这个二叉树的后序遍历结果。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;const int MAXN=100;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data),left(NULL),right(NULL){}};struct TreeNode* Tree[MAXN];void PostOrder(TreeNode* root){    if(root==NULL) return;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data;}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    TreeNode* T=NULL;    while(getline(infile,s)){        int pos=s.find(&quot; &quot;);        char a=s.substr(0,pos)[0];        s=s.substr(pos+1);        pos=s.find(&quot; &quot;);        char b=s.substr(0,pos)[0];        s=s.substr(pos+1);        pos=s.find(&quot; &quot;);        char c=s.substr(0,pos)[0];        cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;        TreeNode* Tl=NULL;        TreeNode* Tr=NULL;        if(Tree[a-&#39;0&#39;]) T=Tree[a-&#39;0&#39;];        else{            T=new TreeNode(a);            Tree[a-&#39;0&#39;]=T;        }        if(Tree[b-&#39;0&#39;]) Tl=Tree[b-&#39;0&#39;];        else{            Tl=new TreeNode(b);            Tree[b-&#39;0&#39;]=Tl;        }        if(Tree[c-&#39;0&#39;]) Tr=Tree[c-&#39;0&#39;];        else{            Tr=new TreeNode(c);            Tree[c-&#39;0&#39;]=Tr;        }        if(b!=&#39;0&#39;) T-&gt;left=Tl;        else T-&gt;left=NULL;        if(c!=&#39;0&#39;) T-&gt;right=Tr;        else T-&gt;right=NULL;    }    T=Tree[1];    PostOrder(T);    infile.close();}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_10</title>
    <link href="/2020/02/25/USTC%E6%9C%BA%E8%AF%95_10/"/>
    <url>/2020/02/25/USTC%E6%9C%BA%E8%AF%95_10/</url>
    
    <content type="html"><![CDATA[<p>1.input.txt文件里面有一段文章，由字符串和一些特殊字符构成。先把  input文件中的内容读入缓冲区，在从缓冲区中取字符，进行如下操作：</p><ul><li>如果是字符，空格，输出</li><li>如果是’!’，删除前面一个字符</li><li>如果是’*’，删除前面 1行字符串</li><li>如果是’&gt;’，讲前面一个单词的首字符，进行大小写转化</li><li>如果是数字，则不作任何操作</li></ul><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;using namespace std;vector&lt;string&gt; v;int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    while(getline(infile,s)){        v.push_back(s);    }    for(int i=0;i&lt;v.size();i++){        s=v[i];        if(s.find(&#39;!&#39;)!=string::npos){            int pos=s.find(&quot;!&quot;);            v[i]=s.substr(0,pos-1)+s.substr(pos);        }        if(s.find(&#39;*&#39;)!=string::npos){            if(i==0) cout&lt;&lt;&quot;已在第一行无法删除&quot;;            else{                v.erase(v.begin()+i-1,v.begin()+i);                i--;            }        }        if(s.find(&#39;&gt;&#39;)!=string::npos){            int pos=s.find(&#39;&gt;&#39;);            string s1=s.substr(0,pos);//&gt;前面的字符串            s1=s1.substr(0,s1.find_last_of(&quot; &quot;));            int pos1=s1.find(&quot; &quot;);//&gt;的前一个单词前面的空格位置            string c=s.substr(pos1+1,1);            if(c[0]&gt;&#39;a&#39;&amp;&amp;c[0]&lt;&#39;z&#39;) c[0]=c[0]-32;            else c[0]=c[0]+32;            //cout&lt;&lt;&quot;字母&quot;&lt;&lt;c&lt;&lt;endl;            s.replace(pos1+1,1,(char*)c.data());            v[i]=s;        }    }    for(int i=0;i&lt;v.size();i++){        cout&lt;&lt;v[i]&lt;&lt;endl;    }    infile.close();}</code></pre><p>2.从键盘输入 N，建立  N*N矩阵，每个元素是一个字符串，为每个元素赋值。然后求出按字典序排列最大的元素所在的行列</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=100;struct M{//为了排序方便，将矩阵化成一维处理    char s[MAXN];    int i,j;    bool operator &lt;(const M &amp;e) const{        if(strcmp(s,e.s)&lt;0) return true;        else return false;    }}M[MAXN];int main(){    int N;    cin&gt;&gt;N;    int k=0;//M中的下标    for(int i=0;i&lt;N;i++){        for(int j=0;j&lt;N;j++){            scanf(&quot;%s&quot;,M[k].s);            M[k].i=i;            M[k].j=j;            k++;        }    }    sort(M,M+N*N);    cout&lt;&lt;M[N*N-1].i+1&lt;&lt;&quot; &quot;&lt;&lt;M[N*N-1].j+1&lt;&lt;endl;}</code></pre><p>3.已知二叉排序树用二叉链表存储，结点的关键字为  1正整数。从键盘输入结点的关键字（以 0表示结束）建立一棵二叉排序树，并输出其后序遍历序列</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;struct TreeNode{    int data;    TreeNode* left;    TreeNode* right;    TreeNode(int data):data(data),left(NULL),right(NULL){}};//x插入到以root为根结点的排序树中，从根结点不断的向下比TreeNode* Insert(TreeNode* root,int n){    if(root==NULL) root=new TreeNode(n);    else if(n&lt;root-&gt;data) root-&gt;left=Insert(root-&gt;left,n);    else if(n&gt;root-&gt;data) root-&gt;right=Insert(root-&gt;right,n);    return root;}void PostOrder(TreeNode* root){    if(root==NULL) return  ;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;}int main(){    int n;    TreeNode* root=NULL;    while(cin&gt;&gt;n){        if(n==0) break;        else root=Insert(root,n);    }    PostOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_09</title>
    <link href="/2020/02/24/USTC%E6%9C%BA%E8%AF%95_09/"/>
    <url>/2020/02/24/USTC%E6%9C%BA%E8%AF%95_09/</url>
    
    <content type="html"><![CDATA[<p>1.处理：比如输入4，转化为16位二进制数   0000 0000 0000 0100，4个一组，相异或，变为0001，然后把0001转化为十进制的1输出</p><pre><code class="c">// 1.cpp : Defines the entry point for the console application.//#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;math.h&gt;using namespace std;queue&lt;int&gt; q;int main(){    int x;    cin&gt;&gt;x;    while(x!=0){        int a,b;        a=x%2;//当前最后一位        x/=2;        b=x%2;        a=a^b;//1 2位异或        x/=2;        b=x%2;        a=a^b;//1 2 3位异或        x/=2;        b=x%2;        a=a^b;//1 2 3 4位异或        q.push(a);    }    int i=0,answer=0;    while(!q.empty()){        answer+=q.front()*pow(2,i++);        q.pop();    }    cout&lt;&lt;answer&lt;&lt;endl;}</code></pre><p>2.将n个数由小到大排序，如果  n是奇数，输出正中间的数；如果n是偶数，输出<br>正中间的两个数</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000;int arr[MAXN];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;arr[i];    }    sort(arr,arr+n);    if(n%2==0){        cout&lt;&lt;arr[n/2-1]&lt;&lt;&quot; &quot;&lt;&lt;arr[n/2];    }    else cout&lt;&lt;arr[n/2];}</code></pre><p>3.文件读入类ABC00DE00…的二叉树先序序列，0表示叶子<br>输出：中序输出深度&lt;=depth/2的节点，其中depth是你所建立的树的深度</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//数据:ABC00D00E00int depth=0;string pre;int i=0;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};TreeNode* buildTree(){//仅用带null符号的先序序列构建树    if(i&gt;pre.size()-1) return NULL;    char c=pre[i++];    if(c==&#39;0&#39;) return NULL;    TreeNode* T=new TreeNode(c);    T-&gt;left=buildTree();    T-&gt;right=buildTree();    return T;}void PostOrder(TreeNode* T,int deep){//计算深度    if(T==NULL)return ;    if(deep&gt;depth) depth=deep;    PostOrder(T-&gt;left,deep+1);    PostOrder(T-&gt;right,deep+1);}void PostOrder1(TreeNode* T,int deep){    if(T==NULL)return ;    if(deep&gt;depth) depth=deep;    PostOrder(T-&gt;left,deep+1);    PostOrder(T-&gt;right,deep+1);    if(deep&lt;=depth/2){        cout&lt;&lt;T-&gt;data;    }    return ;}int main(){    ifstream infile(&quot;in.txt&quot;);    getline(infile,pre);    infile.close();    cout&lt;&lt;pre&lt;&lt;endl;    TreeNode* root=buildTree();    PostOrder(root,1);    //cout&lt;&lt;&quot;deep:&quot;&lt;&lt;depth&lt;&lt;endl;    PostOrder1(root,1);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_08下</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8B/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.输入十进制正整数将其转换成任意的进制</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;int main(){    int n,m;    cin&gt;&gt;n;    cout&lt;&lt;&quot;进制:&quot;;    cin&gt;&gt;m;    while(n!=0){        v.push_back(n%m);        n/=m;    }    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i];    }}</code></pre><p>2.从文件读入 2个矩阵，转置后相加再输出</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;const int n=3;const int m=2;int matrix1[n][m];int matrix2[n][m];int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    for(int i=0;i&lt;m;i++){        getline(infile,s);        for(int j=0;j&lt;n;j++){            if(s.find(&quot; &quot;)!=string::npos){                int pos=s.find(&quot; &quot;);                matrix1[j][i]=atoi((char*)s.substr(0,pos).data());//转置                s=s.substr(pos+1);            }            else{                matrix1[j][i]=atoi((char*)s.data());            }        }    }    for(int i=0;i&lt;n;i++){        getline(infile,s);        for(int j=0;j&lt;m;j++){            if(s.find(&quot; &quot;)!=string::npos){                int pos=s.find(&quot; &quot;);                matrix2[i][j]=atoi((char*)s.substr(0,pos).data());                s=s.substr(pos+1);            }            else{                matrix2[i][j]=atoi((char*)s.data());            }        }    }    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            cout&lt;&lt;matrix1[i][j]+matrix2[i][j]&lt;&lt;&quot; &quot;;        }        cout&lt;&lt;endl;    }}</code></pre><p>3.读入一个文件，第一行是字符串集合个数，第二行到第五行是这四个集合，从中<br>找到，字符串集合中出现两次的字符串，然后标识出第几个集合（行数）</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt; m;void Count1(string key){    if(m.find(key)==m.end()){//没找到这个key        m.insert(pair&lt;string,int&gt;(key,1));    }    else{//已经存在这个key        m[key]=m[key]+1;    }}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=0;i&lt;n;i++){        getline(infile,s);        while(s.size()&gt;0){            if(s.find(&quot; &quot;)!=string::npos){//                int pos=s.find(&quot; &quot;);                string key=s.substr(0,pos);                Count1(key);                s=s.substr(pos+1);            }            else{                string key=s;                Count1(key);                s=s.substr(s.size());//为了能跳出循环            }        }    }    map&lt;string,int&gt;::iterator it;    for(it=m.begin();it!=m.end();it++){//        if(it-&gt;second==2){            ifstream in(&quot;in.txt&quot;);            string s; int i=0;            getline(in,s);            while(getline(in,s)){                i++;                if(s.find(it-&gt;first)!=string::npos){                    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;i; break;                }            }            in.close();            cout&lt;&lt;endl;        }    }}</code></pre><p>4.给一个先序(中序)遍历序列，按层次输出该树的结点</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;string pre;string in;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};void LevelOrder(TreeNode* T){    queue&lt;TreeNode*&gt; q;    q.push(T);    while(!q.empty()){        TreeNode* p=q.front();        cout&lt;&lt;p-&gt;data;        q.pop();        if(p-&gt;left) q.push(p-&gt;left);        if(p-&gt;right) q.push(p-&gt;right);    }    return ;}TreeNode* build(int l1,int h1,int l2,int h2){//前序中序建树    char c=pre[l1];    TreeNode* T=new TreeNode(c);    int i;    for(i=l2;in[i]!=c;i++) ;    int llen=i-l2;    int rlen=h2-i;    if(llen) T-&gt;left=build(l1+1,l1+llen,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=build(h1-rlen+1,h1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}int main(){    cin&gt;&gt;pre&gt;&gt;in;    TreeNode* root=build(0,pre.size()-1,0,in.size()-1);    LevelOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_08上</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8A/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>1.一个十进制正整数转换成二进制有多少个1</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int main(){    int x;    cin&gt;&gt;x;    int Count=0;    while(x!=0){        if(x%2==1) Count++;        x/=2;    }    cout&lt;&lt;Count;}</code></pre><p>2.约瑟夫环问题</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;using namespace std;int main(){    queue&lt;int&gt; q;    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=1;i&lt;=n;i++){        q.push(i);    }    int m=4;    while(!q.empty()){        for(int i=1;i&lt;m;i++){            int k=q.front();            q.pop();            q.push(k);        }        cout&lt;&lt;q.front();        q.pop();    }}</code></pre><p>3.从文件读入 2个矩阵，输出矩阵相乘后的矩阵</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;int matrix1[3][3];int matrix2[3][2];int matrix3[3][2];int main(){    ifstream infile(&quot;in.txt&quot;);    ofstream outfile(&quot;out.txt&quot;);    string s;    for(int i=0;i&lt;3;i++){        getline(infile,s);        int j;        for(j=0;j&lt;2;j++){            int pos=s.find(&quot; &quot;);            matrix1[i][j]=atoi((char*)s.substr(0,pos).data());            s=s.substr(pos+1);        }        matrix1[i][j]=atoi((char*)s.data());    }    for(int i=0;i&lt;3;i++){        getline(infile,s);        int j;        for(j=0;j&lt;1;j++){            int pos=s.find(&quot; &quot;);            matrix2[i][j]=atoi((char*)s.substr(0,pos).data());            s=s.substr(pos+1);        }        matrix2[i][j]=atoi((char*)s.data());    }    infile.close();    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;2;j++){//前两个for为最终矩阵的每一个位置            int temp=0;            for(int k=0;k&lt;3;k++){                temp+=matrix1[i][k]*matrix2[k][j];//            }            matrix3[i][j]=temp;        }    }    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;2;j++){            outfile&lt;&lt;matrix3[i][j]&lt;&lt;&quot; &quot;;        }        outfile&lt;&lt;endl;    }}</code></pre><p>4.符串问题。从文件中读入几行英文句子。输出单词，行号，并按单词字典索<br>引。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt; m;//写成计数了，不过字典索引也不难，懒得改了void Count(string key){    if(m.find(key)==m.end()){//没找到这个key        m.insert(pair&lt;string,int&gt;(key,1));    }    else{//已经存在这个key        cout&lt;&lt;&quot;存在&quot;&lt;&lt;key&lt;&lt;&quot;:&quot;&lt;&lt;m[key]&lt;&lt;endl;        m[key]=m[key]+1;    }}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=0;i&lt;n;i++){        getline(infile,s);        while(s.size()&gt;0){            cout&lt;&lt;s&lt;&lt;endl;            if(s.find(&quot; &quot;)!=string::npos){//                int pos=s.find(&quot; &quot;);                string key=s.substr(0,pos);                Count(key);                s=s.substr(pos+1);            }            else{                string key=s;                Count(key);                s=s.substr(s.size());//为了能跳出循环            }        }    }    map&lt;string,int&gt;::iterator it;    for(it=m.begin();it!=m.end();it++){//        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_07下</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8B/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.输入字符串，倒序输出，例如：输入 I come from China.输出 China from come I.（单词不需倒序，只是句子倒了）</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main(){    string s;    getline(cin,s);    vector&lt;string&gt; v;    while(s.find(&#39; &#39;)!=string::npos){        int pos=s.find(&#39; &#39;);        v.push_back(s.substr(0,pos));        s=s.substr(pos+1);    }    v.push_back(s);    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre><p>2.输入一个数判断是不是完数，是输出 yes，不是输出  no</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int fenjie(int x){    int sum=0;    for(int i=1;i&lt;=x/2;i++){        if(x%i==0) sum+=i;    }    return sum;}int main(){    int x;    cin&gt;&gt;x;    if(fenjie(x)==x) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;}</code></pre><p>3.件读取一个文件，做无向图的广度遍历输出，文件的第一行是图的节点个<br>数，后面是边的信息，0 0表示结束</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;const int MAXN=100;int visit[MAXN];vector&lt;int&gt; G[MAXN];void BFS(int x){//传过来的起始点    queue&lt;int&gt; q;    q.push(x);    visit[x]=true;    while(!q.empty()){//队列        int current=q.front();        cout&lt;&lt;current&lt;&lt;&quot; &quot;;        q.pop();        for(int i=0;i&lt;G[current].size();i++){            if(!visit[G[current][i]]){                //cout&lt;&lt;&quot;没访问&quot;&lt;&lt;G[current][i]&lt;&lt;&quot; &quot;;                q.push(G[current][i]);                visit[G[current][i]]=true;            }        }        //cout&lt;&lt;endl;    }}int main(){    //memset(visit,false,sizeof(visit));//在cstring中    ifstream infile(&quot;in.txt&quot;);//在fstream中    string line;//std::string类似通常的字符数组    string n;    getline(infile,n);    while(getline(infile,line)){        int pos=line.find(&quot; &quot;);        //atoi中要将string转化为char*        int a=atoi((char*)line.substr(0,pos).data());        int b=atoi((char*)line.substr(pos+1).data());        //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;        G[a].push_back(b);        G[b].push_back(a);    }    BFS(1);}</code></pre><p>4.没有括号只有加减乘除的表达式求值，表达式从文件读入，计算的结果<br>输出到文件上。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100;char out[MAXN];//存储逆波兰式stack&lt;char&gt; s1;//生成逆波兰式stack&lt;double&gt; s2;//计算逆波兰式int Priority(char c){    if(c==&#39;*&#39;||c==&#39;/&#39;) return 2;    else if(c==&#39;+&#39;||c==&#39;-&#39;)return 1;    else if(c==&#39;#&#39;) return 3;    else return 0;}bool isop(char c){    return c==&#39;+&#39;||c==&#39;-&#39;||c==&#39;*&#39;||c==&#39;/&#39;;}double cal(double x,double y,char op){    if(op==&#39;+&#39;)return x+y;    else if(op==&#39;-&#39;) return x-y;    else if(op==&#39;*&#39;) return x*y;    else if(op==&#39;/&#39;) return x/y;}void RePolish(string s){    int j=0;//指向out    for(int i=0;i&lt;s.size();i++){        //if(!s1.empty()) cout&lt;&lt;&quot;栈顶：&quot;&lt;&lt;s1.top();        if(isdigit(s[i])){            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;s[i];            out[j++]=s[i];        }        else if(isop(s[i])){            //cout&lt;&lt;&quot;操作符:&quot;&lt;&lt;s[i];            if(s1.empty()) s1.push(s[i]);            else if(Priority(s[i])&gt;Priority(s1.top())){                s1.push(s[i]);            }            else{                while(!s1.empty()&amp;&amp;Priority(s[i])&lt;=Priority(s1.top())){//这里是&lt;=，先进的优先级更高                    out[j++]=s1.top();                    //cout&lt;&lt;&quot;此时栈顶&quot;&lt;&lt;s1.top();                    s1.pop();                }                s1.push(s[i]);            }        }    }    while(!s1.empty()){        out[j++]=s1.top();        s1.pop();    }    return ;}void Calculate(){//根据逆波兰式求值    for(int i=0;i&lt;strlen(out);i++){        if(isdigit(out[i])) s2.push((double)out[i]-&#39;0&#39;);        else if(isop(out[i])){            double b=(double)s2.top(); s2.pop();            double a=(double)s2.top(); s2.pop();            s2.push(cal(a,b,out[i]));        }    }    cout&lt;&lt;s2.top();}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    RePolish(s);    for(int i=0;i&lt;strlen(out);i++){//char*要用strlen而不是.size        cout&lt;&lt;out[i];    }    cout&lt;&lt;endl;    Calculate();}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector的总结</title>
    <link href="/2020/02/22/%E6%A0%87%E5%87%86c++%E4%B8%ADstring%E7%B1%BB%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/02/22/%E6%A0%87%E5%87%86c++%E4%B8%ADstring%E7%B1%BB%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>注意不是CString<br>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必 担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。</p><p>好了，进入正题………<br>首先，为了在我们的程序中使用string类型，我们必须包含头文件 <string>。</p><p>如下：<br>#include <string> //注意这里不是string.h string.h是C字符串头文件<br>#include <string><br>using namespace std;</p><p><strong>1．声明一个C++字符串</strong><br>声明一个字符串变量很简单：<br>string Str;<br>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：<br>a)      string s;    //生成一个空字符串s<br>b)      string s(str) //拷贝构造函数 生成str的复制品<br>c)      string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值<br>d)      string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值<br>e)      string s(cstr) //将C字符串作为s的初值<br>f)      string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。<br>g)      string s(num,c) //生成一个字符串，包含num个c字符<br>h)      string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值<br>i)      s.~string() //销毁所有字符，释放内存<br>都很简单，我就不解释了。</p><p><strong>2．字符串操作函数</strong><br>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。<br>a) =,assign()     //赋以新值<br>b) swap()     //交换两个字符串的内容<br>c) +=,append(),push_back() //在尾部添加字符<br>d) insert() //插入字符<br>e) erase() //删除字符<br>f) clear() //删除全部字符<br>g) replace() //替换字符<br>h) + //串联字符串<br>i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()    //比较字符串<br>j) size(),length()    //返回字符数量<br>k) max_size() //返回字符的可能最大个数<br>l) empty()    //判断字符串是否为空，是空时返回ture，不是空时返回false<br>m) capacity() //返回重新分配之前的字符容量<br>n) reserve() //保留一定量内存以容纳一定数量的字符<br>o) [ ], at() //存取单一字符<br>p) &gt;&gt;,getline() //从stream读取某值<br>q) &lt;&lt;    //将谋值写入stream<br>r) copy() //将某值赋值为一个C_string<br>s) c_str() //将内容以C_string返回<br>t) data() //将内容以字符数组形式返回<br>u) substr() //返回某个子字符串<br>v)查找函数<br>w)begin() end() //提供类似STL的迭代器支持<br>x) rbegin() rend() //逆向迭代器<br>y) get_allocator() //返回配置器</p><p>下面详细介绍：</p><p><strong>2．1 C++字符串和C字符串的转换</strong><br>C ++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’/0’。c_str()返回一个以‘/0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string或 字符数组内。C++字符串并不以’/0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</p><p><strong>2．2 大小和容量函数</strong><br>一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定， 默认参数为0，这时候会对string进行非强制性缩减。</p><p>还有必要再重复一下C++字符串和C字符串转换的问 题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数Connect(char<em>,char</em>)），但别人的函数参 数用的是char<em>形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char</em>,要想作为上面提及的函数的参数，还必须拷贝到一个char<em>,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果 此函数对参数(也就是char</em>)的内容不修改的话，我们可以这样Connect((char<em>)UserID.c_str(), (char</em>)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char<em>上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char</em>上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</p><p><strong>2．3元素存取</strong><br>我们可以使用下标操作符[]和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用 at()的时候索引无效，会抛出out_of_range异常。</p><p>有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’/0’。其他的各种情况，a.length()索引都是无效的。举例如下：<br>const string Cstr(“const string”);<br>string Str(“string”);<br>Str[3];      //ok<br>Str.at(3);    //ok<br>Str[100]; //未定义的行为<br>Str.at(100);    //throw out_of_range<br>Str[Str.length()]    //未定义行为<br>Cstr[Cstr.length()] //返回 ‘/0’<br>Str.at(Str.length());//throw out_of_range<br>Cstr.at(Cstr.length()) ////throw out_of_range<br>我不赞成类似于下面的引用或指针赋值：<br>char&amp; r=s[2];<br>char* p= &amp;s[3];<br>因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</p><p><strong>2．4比较函数</strong><br>C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string (“aaaa”) &lt;string(aaaaa)。</p><p>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：<br>string s(“abcd”);<br>s.compare(“abcd”); //返回0<br>s.compare(“dcba”); //返回一个小于0的值<br>s.compare(“ab”); //返回大于0的值<br>s.compare(s); //相等<br>s.compare(0,2,s,2,2); //用”ab”和”cd”进行比较 小于零<br>s.compare(1,2,”bcx”,2); //用”bc”和”bc”比较。<br>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？靠，你重修吧！</p><p><strong>2．5 更改内容</strong><br>这在字符串的操作中占了很大一部分。<br>首先讲赋值，第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：<br>s.assign(str); //不说<br>s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串<br>s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给s<br>s.assign(“gaint”); //不说<br>s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘/0’赋给字符串<br>s.assign(5,’x’);//把五个x赋给字符串<br>把字符串清空的方法有三个：s=””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。<br>string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。<br>先说增加字符（这里说的增加是在尾巴上），函数有 +=、append()、push_back()。</p><p>举例如下：<br>s+=str;//加个字符串<br>s+=”my name is jiayp”;//加个C字符串<br>s+=’a’;//加个字符<br>s.append(str);<br>s.append(str,1,3);//不解释了 同前面的函数参数assign的解释<br>s.append(str,2,string::npos)//不解释了<br>s.append(“my name is jiayp”);<br>s.append(“nico”,5);<br>s.append(5,’x’);<br>s.push_back(‘a’);//这个函数只能增加单个字符对STL熟悉的理解起来很简单</p><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。<br>      s.insert(0,”my name”);<br>      s.insert(1,str);<br>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插 入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1, ‘j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指 出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</p><p>删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。</p><p>举例吧：<br>string s=”il8n”;<br>s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_string<br>s.erase(13);//从索引13开始往后全删除<br>s.erase(7,5);//从索引7开始往后删5个</p><p><strong>2．6提取子串和字符串连接</strong><br>题取子串的函数是：substr(),形式如下：<br>s.substr();//返回s的全部内容<br>s.substr(11);//从索引11往后的子串<br>s.substr(5,6);//从索引5开始6个字符<br>把两个字符串结合起来的函数是+。（谁不明白请致电120）</p><p><strong>2．7输入输出操作</strong><br>1．&gt;&gt; 从输入流读取一个string。<br>2．&lt;&lt; 把一个string写入输出流。<br>另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</p><p><strong>2．8搜索与查找</strong><br>查找函数很多，功能也很强大，包括了：<br>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。</p><p>最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)== string::npos)）。</p><p>string类的构造函数：<br>string(const char *s);    //用c字符串s初始化<br>string(int n,char c);     //用n个字符c初始化<br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常</p><p>string类的字符操作：<br>const char &amp;operator[](int n)const;<br>const char &amp;at(int n)const;<br>char &amp;operator[](int n);<br>char &amp;at(int n);<br>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br>const char *data()const;//返回一个非null终止的c字符数组<br>const char *c_str()const;//返回一个以null终止的c字符串<br>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p><p>string的特性描述:<br>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）<br>int max_size()const;    //返回string对象中可存放的最大字符串的长度<br>int size()const;        //返回当前字符串的大小<br>int length()const;       //返回当前字符串的长度<br>bool empty()const;        //当前字符串是否为空<br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p><p>string类的输入输出操作:<br>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p><p>string的赋值：<br>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(const char *s);//用c类型字符串s赋值<br>string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值<br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p><p>string的连接：<br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾<br>string &amp;append(const char *s);            //把c类型字符串s连接到当前字符串结尾<br>string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br>string &amp;append(const string &amp;s);    //同operator+=()<br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c<br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p><p>string的比较：<br>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br>int compare(const string &amp;s) const;//比较当前字符串和s的大小<br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小<br>int compare(const char *s) const;<br>int compare(int pos, int n,const char *s) const;<br>int compare(int pos, int n,const char *s, int pos2) const;<br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0<br>string的子串：<br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p><p>string的交换：<br>void swap(string &amp;s2);    //交换当前字符串与s2的值</p><p>string类的查找函数：<br>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br>int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>//查找成功时返回所在位置，失败返回string::npos的值<br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br>int rfind(const char *s, int pos = npos) const;<br>int rfind(const char *s, int pos, int n = npos) const;<br>int rfind(const string &amp;s,int pos = npos) const;<br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值<br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br>int find_first_of(const char *s, int pos = 0) const;<br>int find_first_of(const char *s, int pos, int n) const;<br>int find_first_of(const string &amp;s,int pos = 0) const;<br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos<br>int find_first_not_of(char c, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos,int n) const;<br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos<br>int find_last_of(char c, int pos = npos) const;<br>int find_last_of(const char *s, int pos = npos) const;<br>int find_last_of(const char *s, int pos, int n = npos) const;<br>int find_last_of(const string &amp;s,int pos = npos) const;<br>int find_last_not_of(char c, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos, int n) const;<br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p><p>string类的替换函数：<br>string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br>string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s<br>string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p><p>string类的插入函数：<br>string &amp;insert(int p0, const char *s);<br>string &amp;insert(int p0, const char *s, int n);<br>string &amp;insert(int p0,const string &amp;s);<br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br>void insert(iterator it, int n, char c);//在it处插入n个字符c</p><p>string类的删除函数<br>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p><p>string类的迭代器处理：<br>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。</p><p>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br>const_iterator begin()const;<br>iterator begin();                //返回string的起始位置<br>const_iterator end()const;<br>iterator end();                    //返回string的最后一个字符后面的位置<br>const_iterator rbegin()const;<br>iterator rbegin();                //返回string的最后一个字符的位置<br>const_iterator rend()const;<br>iterator rend();                    //返回string第一个字符位置的前面<br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p><p>字符串流处理：<br>通过定义ostringstream和istringstream变量实现，<sstream>头文件中<br>例如：<br>string input(“hello,this is a test”);<br>istringstream is(input);<br>string s1,s2,s3,s4;<br>is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br>ostringstream os;<br>os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br>cout&lt;&lt;os.str();</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c++常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_07上</title>
    <link href="/2020/02/22/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8A/"/>
    <url>/2020/02/22/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>1.编写程序，判断回文数</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int Reverse(int x){    int result=0;    while(x!=0){        result=result*10+x%10;        x/=10;    }    return result;}int main(){    int n;    while(cin&gt;&gt;n){        if(Reverse(n)==n) cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;    }}</code></pre><p>2.队列的循环报数问题</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){    int n;    cin&gt;&gt;n;    queue&lt;int&gt; q;o    for(int i=1;i&lt;=n;i++) q.push(i);    while(!q.empty()){        cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;;//报号1        q.pop();        if(!q.empty()){            q.push(q.front());//报号2            q.pop();        }    }}</code></pre><p>3.图的最小生成树</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1001;struct Edge{    int from;    int to;    int length;    bool operator&lt; (const Edge&amp; e) const{        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(x!=father[x]) father[x]=Find(father[x]);    return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[y]&lt;height[x]) father[y]=x;        else{            father[y]=x;            height[x]++;        }    }    return ;}int kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //即from与to上溯的根结点不一样        //也即加上edge[i]不会形成环        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        //用于给了两两之间的距离修路的问题        int edgeNumber=n*(n-1)/2;        for(int i=0;i&lt;edgeNumber;i++){            cin&gt;&gt;edge[i].from&gt;&gt;edge[i].to&gt;&gt;edge[i].length;        }        int answer=kruskal(n,edgeNumber);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre><p>4.后序中序得先序</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};string in;string post;TreeNode* postin(int l1,int h1,int l2,int h2){    char data=post[h1];    cout&lt;&lt;data&lt;&lt;endl;    TreeNode* T=new TreeNode(data);    int i;    for(i=l2;data!=in[i];i++);//这里i的开头是l2    int llen=i-l2;    int rlen=h2-i;    if(llen) T-&gt;left=postin(l1,l1+llen-1,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=postin(h1-rlen,h1-1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}void PreOrder(TreeNode* T){    if(T==NULL) return;    cout&lt;&lt;T-&gt;data;    PreOrder(T-&gt;left);    PreOrder(T-&gt;right);}int main(){    cin&gt;&gt;post&gt;&gt;in;    TreeNode* root=postin(0,post.size()-1,0,in.size()-1);    PreOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_06下</title>
    <link href="/2020/02/21/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8B/"/>
    <url>/2020/02/21/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.统计一个字符串当中有多少字母、数字、空格和其它字符；</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int count_zimu=0,count_shuzi=0,count_space=0,count_others=0;void Count(char c){    if(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) count_shuzi++;    else if((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) count_zimu++;    else if(c==&#39; &#39;) count_space++;    else count_others++;}int main(){    string s;3r    getline(cin,s);    for(int i=0;i&lt;s.size();i++){        Count(s[i]);    }    cout&lt;&lt;count_zimu&lt;&lt;&quot; &quot;&lt;&lt;count_shuzi&lt;&lt;&quot; &quot;&lt;&lt;count_space&lt;&lt;&quot; &quot;&lt;&lt;count_others&lt;&lt;endl;}</code></pre><p>2.给你一个 10进制数，要你输出  8进制数；</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(){    int n;    stack&lt;int&gt; result;    cin&gt;&gt;n;    while(n!=0){        result.push(n%8);        n/=8;    }    while(!result.empty()){        cout&lt;&lt;result.top();        result.pop();    }}</code></pre><p>3.给你一个数，要求你求出这个数与其反序数的和相加多少次才可以得到回<br>文字</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int Reverse(int x){//求逆序    int result=0;    while(x!=0){        result=result*10+x%10;        x/=10;    }    return result;}bool ishuiwen(int x){//判断回文    if(Reverse(x)==x) return true;    else return false;}int main(){    int time=0;    int n;    cin&gt;&gt;n;    while(!ishuiwen(n)){        n=n+Reverse(n);        time++;    }    cout&lt;&lt;time&lt;&lt;endl;}</code></pre><p>4.给你一个数列，求出最大子序列之和</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=100;int a[MAXN];int dp[MAXN];int main(){    int n;    cin&gt;&gt;n;    int Max=0;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];    }    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];        else dp[i]=max(a[i],dp[i-1]+a[i]);        if(dp[i]&gt;Max) Max=dp[i];    }    cout&lt;&lt;Max&lt;&lt;endl;}</code></pre><p>5.给你几个整数，求出最大的组合数</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100;vector&lt;string&gt; v;//使用字典序可以快速解决这道题bool compare(string x,string y){    return x&gt;y;}int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        string num;        cin&gt;&gt;num;        v.push_back(num);    }    sort(v.begin(),v.end(),compare);    for(int i=0;i&lt;n;i++){        cout&lt;&lt;v[i];    }}</code></pre><p>6.关于图的最大连通分量</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;#define maxn 10001using namespace std;vector&lt;int&gt;G[maxn];stack&lt;int&gt;s;int n,m;int dfn[maxn],used[maxn],vis[maxn],low[maxn],color[maxn],num[maxn],colornum=0,cnt=0,ans=0;void paint(int x){    s.pop();    color[x]=colornum;    num[colornum]++;    vis[x]=false;}void tarjan(int x){    dfn[x]=low[x]=++cnt;//依次深搜并且对dfn和low初始化    s.push(x);    vis[x]=used[x]=true;//置访问标记    for(int i=0;i&lt;G[x].size();i++){//遍历当前节点的所有边        int q=G[x][i];        if (!dfn[q]){//如果边没有被访问过，即没有被dfn初始化            tarjan(q);            low[x]=min(low[x],low[q]);        }        else if (vis[q]) low[x]=min(low[x],dfn[q]);//如果    }    if (low[x]==dfn[x]){//满足强连通分量的条件        colornum++;        while(s.top()!=x){            int t=s.top();            paint(t);        }        paint(x);    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int u,v;        cin&gt;&gt;u&gt;&gt;v;        G[u].push_back(v);    }    for(int i=1;i&lt;=n;i++){        if (!used[i]) tarjan(i);    }    for(int i=1;i&lt;=colornum;i++){        if (num[i]&gt;0) ans++;    }    cout&lt;&lt;ans;    return 0;}</code></pre><p>7.用二叉树，给你先序和中序遍历，输出后续遍历</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;string pre,post;struct TreeNode{    char c;    TreeNode* left;    TreeNode* right;    TreeNode(char c):c(c){}};TreeNode* PreInCreat(int l1,int h1,int l2,int h2){    TreeNode* T=new TreeNode(pre[l1]);//根结点    int i;    for(i=l2;post[i]!=T-&gt;c;i++) ;//根结点在中序序列中的划分    int llen=i-l2;//左子树长度    int rlen=h2-i;//右子树长度    //这里的上下限画个图就清楚了    if(llen) T-&gt;left=PreInCreat(l1+1,l1+llen,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=PreInCreat(h1-rlen+1,h1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}void PostOrder(TreeNode* T){    if(T==NULL) return;    else{        PostOrder(T-&gt;left);        PostOrder(T-&gt;right);        cout&lt;&lt;T-&gt;c;    }}int main(){    cin&gt;&gt;pre&gt;&gt;post;    TreeNode* root=PreInCreat(0,pre.size()-1,0,post.size()-1);    PostOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法中的常用代码</title>
    <link href="/2020/02/21/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/02/21/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><strong>并查集模板</strong><br>主要用于解决关于连通的一些问题</p><pre><code class="cpp">void Initial(){    for(int i=0;i&lt;MAXN;i++){        father[i]=i;//根结点指向自己        height[i]=0;        //inDegree[i]=0;        //visit[i]=false;    }}int Find(int x){    if(father[x]!=x) father[x]=Find(father[x]);//注意写法，路径压缩    return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;//前面两种情况树高并没有变        else{            father[y]=x;            height[x]++;        }    }    return ;}</code></pre><p><strong>邻接表</strong></p><pre><code class="cpp">struct Edge{    int to;    int length;    Edge(int t,int l):to{t},length(l){}};vector&lt;Edge&gt; graph[MAXN];</code></pre><p><strong>广度优先搜索</strong></p><pre><code class="cpp">struct Status{    int n,t;//t表示起点到n的时间    Status(int n,int t):n(n),t(t){}};bool visit[MAXN];int BFS(int n,int k){    queue&lt;Status&gt; myqueue;    myqueue.push(Status(n,0)); //初始状态    visit[n]=true;   //起始点已被访问    while(!myqueue.empty()){        Status current=myqueue.front();        myqueue.pop();        if(current.n==k) return current.t;  //查找成功        for(int i=0;i&lt;3;i++){       //转入三种不同的状态            Status next(current.n,current.t+1);            if(i==0) next.n+=1;            else if(i==1) next.n-=1;            else next.n*=2;            if(next.n&lt;0||next.n&gt;=MAXN||visit[next.n]) continue;//新状态不合法            myqueue.push(next);            visit[next.n]=true;//置访问标记        }    }}</code></pre><p><strong>深度优先搜索</strong></p><pre><code class="cpp">int side; //边长int m;  //树枝数目int sticks[MAXN];bool visit[MAXN];bool DFS(int sum,int number,int position){    if(number==3) return true;    int sample=0;       //剪枝(3)    for(int i=position;i&lt;m;i++){        if(visit[i]||sum+sticks[i]&gt;side||sticks[i]==sample) continue;        visit[i]=true;        if(sum+sticks[i]==side){    //能凑成一条边            if(DFS(0,number+1,0)) return true;            else sample=sticks[i];  //记录失败的棍子的长度        }        else{            if(DFS(sum+sticks[i],number,i+1)) return true;            else sample=sticks[i];  //记录失败的棍子的长度        }        visit[i]=false;    }    return false;}</code></pre><p><strong>最小生成树</strong></p><pre><code class="cpp">int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}</code></pre><p><strong>最短路径</strong></p><pre><code class="cpp">struct Point{//结点    int number;    int distance;    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; p) const{//重载小于        return distance&gt;p.distance;    }};int dis[MAXN];void Dijkstra(int s){    priority_queue&lt;Point&gt; pqueue;    dis[s]=0;    pqueue.push(Point(s,dis[s]));    while(!pqueue.empty()){        int u=pqueue.top().number;//离源点最近的点        pqueue.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;//u为顶点的编号，i为边的序号            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){                dis[v]=dis[u]+d;                pqueue.push(Point(v,dis[v]));            }        }    }    return ;}</code></pre><p><strong>拓扑排序</strong></p><pre><code class="cpp">int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}</code></pre><p><strong>关键路径</strong><br>基于拓扑顺序去遍历的</p><pre><code class="cpp">void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_06上</title>
    <link href="/2020/02/18/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8A/"/>
    <url>/2020/02/18/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>2.给出四个[年,月],判断此月有多少天.题目给出了闰年判断方法的伪代码.</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int months[2][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},//平年    {0,31,29,31,30,31,30,31,31,30,31,30,31}//闰年};bool isrein(int year){    return (year%400==0)||(year%4==0&amp;&amp;year%100!=0);}int main(){    int year,month;    while(cin&gt;&gt;year&gt;&gt;month){        if(isrein(year)) cout&lt;&lt;months[1][month];        else cout&lt;&lt;months[0][month];    }}</code></pre><p>3.给出一些标识符,判断合法标识符有多少个.(与 C语言中标识符定义一致.)</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;bool first(char c){    return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)||(c==&#39;_&#39;);}bool others(char c){    return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)||isdigit(c)||(c==&#39;_&#39;);}int main(){    int n;    while(cin&gt;&gt;n){        vector&lt;string&gt; v;        int Count=0;        for(int i=0;i&lt;n;i++){            string s;            cin&gt;&gt;s;            v.push_back(s);        }        for(int i=0;i&lt;v.size();i++){            string s1=v[i];            if(first(s1[0])){                bool flag=true;                for(int j=1;j&lt;s1.size();j++){                    if(!others(s1[j])) flag=false;                }                if(flag) Count++;            }            else continue;        }        cout&lt;&lt;Count&lt;&lt;endl;    }}</code></pre><p>4.第四道,给出无向图连接矩阵,求各个连通分量</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;const int MAXN=1000;int father[MAXN];int height[MAXN];//以该节点为根的树的高度using namespace std;void Initial(){    for(int i=0;i&lt;MAXN;i++){        father[i]=i;        height[i]=0;        //inDegree[i]=0;        //visit[i]=false;    }}int FindRoot(int x){    if(father[x]!=x) father[x]=FindRoot(father[x]);//注意写法    return father[x];}void Union(int x,int y){    x=FindRoot(x);    y=FindRoot(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;//前面两种情况树高并没有变        else{            father[y]=x;            height[x]++;        }    }    return ;}int main(){    FILE *fp1,*fp2;//1.定义指针    fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;);//2.指向文件    fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;);    int n;    fscanf(fp1,&quot;%d&quot;,&amp;n);//3.进行读写    Initial();    while(!feof(fp1)){        int a,b;        fscanf(fp1,&quot;%d&quot;,&amp;a);        fscanf(fp1,&quot;%d&quot;,&amp;b);        Union(a,b);    }    vector&lt;int&gt; roots;    for(int i=1;i&lt;=n;i++){//因为序号是从1开始        if(FindRoot(i)==i){            roots.push_back(i);        }    }}</code></pre><p>5.给出一个整数分解成尽可能多的连续整数的和</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int main(){    int n;    while(cin&gt;&gt;n){        int maxi=0,maxj=0;        bool flag=false;        for(int i=1;i&lt;=n/2;i++){            int sum=0;            for(int j=2;j&lt;n;j++){//j表示从i开始往后连续的长度                sum=(i+i+j-1)*j/2;                if(sum&gt;n) break;                else if(sum==n){                    flag=true;                    if(j&gt;maxj){                        maxi=i;                        maxj=j;                    }                }            }        }        if(flag){            for(int i=maxi;maxj&gt;0;maxj--,i++){                cout&lt;&lt;i&lt;&lt;&quot; &quot;;            }            cout&lt;&lt;endl;        }        else cout&lt;&lt;&quot;分解失败&quot;&lt;&lt;endl;    }}</code></pre><p>6.给出带括号的四则运算表达式,要求给出逆波兰式</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;stack&lt;char&gt; Stack;char output[500];int outLen;int Priority(char c){//判断运算符优先级    if(c==&#39;*&#39;||c==&#39;/&#39;) return 2;    else if(c==&#39;+&#39;||c==&#39;-&#39;) return 1;    else return 0;//&#39;(&#39;}bool isOperator(char op)                //判断是不是操作符{    return (op==&#39;+&#39; || op==&#39;-&#39; || op==&#39;*&#39; || op==&#39;/&#39;);}void rePolish(string s,int len){//输出逆波兰式    memset(output,&#39;\0&#39;,sizeof(output));    outLen=0;    for(int i=0;i&lt;len;++i){        //操作数        if(isdigit(s[i])){            cout&lt;&lt;&quot;shu:&quot;&lt;&lt;s[i]&lt;&lt;endl;            output[outLen++] = s[i];            while (i+1&lt;len&amp;&amp;isdigit(s[i+1])){                output[outLen++] = s[i+1];                ++i;            }            output[outLen++] = &#39; &#39;;        //空格隔开        }        //运算符        else if (isOperator(s[i])){            cout&lt;&lt;&quot;fu:&quot;&lt;&lt;s[i]&lt;&lt;endl;            if(!Stack.empty()&amp;&amp;Priority(Stack.top())&gt;=Priority(s[i])){                while(Priority(Stack.top())&gt;=Priority(s[i])){                    output[outLen++]=Stack.top();                    output[outLen++] = &#39; &#39;;                    Stack.pop();                }            }            else Stack.push(s[i]);//栈为空，或者栈顶优先级更小        }        //&#39;(&#39;        else if (s[i]==&#39;(&#39;){            cout&lt;&lt;&quot;(:&quot;&lt;&lt;s[i]&lt;&lt;endl;            Stack.push(s[i]);        }        //&#39;)&#39;        else if (s[i]==&#39;)&#39;){            cout&lt;&lt;&quot;):&quot;&lt;&lt;s[i]&lt;&lt;endl;            while (Stack.top()!=&#39;(&#39;){                output[outLen++] = Stack.top();                output[outLen++] = &#39; &#39;;                Stack.pop();            }            Stack.pop();// 此时Stack.top()=&#39;(&#39;,跳过)        }        else continue;    }    while (!Stack.empty()){//输入完毕，栈中剩余的所有操作符出栈        output[outLen++] = Stack.top();        output[outLen++] = &#39; &#39;;        Stack.pop();    }}int main(){    string s;    while (getline(cin,s)){        cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;s.size();        Stack.push(&#39;#&#39;);        rePolish(s,s.size());        output[outLen-1] = &#39;\0&#39;;        printf(&quot;%s\n&quot;,output);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划状态转移公式</title>
    <link href="/2020/02/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/02/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>最大连续子序列和</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最大连续子序列和</td><td align="left">在一个给定的序列中，找出一个连续的子序列，使得这个子序列的和最大</td><td align="left">dp[i]表示以A[i]作为末尾的连续序列最大和&#124;dp[i]=max(A[i],dp[i-1]+A[i])</td><td align="left"></td></tr></tbody></table><p>转移情况：<br>①最大和的连续序列只有一个元素，即A[i]本身，为A[i]<br>②最大和的连续序列有多个元素，即从A[j]开始到A[i]，为dp[i-1]+A[i]</p><pre><code class="cpp">int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}</code></pre><p><strong>最长递增子序列</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最长递增子序列</td><td align="left">在一个给定的序列中，找出一个的最长的递增子序列（不必连续）</td><td align="left">dp[i]表示以A[i]作为末尾的最长递增子序列长度</td><td align="left">dp[i]=max(1,dp[j]+1 | j&lt;i&amp;&amp;A[j]&lt;A[i])</td></tr></tbody></table><p>转移情况：<br>①A[i]之前的元素都比A[i]大，即最长递增子序列只有A[i]本身，为dp[i]=1<br>②A[i]之前的元素A[j]比A[i]小此时只需将A[i]添加到以A[j]为末尾的最长递增子序列,而求长度则是通过将i之前的元素逐一遍历，就可以获得dp[i]</p><pre><code class="cpp">  int answer=0;  for(int i=0;i&lt;n;i++){      dp[i]=1;//初始化为1      for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度          if(height[i]&lt;=height[j]){              dp[i]=max(dp[i],dp[j]+1);          }      }      answer=max(answer,dp[i]);  }</code></pre><p><strong>最长公共子序列</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最长公共子序列</td><td align="left">给定字符串s1,s2求一个最长的公共子序列(不一定连续)</td><td align="left">dp[i][j]表示以s1[i]作为末尾和以s2[j]为末尾的最长公共子序列的长度</td><td align="left">dp[i][j]=dp[i-1][j-1]+1(s1[i]=s2[j])___   否则dp[i][j]==max(dp[i-1][j],dp[i][j-1])</td></tr></tbody></table><p>转移情况：<br>①s1[i]=s2[j]，此时比存在一个最长公共子序列以s1[i]和s2[j]结尾，其他部分相当于s1的前i-1和s2的前j-1个字符的最长公共子序列，为dp[i-1][j-1]+1<br>②s1[i]!=s2[j],此时最长公共子序列的长度为<u>s1的前i-1个字符和s2的前j个字符的最长公共子序列</u>与<u>s1的前i个字符和s2中的前j-1个字符的最长公共子串</u>的较大者，为max(dp[i-1][j],dp[i][j-1])</p><p>边界情况：<br>dp[i][0]=0;       dp[0][j]=0;</p><pre><code class="cpp">while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入    int n=strlen(s1+1);    int m=strlen(s2+1);    for(int i=0;i&lt;=n;i++){        for(int j=0;j&lt;=m;j++){            if(i==0||j==0){//边界条件初始化                dp[i][j]=0;                continue;            }            //状态转移方程            if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);        }    }    cout&lt;&lt;dp[n][m]&lt;&lt;endl;}</code></pre><p><strong>背包问题</strong></p><ul><li>0-1背包</li></ul><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">0–1背包</td><td align="left">n种物品(<u>一种只取一次</u>),重量分别为w[i],现有容量为m背包,要使装进背包物品价值最大</td><td align="left">dp[i][j]表示前i个物品装进容量为j的背包能获得的最大价值</td><td align="left">dp[j]=max(dp[j],dp[j-w[i]]+v[i])</td></tr></tbody></table><p>转移情况：<br>①对于容量为j的背包，如果不放入第i件物品，问题就转化成了前i-1个物品放入容量为j的背包的问题，为dp[i-1][j]<br>②对于容量为j的背包，如果放入第i件物品，问题就转化成了将前面i-1个物品放入容量为j-w[i]的背包的问题，为dp[i-1][j-w[i]]+v[i]<br>最终转化成了dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])<br>经观察dp[i][j]只与二维数组中本行的上一行有关，根据这个可以将二维数组优化为一维数组：<br>dp[j]=max(dp[j],dp[j-w[i]+v[i])</p><p>边界情况：<br>dp[i][0]=0;       dp[0][j]=0;</p><pre><code class="cpp">for(int i=0;i&lt;=m;i++){    dp[i]=0;//初始化}for(int i=0;i&lt;n;i++){    for(int j=m;j&gt;=w[i];j--){        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);    }}</code></pre><ul><li><del>完全背包</del> ：暂时不是很理解(╯°Д°)╯︵┻━┻</li><li><del>多重背包</del> ：暂时不是很理解ヽ(｀Д´)ﾉ︵ ┻━┻ ┻━┻ </li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小邮票数</title>
    <link href="/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/"/>
    <url>/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。</p><p><strong>输入描述:</strong><br>    有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。</p><p><strong>输出描述:</strong><br>      对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。</p><p><strong>输入</strong></p><blockquote><p>10<br>5<br>1 3 3 3 4</p></blockquote><p><strong>输出</strong></p><blockquote><p>3</p></blockquote><pre><code class="cpp">/*    最少邮票数 &gt;&gt; 01动态规划    状态    集合中数字    dp[i][j]    0   1   2   3   4   5   6   7   8   9   10    1           0   1   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞    1 3         0   1   ∞   1   2   ∞   ∞   ∞   ∞   ∞   ∞    1 3 3       0   1   ∞   1   2   ∞   2   3   ∞   ∞   ∞    1 3 3 3     0   1   ∞   1   2   ∞   2   ∞   ∞   3   4    1 3 3 3 4   0   1   ∞   1   2   2   2   2   3   3   3      状态迁移方程    dp[j] = min{dp[j],dp[j-stamp[i]]+1}    其中dp[j-stamp[i]]+1，表示将第i个邮票加入集合后 凑总量为j的面额 所需要的最少邮票数量*/#include&lt;stdio.h&gt;#define INF 1000int stamp[1000];int dp[1000];// 返回最少数量，num表示邮票的个数，deno表示要凑成的面额int Min_Stamp(int num,int deno){    int i,j;    //将状态全部初始化为最多    for(j=0;j&lt;=deno;++j){        dp[j]= (j==0)?0:INF;           }    for(i=0;i&lt;num;i++){        //从后向前寻找若能凑成，且使数量变少就使用，不能也无所谓因为还是INF        for(j=deno;j&gt;=stamp[i];j--){            if(dp[j-stamp[i]]!=INF)dp[j]=(dp[j] &lt; dp[j-stamp[i]]+1)? dp[j]: dp[j-stamp[i]]+1;        }    }    return dp[deno]==INF?0:dp[deno];}int main(){    int num,deno;    while(scanf(&quot;%d %d&quot;,&amp;deno,&amp;num)!=EOF){        for(int i=0;i&lt;num;i++)scanf(&quot;%d&quot;,stamp+i);        printf(&quot;%d&quot;,Min_Stamp(num,deno));    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点菜问题</title>
    <link href="/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    北大网络实验室经常有活动需要叫外卖，但是每次叫外卖的报销经费的总额最大为C元，有N种菜可以点，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大。     注意：由于需要营养多样化，每种菜只能点一次。</p><p><strong>输入描述:</strong><br>    输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。</p><p><strong>输出描述:</strong><br>    输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。</p><p><strong>输入</strong></p><blockquote><p>90 4<br>20 25<br>30 20<br>40 50<br>10 18<br>40 2<br>25 30<br>10 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>95 38</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//背包问题using namespace std;const int MAXN=1001;int dp[MAXN];int v[MAXN];//物品价值int w[MAXN];//物品重量int main(){    int n,m;    cin&gt;&gt;m&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=0;i&lt;=m;i++){        dp[i]=0;//初始化    }    for(int i=0;i&lt;n;i++){        for(int j=m;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[m]&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/14/Common%20Subsequence/"/>
    <url>/2020/02/14/Common%20Subsequence/</url>
    
    <content type="html"><![CDATA[<p><strong>Description</strong><br>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><p><strong>Input</strong><br>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><p><strong>Output</strong><br>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><p><strong>Sample Input</strong></p><blockquote><p>abcfbc            abfcab<br>programming    contest<br>abcd           mnp</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4<br>2<br>0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//最长公共子序列using namespace std;const int MAXN=1001;char s1[MAXN];char s2[MAXN];int dp[MAXN][MAXN];int main(){    while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入        int n=strlen(s1+1);        int m=strlen(s2+1);        for(int i=0;i&lt;=n;i++){            for(int j=0;j&lt;=m;j++){                if(i==0||j==0){//边界条件初始化                    dp[i][j]=0;                    continue;                }                //状态转移方程                if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK， 则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>输入描述:</strong><br>输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。<br>第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。</p><p><strong>输出描述:</strong><br>可能包括多组测试数据，对于每组数据，<br>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><p><strong>输入</strong></p><blockquote><p>8<br>186 186 150 200 160 130 197 220</p></blockquote><p><strong>输出</strong></p><blockquote><p>4</p></blockquote><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;int num[100];int dp1[100];int dp2[100];//枚举每个位置，从左边找最长上升子序列，从右边开始找最长下降子序列，两个数相加就是题目所说的唱歌的人数。int main(){    int count;    while(cin&gt;&gt;count){        for(int i=0;i&lt;count;i++){            cin&gt;&gt;num[i];        }        for(int i=0;i&lt;count;i++){            dp1[i]=1;            for(int j=0;j&lt;i;j++){                if(num[i]&gt;num[j]){                    dp1[i]=max(dp1[j]+1,dp1[i]);                }            }        }        for(int i=count-1;i&gt;=0;i--){            dp2[i]=1;            for(int j=count-1;j&gt;i;j--){                if(num[i]&gt;num[j]){                    dp2[i]=max(dp2[i],dp2[j]+1);                }            }        }        int total=0;        for(int i=0;i&lt;count;i++){//i此时是作为最中间的一个点            total=max(dp1[i]+dp2[i]-1,total);        }        cout&lt;&lt;count-total&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大上升子序列和</title>
    <link href="/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p><p><strong>输入描述:</strong><br>输入包含多组测试数据。<br>每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</p><p><strong>输出描述:</strong><br>对于每组测试数据，输出其最大上升子序列和。</p><p><strong>输入</strong></p><blockquote><p>7<br>1 7 3 5 9 4 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>18</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1001;int a[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=a[i];//初始化为a[i]            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列                if(a[i]&gt;a[j]){                    dp[i]=max(dp[i],dp[j]+a[i]);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拦截导弹</title>
    <link href="/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/"/>
    <url>/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。 </p><p><strong>输入描述:</strong><br>每组输入有两行，<br>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），<br>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p><p><strong>输出描述:</strong><br>每组输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p><p><strong>输入</strong></p><blockquote><p>8<br>300 207 155 300 299 170 158 65</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//动态规划：最长递增子序列//状态转移方程：dp[i]=max(1,dp[j]+1|j&lt;i&amp;&amp;Aj&gt;Ai)using namespace std;const int MAXN=25;int height[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;height[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=1;//初始化为1            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度                if(height[i]&lt;=height[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。<br><strong>输入描述:</strong><br>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。<br>再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。<br>已知矩阵中整数的范围都在[-127, 127]。<br><strong>输出描述:</strong><br>测试数据可能有多组，对于每组测试数据，输出最大子矩阵的大小。<br>示例1<br><strong>输入</strong></p><blockquote><p>4<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4  1<br>-1 8  0 -2</p></blockquote><p><strong>输出</strong></p><blockquote><p>15</p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN=100;int dp[MAXN];int arr[MAXN];int matrix[MAXN][MAXN];int total[MAXN][MAXN];//total[i][j]表示从这个元素往上的所有元素的和int MaxSubsequence(int n){    int maximum=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=arr[i];        else dp[i]=max(dp[i-1]+arr[i],arr[i]);        maximum=max(maximum,dp[i]);    }    return maximum;}int maxSubmatrix(int n){    int maximal=0;    for(int i=0;i&lt;n;i++){        for(int j=i;j&lt;n;j++){//            for(int k=0;k&lt;n;k++){//获得一维数组                if(i==0) arr[k]=total[j][k];                else arr[k]=total[j][k]-total[i-1][k];            }        int current =MaxSubsequence(n);        maximal = max(maximal,current);        }    }    return maximal;}int main(){    int N;    while(cin&gt;&gt;N){        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                cin&gt;&gt;matrix[i][j];            }        }        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                if(i==0) total[i][j]=matrix[i][j];                else total[i][j]=total[i-1][j]+matrix[i][j];            }        }        int result=maxSubmatrix(N);        cout&lt;&lt;result&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。<br><strong>输入描述:</strong><br>    测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。<br><strong>输出描述:</strong><br>    对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。<br><strong>输入</strong></p><blockquote><p>6<br>-2 11 -4 13 -5 -2 10<br>-10<br>1 2 3 4 -5 -23 3 7 -21<br>6<br>5 -8 3 2 5 0<br>1<br>10<br>3<br>-1 -5 -2<br>3<br>-1 0 -2<br>0</p></blockquote><p><strong>输出</strong></p><blockquote><p>20 11 13<br>10 1 4<br>10 3 5<br>10 10 10<br>0 -1 -2<br>0 0 0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=10000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];void maxSub(int n,int&amp; Max,int&amp; first,int&amp; last){    Max=0,first=0,last=n-1;    //第一次遍历找出最大子序列和    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    //第二次遍历确定最大子序列的两个边界    for(int i=0;i&lt;n;i++){        if(i==0){            dp[i]=a[i];        }        else if(dp[i-1]+a[i]&gt;a[i]){            last=i;//当前子序列继续扩充元素            dp[i]=dp[i-1]+a[i];        }        else{            first=i;//从当前的元素重新往后找，赋值first            dp[i]=a[i];        }        if(dp[i]==Max){            last=i;//此时已经找到最大的子序列，给last赋最终值            return;        }    }}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int Max,first,last;        maxSub(n,Max,first,last);        cout&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;a[first]&lt;&lt;&quot; &quot;&lt;&lt;a[last]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大序列和</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。<br><strong>输入描述</strong>:<br>第一行为一个正整数N，第二行为N个整数，表示序列中的数。<br><strong>输出描述:</strong><br>输入可能包括多组数据，对于每一组输入数据，<br>仅输出一个数，表示最大序列和。<br><strong>输入</strong></p><blockquote><p>5<br>1 5 -3 2 4<br>6<br>1 -2 3 4 -10 6<br>4<br>-3 -1 -2 -5</p></blockquote><p><strong>输出</strong></p><blockquote><p>9<br>7<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        cout&lt;&lt;maxSub(n)&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文</title>
    <link href="/2020/02/11/%E8%AE%BA%E6%96%87/"/>
    <url>/2020/02/11/%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>小H为了完成一篇论文，一共要完成n个实验。其中第i个实验需要ai的时间去完成。小H可以同时进行若干实验，但存在一些实验，只有当它的若干前置实验完成时，才能开始进行该实验。同时我们认为小H在一个实验的前置实验都完成时，就能马上开始该实验。为了让小H尽快完成论文，需要知道在最优的情况下，最后一个完成的实验什么时候完成？小H还想知道，在保证最后一个实验尽快完成的情况下（即保证上一问的答案不变），他想知道每个实验最晚可以什么时候开始。设第i个实验最早可能的开始时间为fi，不影响最后一个实验完成时间的最晚开始时间为gi，请你证明<img src="https://img-blog.csdnimg.cn/20200211171228484.png" srcset="/img/loading.gif" alt="">除以10^9+7所得的余数。题目保证有解。</p><p><strong>输入描述:</strong><br>从标准输入读入数据。<br>第一行输入一个整数n，m。<br>第二行输入n个正整数，a1,a2,…..an,描述每个实验完成所需要的时间。<br>接下来读入m行，每行读入两个整数u,v，表示编号为u的实验是编号为v的实验的前置实验。<br>对于所有的输入数据，都满足1&lt;=n&lt;=10^5,1&lt;=m&lt;=5<em>10^5,1&lt;=ai&lt;=10^6。<br>*</em>输出描述:**<br>输出到标准输出。<br>第一行输出一个整数表示最晚完成的实验的时间。<br>第二行输出一个整数表示除以10^9+7所得的余数。<br>输入输出样例<br><strong>输入样例#:</strong></p><blockquote><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p></blockquote><p><strong>输出样例#:</strong></p><blockquote><p>34<br>7840</p></blockquote><p>提示：<br>第一个点最早开始时间为20，最晚开始时间为23。<br>第二个点最早开始时间为0，最晚开始时间为3。<br>第三个点最早开始时间为17，最晚开始时间为17。<br>第四个点最早开始时间为20，最晚开始时间为24。<br>第五个点最早开始时间为0，最晚开始时间为13。<br>第六个点最早开始时间为0，最晚开始时间为6。<br>第七个点最早开始时间为0，最晚开始时间为0。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1e5+7;const int INF=INT_MAX;const int MOD=1e9+7;vector&lt;int&gt; graph[MAXN];//邻接表long long earliest[MAXN];//最早开始时间long long latest[MAXN];//最晚开始时间long long time[MAXN];//花费时间int inDegree[MAXN];long long CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=1;i&lt;=n;i++){        if(inDegree[i]==0){            node.push(i);        }    }    long long totalTime=0;//总耗时    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i];            earliest[v]=max(earliest[v],earliest[u]+time[u]);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0){                node.push(v);                totalTime=max(totalTime,earliest[v]+time[v]);            }        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=totalTime-time[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j];            latest[u]=min(latest[u],latest[v]-time[u]);//逆向找最小，形成latest        }    }    return totalTime;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        memset(time,0,sizeof(time));        for(int i=1;i&lt;=n;i++){            cin&gt;&gt;time[i];        }        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;        }        long long totalTime=CriticalPath(n);        long long answer=1;        for(int i=1;i&lt;=n;i++){            answer*=latest[i]-earliest[i]+1;            answer%=MOD;        }        cout&lt;&lt;totalTime&lt;&lt;endl;        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction Arrangement</title>
    <link href="/2020/02/11/Instruction%20Arrangement/"/>
    <url>/2020/02/11/Instruction%20Arrangement/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>Ali has taken the Computer Organization and Architecture course this term. He learned that there may be dependence between instructions, like WAR (write after read), WAW, RAW.<br>If the distance between two instructions is less than the Safe Distance, it will result in hazard, which may cause wrong result. So we need to design special circuit to eliminate hazard. However the most simple way to solve this problem is to add bubbles (useless operation), which means wasting time to ensure that the distance between two instructions is not smaller than the Safe Distance.<br>The definition of the distance between two instructions is the difference between their beginning times.<br>Now we have many instructions, and we know the dependent relations and Safe Distances between instructions. We also have a very strong CPU with infinite number of cores, so you can run as many instructions as you want simultaneity, and the CPU is so fast that it just cost 1ns to finish any instruction.<br>Your job is to rearrange the instructions so that the CPU can finish all the instructions using minimum time.<br><strong>Input</strong><br>The input consists several testcases.<br>The first line has two integers N, M (N &lt;= 1000, M &lt;= 10000), means that there are N instructions and M dependent relations.<br>The following M lines, each contains three integers X, Y , Z, means the Safe Distance between X and Y is Z, and Y should run after X. The instructions are numbered from 0 to N - 1.<br><strong>Output</strong><br>Print one integer, the minimum time the CPU needs to run.</p><p><strong>Sample Input</strong></p><blockquote><p>5 2<br>1 2 1<br>3 4 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Hint</strong><br>In the 1st ns, instruction 0, 1 and 3 are executed;<br>In the 2nd ns, instruction 2 and 4 are executed.<br>So the answer should be 2.</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1001;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to(t),length(l){}};vector&lt;Edge&gt; graph[MAXN];//邻接表int earliest[MAXN];//最早开始时间int latest[MAXN];//最晚开始时间int inDegree[MAXN];void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            inDegree[to]++;        }        CriticalPath(n);        int answer=0;        for(int i=0;i&lt;n;i++){            answer=max(answer,earliest[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jungle roads</title>
    <link href="/2020/02/10/Jungle%20roads/"/>
    <url>/2020/02/10/Jungle%20roads/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br><img src="https://img-blog.csdnimg.cn/20200210210056936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.<br><strong>Input</strong><br>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.<br><strong>Output</strong><br>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. </p><p><strong>Sample Input</strong></p><blockquote><p>9<br>A 2 B 12 I 25<br>B 3 C 10 H 40 I 8<br>C 2 D 18 G 55<br>D 1 E 44<br>E 2 F 60 G 38<br>F 0<br>G 1 H 35<br>H 1 I 35<br>3 A 2 B 10 C 40<br>B 1 C 20<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>216<br>30</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;struct Edge{    int from;    int to;    int length;    bool operator&lt;(const Edge&amp; e) const{//жиди&lt;a        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(father[x]!=x) return Find(father[x]);    else return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;        else{            father[y]=x; height[x]++;        }    }}int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        int k=0;        for(int i=0;i&lt;n-1;i++){            char v; int num;            cin&gt;&gt;v&gt;&gt;num;            for(int j=0;j&lt;num;j++){                char v1; int length;                cin&gt;&gt;v1&gt;&gt;length;                edge[k].from=i;                edge[k].to=v1-&#39;A&#39;;                edge[k].length=length;                k++;            }        }        int answer=Kruskal(n,k);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最小生成树</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>畅通工程续</title>
    <link href="/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/"/>
    <url>/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p><p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p><p><strong>Input</strong><br>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p><p><strong>Output</strong><br>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.<br><strong>Sample Input</strong></p><blockquote><p>3 3<br>0 1 1<br>0 2 3<br>1 2 1<br>0 2<br>3 1<br>0 1 1<br>1 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;climits&gt;using namespace std;const int MAXN=200;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to{t},length(l){}};struct Point{    int number;    int distance;    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; p) const{        return distance&gt;p.distance;    }};vector&lt;Edge&gt; graph[MAXN];   //邻接表实现的图，数组中是点，而每一个点后面都跟了一个vectorint dis[MAXN];void Dijkstra(int s){    priority_queue&lt;Point&gt; pqueue;    dis[s]=0;    pqueue.push(Point(s,dis[s]));    while(!pqueue.empty()){        int u=pqueue.top().number;//离源点最近的点        pqueue.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;//u为顶点的编号，i为边的序号            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){                dis[v]=dis[u]+d;                pqueue.push(Point(v,dis[v]));            }        }    }    return ;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));//图初始化        fill(dis,dis+n,INF);//距离初始化为无穷        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            graph[to].push_back(Edge(from,length));        }        int s,t;        cin&gt;&gt;s&gt;&gt;t;        Dijkstra(s);        if(dis[t]==INF) dis[t]=-1;        cout&lt;&lt;dis[t]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>确定比赛名次</title>
    <link href="/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/"/>
    <url>/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p><p><strong>Input</strong><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p><p><strong>Output</strong><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><p><strong>Sample Input</strong></p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 2 4 3</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];//邻接表的实现int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        if(n==0&amp;&amp;m==0) break;        memset(graph,0,sizeof(graph));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;//在输入时更新入度数组        }        vector&lt;int&gt; answer=TopologicalSort(n);        for(int i=0;i&lt;answer.size();i++){            if(i==0) cout&lt;&lt;answer[i];            else cout&lt;&lt;&quot; &quot;&lt;&lt;answer[i];        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量修改XML中的标签值</title>
    <link href="/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/"/>
    <url>/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>因为用labelimg给图片打标签的时候打错了，本来是water dispenser弄成了drinking_fountain了，尴尬_(:з)∠)_，并且已经标了1500张了，只能自己写程序改，xml文件示例如下：</p><pre><code class="cpp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;us-ascii&#39;?&gt;&lt;annotation verified=&quot;no&quot;&gt;  &lt;folder&gt;drinking_fountain&lt;/folder&gt;  &lt;filename&gt;1&lt;/filename&gt;  &lt;path&gt;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain\1.jpg&lt;/path&gt;  &lt;source&gt;    &lt;database&gt;Unknown&lt;/database&gt;  &lt;/source&gt;  &lt;size&gt;    &lt;width&gt;720&lt;/width&gt;    &lt;height&gt;1280&lt;/height&gt;    &lt;depth&gt;3&lt;/depth&gt;  &lt;/size&gt;  &lt;segmented&gt;0&lt;/segmented&gt;  &lt;object&gt;    &lt;name&gt;drinking_fountain&lt;/name&gt;    &lt;pose&gt;Unspecified&lt;/pose&gt;    &lt;truncated&gt;0&lt;/truncated&gt;    &lt;difficult&gt;0&lt;/difficult&gt;    &lt;bndbox&gt;      &lt;xmin&gt;153&lt;/xmin&gt;      &lt;ymin&gt;6&lt;/ymin&gt;      &lt;xmax&gt;587&lt;/xmax&gt;      &lt;ymax&gt;1157&lt;/ymax&gt;    &lt;/bndbox&gt;  &lt;/object&gt;&lt;/annotation&gt;</code></pre><p>用来修改的python代码的如下：</p><pre><code class="cpp">import osimport os.pathfrom xml.etree.ElementTree import parse, Element#批量修改xml中内容def test():    path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;#xml文件所在的目录    files = os.listdir(path)  # 得到文件夹下所有文件名称    s = []    for xmlFile in files:  # 遍历文件夹        if not os.path.isdir(xmlFile):  # 判断是否是文件夹,不是文件夹才打开            print            xmlFile            pass        path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;        print(xmlFile)        path1 = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;+xmlFile#定位当前处理的文件的路径        newStr = os.path.join(path, xmlFile)        name = &quot;water dispenser&quot;        dom = parse(newStr)  ###最核心的部分,路径拼接,输入的是具体路径        root = dom.getroot()        print(root)        for obj in root.iter(&#39;object&#39;):#获取object节点中的name子节点            obj.find(&#39;name&#39;).text=name            name1 = obj.find(&#39;name&#39;).text#修改            print(name1)        dom.write(path1, xml_declaration=True)#保存到指定文件        passif __name__ == &#39;__main__&#39;:    test()</code></pre>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约瑟夫问题no_2</title>
    <link href="/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/"/>
    <url>/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h4><p>n 个小孩围坐成一圈，并按顺时针编号为1,2,…,n，从编号为 p 的小孩顺时针依次报数，由1报到m ，当报到 m 时，该小孩从圈中出去，然后下一个再从1报数，当报到 m 时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a><strong>Input:</strong></h4><p>每行是用空格分开的三个整数，第一个是n,第二个是p,第三个是m (0 &lt; m,n &lt; 300)。最后一行是: 0 0 0</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>按出圈的顺序输出编号，编号之间以逗号间隔。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><blockquote><p>8 3 4<br>0 0 0</p></blockquote><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h4><blockquote><p>6,2,7,4,3,5,1,8</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;//用循环队列的方式解决约瑟夫问题int main(){    int n,p,m;    while(cin&gt;&gt;n&gt;&gt;p&gt;&gt;m){        queue&lt;int&gt; children;        for(int i=1;i&lt;=n;i++){            children.push(i);        }        //使编号为p的小孩放在队首        for(int i=1;i&lt;p;i++){            //这两句实现了循环队列，将要pop出去的再次放入队尾            children.push(children.front());            children.pop();        }        //m-1个小孩重新入队        while(!children.empty()){            for(int i=1;i&lt;m;i++){                children.push(children.front());                children.pop();            }            //将第m个小孩出队            if(children.size()==1) cout&lt;&lt;children.front()&lt;&lt;endl;            else cout&lt;&lt;children.front();            children.pop();        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫爬取全国历史天气数据</title>
    <link href="/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>一段很简单的爬虫程序，爬取的网站为<a href="http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据" target="_blank" rel="noopener">http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据</a></p><pre><code class="cpp">from bs4 import BeautifulSoupimport requestsimport pymysqlimport warnings# import pinyin# from pinyin import PinYinfrom pypinyin import pinyin, lazy_pinyinimport pypinyinwarnings.filterwarnings(&quot;ignore&quot;)conn = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, passwd=&#39;root&#39;, db=&#39;test2&#39;, port=3306, charset=&#39;utf8&#39;)cursor = conn.cursor()def get_temperature(url,city):    headers = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,  like Gecko) Chrome/63.0.3239.132 Safari/537.36&#39;}           # 设置头文件信息    response = requests.get(url,  headers=headers).content    # 提交requests get 请求    soup = BeautifulSoup(response,  &quot;lxml&quot;)       # 用Beautifulsoup 进行解析    conmid2 = soup.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    # conmid2 = conmid.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    for info in conmid2:        tr_list = info.find_all(&#39;tr&#39;)[1:]       # 使用切片取到第三个tr标签        for index,  tr in enumerate(tr_list):     # enumerate可以返回元素的位置及内容            td_list = tr.find_all(&#39;td&#39;)            # if index == 0:            date = td_list[0].text.strip().replace(&quot;\n&quot;, &quot;&quot;)  # 取每个标签的text信息，并使用replace()函数将换行符删除            weather = td_list[1].text.strip().replace(&quot;\n&quot;, &quot;&quot;).split(&quot;/&quot;)[0].strip()            temperature = td_list[2].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            wind = td_list[3].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            # else:            #     city_name = td_list[0].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     weather = td_list[4].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     wind = td_list[5].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     max = td_list[3].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     min = td_list[6].text.replace(&#39;\n&#39;,  &#39;&#39;)            print(city,date,  weather,  wind,  temperature)            cursor.execute(&#39;insert into weather(city, date, weather, wind, temp) values(%s, %s, %s, %s, %s)&#39;                           ,  (city,  date,  weather,  wind,  temperature ))if __name__==&#39;__main__&#39;:    # citys1= [&quot;成都市&quot;,&quot;广元市&quot;,&quot;绵阳市&quot;,&quot;德阳市&quot;,&quot;南充市&quot;,&quot;广安市&quot;,&quot;遂宁市&quot;,&quot;内江市&quot;,&quot;乐山市&quot;,&quot;自贡市&quot;,&quot;泸州市&quot;,&quot;宜宾市&quot;,&quot;攀枝花市&quot;,&quot;巴中市&quot;,&quot;达州市&quot;,&quot;资阳市&quot;,&quot;眉山市&quot;,&quot;雅安市&quot;,&quot;崇州市&quot;,&quot;邛崃市&quot;,&quot;都江堰市&quot;,&quot;彭州市&quot;,&quot;江油市&quot;,&quot;什邡市&quot;,&quot;广汉市&quot;,&quot;绵竹市&quot;,&quot;阆中市&quot;,&quot;华蓥市&quot;,&quot;峨眉山市&quot;,&quot;万源市&quot;,&quot;简阳市&quot;,&quot;西昌市&quot;,&quot;康定市&quot;,&quot;马尔康市&quot;,&quot;隆昌市&quot;]    # citys1= [&quot;郑州市&quot;,&quot;开封市&quot;,&quot;洛阳市&quot;,&quot;平顶山市&quot;,&quot;安阳市&quot;,&quot;鹤壁市&quot;,&quot;新乡市&quot;,&quot;焦作市&quot;,&quot;濮阳市&quot;,&quot;许昌市&quot;,&quot;漯河市&quot;,&quot;三门峡市&quot;,&quot;南阳市&quot;,&quot;商丘市&quot;,&quot;周口市&quot;,&quot;驻马店市&quot;,&quot;信阳市&quot;,&quot;荥阳市&quot;,&quot;新郑市&quot;,&quot;登封市&quot;,&quot;新密市&quot;,&quot;偃师市&quot;,&quot;孟州市&quot;,&quot;沁阳市&quot;,&quot;卫辉市&quot;,&quot;辉县市&quot;,&quot;林州市&quot;,&quot;禹州市&quot;,&quot;长葛市&quot;,&quot;舞钢市&quot;,&quot;义马市&quot;,&quot;灵宝市&quot;,&quot;项城市&quot;,&quot;巩义市&quot;,&quot;邓州市&quot;,&quot;永城市&quot;,&quot;汝州市&quot;,&quot;济源市&quot;]    # citys1= [&quot;呼和浩特市&quot;,&quot;包头市&quot;,&quot;乌海市&quot;,&quot;赤峰市&quot;,&quot;通辽市&quot;,&quot;鄂尔多斯市&quot;,&quot;呼伦贝尔市&quot;,&quot;巴彦淖尔市&quot;,&quot;乌兰察布市&quot;,&quot;霍林郭勒市&quot;,&quot;满洲里市&quot;,&quot;牙克石市&quot;,&quot;扎兰屯市&quot;,&quot;额尔古纳市&quot;,&quot;根河市&quot;,&quot;丰镇市&quot;,&quot;乌兰浩特市&quot;,&quot;阿尔山市&quot;,&quot;二连浩特市&quot;,&quot;锡林浩特市&quot;]    # citys1= [&quot;沈阳市&quot;,&quot;大连市&quot;,&quot;鞍山市&quot;,&quot;抚顺市&quot;,&quot;本溪市&quot;,&quot;丹东市&quot;,&quot;锦州市&quot;,&quot;营口市&quot;,&quot;阜新市&quot;,&quot;辽阳市&quot;,&quot;盘锦市&quot;,&quot;铁岭市&quot;,&quot;朝阳市&quot;,&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    # citys1= [&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    citys1= [&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    for city in citys1:        city1 = &#39;&#39;.join(lazy_pinyin(city[:-1]))        print(city1)        urls = [&#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201801.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201802.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201803.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201804.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201805.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201806.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201807.html&#39;]        for url in urls:            get_temperature(url, city)        conn.commit()</code></pre>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
