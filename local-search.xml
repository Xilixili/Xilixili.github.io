<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>USTC机试_08下</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8B/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.输入十进制正整数将其转换成任意的进制</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; v;int main(){    int n,m;    cin&gt;&gt;n;    cout&lt;&lt;&quot;进制:&quot;;    cin&gt;&gt;m;    while(n!=0){        v.push_back(n%m);        n/=m;    }    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i];    }}</code></pre><p>2.从文件读入 2个矩阵，转置后相加再输出</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;const int n=3;const int m=2;int matrix1[n][m];int matrix2[n][m];int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    for(int i=0;i&lt;m;i++){        getline(infile,s);        for(int j=0;j&lt;n;j++){            if(s.find(&quot; &quot;)!=string::npos){                int pos=s.find(&quot; &quot;);                matrix1[j][i]=atoi((char*)s.substr(0,pos).data());//转置                s=s.substr(pos+1);            }            else{                matrix1[j][i]=atoi((char*)s.data());            }        }    }    for(int i=0;i&lt;n;i++){        getline(infile,s);        for(int j=0;j&lt;m;j++){            if(s.find(&quot; &quot;)!=string::npos){                int pos=s.find(&quot; &quot;);                matrix2[i][j]=atoi((char*)s.substr(0,pos).data());                s=s.substr(pos+1);            }            else{                matrix2[i][j]=atoi((char*)s.data());            }        }    }    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            cout&lt;&lt;matrix1[i][j]+matrix2[i][j]&lt;&lt;&quot; &quot;;        }        cout&lt;&lt;endl;    }}</code></pre><p>3.读入一个文件，第一行是字符串集合个数，第二行到第五行是这四个集合，从中<br>找到，字符串集合中出现两次的字符串，然后标识出第几个集合（行数）</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt; m;void Count1(string key){    if(m.find(key)==m.end()){//没找到这个key        m.insert(pair&lt;string,int&gt;(key,1));    }    else{//已经存在这个key        m[key]=m[key]+1;    }}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=0;i&lt;n;i++){        getline(infile,s);        while(s.size()&gt;0){            if(s.find(&quot; &quot;)!=string::npos){//                int pos=s.find(&quot; &quot;);                string key=s.substr(0,pos);                Count1(key);                s=s.substr(pos+1);            }            else{                string key=s;                Count1(key);                s=s.substr(s.size());//为了能跳出循环            }        }    }    map&lt;string,int&gt;::iterator it;    for(it=m.begin();it!=m.end();it++){//        if(it-&gt;second==2){            ifstream in(&quot;in.txt&quot;);            string s; int i=0;            getline(in,s);            while(getline(in,s)){                i++;                if(s.find(it-&gt;first)!=string::npos){                    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;i; break;                }            }            in.close();            cout&lt;&lt;endl;        }    }}</code></pre><p>4.给一个先序(中序)遍历序列，按层次输出该树的结点</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;string pre;string in;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};void LevelOrder(TreeNode* T){    queue&lt;TreeNode*&gt; q;    q.push(T);    while(!q.empty()){        TreeNode* p=q.front();        cout&lt;&lt;p-&gt;data;        q.pop();        if(p-&gt;left) q.push(p-&gt;left);        if(p-&gt;right) q.push(p-&gt;right);    }    return ;}TreeNode* build(int l1,int h1,int l2,int h2){//前序中序建树    char c=pre[l1];    TreeNode* T=new TreeNode(c);    int i;    for(i=l2;in[i]!=c;i++) ;    int llen=i-l2;    int rlen=h2-i;    if(llen) T-&gt;left=build(l1+1,l1+llen,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=build(h1-rlen+1,h1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}int main(){    cin&gt;&gt;pre&gt;&gt;in;    TreeNode* root=build(0,pre.size()-1,0,in.size()-1);    LevelOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_08上</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8A/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_08%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>1.一个十进制正整数转换成二进制有多少个1</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int main(){    int x;    cin&gt;&gt;x;    int Count=0;    while(x!=0){        if(x%2==1) Count++;        x/=2;    }    cout&lt;&lt;Count;}</code></pre><p>2.约瑟夫环问题</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;using namespace std;int main(){    queue&lt;int&gt; q;    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=1;i&lt;=n;i++){        q.push(i);    }    int m=4;    while(!q.empty()){        for(int i=1;i&lt;m;i++){            int k=q.front();            q.pop();            q.push(k);        }        cout&lt;&lt;q.front();        q.pop();    }}</code></pre><p>3.从文件读入 2个矩阵，输出矩阵相乘后的矩阵</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;int matrix1[3][3];int matrix2[3][2];int matrix3[3][2];int main(){    ifstream infile(&quot;in.txt&quot;);    ofstream outfile(&quot;out.txt&quot;);    string s;    for(int i=0;i&lt;3;i++){        getline(infile,s);        int j;        for(j=0;j&lt;2;j++){            int pos=s.find(&quot; &quot;);            matrix1[i][j]=atoi((char*)s.substr(0,pos).data());            s=s.substr(pos+1);        }        matrix1[i][j]=atoi((char*)s.data());    }    for(int i=0;i&lt;3;i++){        getline(infile,s);        int j;        for(j=0;j&lt;1;j++){            int pos=s.find(&quot; &quot;);            matrix2[i][j]=atoi((char*)s.substr(0,pos).data());            s=s.substr(pos+1);        }        matrix2[i][j]=atoi((char*)s.data());    }    infile.close();    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;2;j++){//前两个for为最终矩阵的每一个位置            int temp=0;            for(int k=0;k&lt;3;k++){                temp+=matrix1[i][k]*matrix2[k][j];//            }            matrix3[i][j]=temp;        }    }    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;2;j++){            outfile&lt;&lt;matrix3[i][j]&lt;&lt;&quot; &quot;;        }        outfile&lt;&lt;endl;    }}</code></pre><p>4.符串问题。从文件中读入几行英文句子。输出单词，行号，并按单词字典索<br>引。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;map&lt;string,int&gt; m;//写成计数了，不过字典索引也不难，懒得改了void Count(string key){    if(m.find(key)==m.end()){//没找到这个key        m.insert(pair&lt;string,int&gt;(key,1));    }    else{//已经存在这个key        cout&lt;&lt;&quot;存在&quot;&lt;&lt;key&lt;&lt;&quot;:&quot;&lt;&lt;m[key]&lt;&lt;endl;        m[key]=m[key]+1;    }}int main(){    string s;    ifstream infile(&quot;in.txt&quot;);    getline(infile,s);    int n=atoi((char*)s.data());    for(int i=0;i&lt;n;i++){        getline(infile,s);        while(s.size()&gt;0){            cout&lt;&lt;s&lt;&lt;endl;            if(s.find(&quot; &quot;)!=string::npos){//                int pos=s.find(&quot; &quot;);                string key=s.substr(0,pos);                Count(key);                s=s.substr(pos+1);            }            else{                string key=s;                Count(key);                s=s.substr(s.size());//为了能跳出循环            }        }    }    map&lt;string,int&gt;::iterator it;    for(it=m.begin();it!=m.end();it++){//        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_07下</title>
    <link href="/2020/02/23/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8B/"/>
    <url>/2020/02/23/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.输入字符串，倒序输出，例如：输入 I come from China.输出 China from come I.（单词不需倒序，只是句子倒了）</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main(){    string s;    getline(cin,s);    vector&lt;string&gt; v;    while(s.find(&#39; &#39;)!=string::npos){        int pos=s.find(&#39; &#39;);        v.push_back(s.substr(0,pos));        s=s.substr(pos+1);    }    v.push_back(s);    for(int i=v.size()-1;i&gt;=0;i--){        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;    }}</code></pre><p>2.输入一个数判断是不是完数，是输出 yes，不是输出  no</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int fenjie(int x){    int sum=0;    for(int i=1;i&lt;=x/2;i++){        if(x%i==0) sum+=i;    }    return sum;}int main(){    int x;    cin&gt;&gt;x;    if(fenjie(x)==x) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;}</code></pre><p>3.件读取一个文件，做无向图的广度遍历输出，文件的第一行是图的节点个<br>数，后面是边的信息，0 0表示结束</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;const int MAXN=100;int visit[MAXN];vector&lt;int&gt; G[MAXN];void BFS(int x){//传过来的起始点    queue&lt;int&gt; q;    q.push(x);    visit[x]=true;    while(!q.empty()){//队列        int current=q.front();        cout&lt;&lt;current&lt;&lt;&quot; &quot;;        q.pop();        for(int i=0;i&lt;G[current].size();i++){            if(!visit[G[current][i]]){                //cout&lt;&lt;&quot;没访问&quot;&lt;&lt;G[current][i]&lt;&lt;&quot; &quot;;                q.push(G[current][i]);                visit[G[current][i]]=true;            }        }        //cout&lt;&lt;endl;    }}int main(){    //memset(visit,false,sizeof(visit));//在cstring中    ifstream infile(&quot;in.txt&quot;);//在fstream中    string line;//std::string类似通常的字符数组    string n;    getline(infile,n);    while(getline(infile,line)){        int pos=line.find(&quot; &quot;);        //atoi中要将string转化为char*        int a=atoi((char*)line.substr(0,pos).data());        int b=atoi((char*)line.substr(pos+1).data());        //cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;        G[a].push_back(b);        G[b].push_back(a);    }    BFS(1);}</code></pre><p>4.没有括号只有加减乘除的表达式求值，表达式从文件读入，计算的结果<br>输出到文件上。</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100;char out[MAXN];//存储逆波兰式stack&lt;char&gt; s1;//生成逆波兰式stack&lt;double&gt; s2;//计算逆波兰式int Priority(char c){    if(c==&#39;*&#39;||c==&#39;/&#39;) return 2;    else if(c==&#39;+&#39;||c==&#39;-&#39;)return 1;    else if(c==&#39;#&#39;) return 3;    else return 0;}bool isop(char c){    return c==&#39;+&#39;||c==&#39;-&#39;||c==&#39;*&#39;||c==&#39;/&#39;;}double cal(double x,double y,char op){    if(op==&#39;+&#39;)return x+y;    else if(op==&#39;-&#39;) return x-y;    else if(op==&#39;*&#39;) return x*y;    else if(op==&#39;/&#39;) return x/y;}void RePolish(string s){    int j=0;//指向out    for(int i=0;i&lt;s.size();i++){        //if(!s1.empty()) cout&lt;&lt;&quot;栈顶：&quot;&lt;&lt;s1.top();        if(isdigit(s[i])){            //cout&lt;&lt;&quot;数字:&quot;&lt;&lt;s[i];            out[j++]=s[i];        }        else if(isop(s[i])){            //cout&lt;&lt;&quot;操作符:&quot;&lt;&lt;s[i];            if(s1.empty()) s1.push(s[i]);            else if(Priority(s[i])&gt;Priority(s1.top())){                s1.push(s[i]);            }            else{                while(!s1.empty()&amp;&amp;Priority(s[i])&lt;=Priority(s1.top())){//这里是&lt;=，先进的优先级更高                    out[j++]=s1.top();                    //cout&lt;&lt;&quot;此时栈顶&quot;&lt;&lt;s1.top();                    s1.pop();                }                s1.push(s[i]);            }        }    }    while(!s1.empty()){        out[j++]=s1.top();        s1.pop();    }    return ;}void Calculate(){//根据逆波兰式求值    for(int i=0;i&lt;strlen(out);i++){        if(isdigit(out[i])) s2.push((double)out[i]-&#39;0&#39;);        else if(isop(out[i])){            double b=(double)s2.top(); s2.pop();            double a=(double)s2.top(); s2.pop();            s2.push(cal(a,b,out[i]));        }    }    cout&lt;&lt;s2.top();}int main(){    ifstream infile(&quot;in.txt&quot;);    string s;    getline(infile,s);    RePolish(s);    for(int i=0;i&lt;strlen(out);i++){//char*要用strlen而不是.size        cout&lt;&lt;out[i];    }    cout&lt;&lt;endl;    Calculate();}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准c++中string类函数介绍</title>
    <link href="/2020/02/22/%E6%A0%87%E5%87%86c++%E4%B8%ADstring%E7%B1%BB%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/02/22/%E6%A0%87%E5%87%86c++%E4%B8%ADstring%E7%B1%BB%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>注意不是CString<br>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必 担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。</p><p>好了，进入正题………<br>首先，为了在我们的程序中使用string类型，我们必须包含头文件 <string>。</p><p>如下：<br>#include <string> //注意这里不是string.h string.h是C字符串头文件<br>#include <string><br>using namespace std;</p><p><strong>1．声明一个C++字符串</strong><br>声明一个字符串变量很简单：<br>string Str;<br>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：<br>a)      string s;    //生成一个空字符串s<br>b)      string s(str) //拷贝构造函数 生成str的复制品<br>c)      string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值<br>d)      string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值<br>e)      string s(cstr) //将C字符串作为s的初值<br>f)      string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。<br>g)      string s(num,c) //生成一个字符串，包含num个c字符<br>h)      string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值<br>i)      s.~string() //销毁所有字符，释放内存<br>都很简单，我就不解释了。</p><p><strong>2．字符串操作函数</strong><br>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。<br>a) =,assign()     //赋以新值<br>b) swap()     //交换两个字符串的内容<br>c) +=,append(),push_back() //在尾部添加字符<br>d) insert() //插入字符<br>e) erase() //删除字符<br>f) clear() //删除全部字符<br>g) replace() //替换字符<br>h) + //串联字符串<br>i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()    //比较字符串<br>j) size(),length()    //返回字符数量<br>k) max_size() //返回字符的可能最大个数<br>l) empty()    //判断字符串是否为空，是空时返回ture，不是空时返回false<br>m) capacity() //返回重新分配之前的字符容量<br>n) reserve() //保留一定量内存以容纳一定数量的字符<br>o) [ ], at() //存取单一字符<br>p) &gt;&gt;,getline() //从stream读取某值<br>q) &lt;&lt;    //将谋值写入stream<br>r) copy() //将某值赋值为一个C_string<br>s) c_str() //将内容以C_string返回<br>t) data() //将内容以字符数组形式返回<br>u) substr() //返回某个子字符串<br>v)查找函数<br>w)begin() end() //提供类似STL的迭代器支持<br>x) rbegin() rend() //逆向迭代器<br>y) get_allocator() //返回配置器</p><p>下面详细介绍：</p><p><strong>2．1 C++字符串和C字符串的转换</strong><br>C ++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’/0’。c_str()返回一个以‘/0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string或 字符数组内。C++字符串并不以’/0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</p><p><strong>2．2 大小和容量函数</strong><br>一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定， 默认参数为0，这时候会对string进行非强制性缩减。</p><p>还有必要再重复一下C++字符串和C字符串转换的问 题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数Connect(char<em>,char</em>)），但别人的函数参 数用的是char<em>形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char</em>,要想作为上面提及的函数的参数，还必须拷贝到一个char<em>,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果 此函数对参数(也就是char</em>)的内容不修改的话，我们可以这样Connect((char<em>)UserID.c_str(), (char</em>)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char<em>上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char</em>上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</p><p><strong>2．3元素存取</strong><br>我们可以使用下标操作符[]和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用 at()的时候索引无效，会抛出out_of_range异常。</p><p>有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’/0’。其他的各种情况，a.length()索引都是无效的。举例如下：<br>const string Cstr(“const string”);<br>string Str(“string”);<br>Str[3];      //ok<br>Str.at(3);    //ok<br>Str[100]; //未定义的行为<br>Str.at(100);    //throw out_of_range<br>Str[Str.length()]    //未定义行为<br>Cstr[Cstr.length()] //返回 ‘/0’<br>Str.at(Str.length());//throw out_of_range<br>Cstr.at(Cstr.length()) ////throw out_of_range<br>我不赞成类似于下面的引用或指针赋值：<br>char&amp; r=s[2];<br>char* p= &amp;s[3];<br>因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</p><p><strong>2．4比较函数</strong><br>C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string (“aaaa”) &lt;string(aaaaa)。</p><p>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：<br>string s(“abcd”);<br>s.compare(“abcd”); //返回0<br>s.compare(“dcba”); //返回一个小于0的值<br>s.compare(“ab”); //返回大于0的值<br>s.compare(s); //相等<br>s.compare(0,2,s,2,2); //用”ab”和”cd”进行比较 小于零<br>s.compare(1,2,”bcx”,2); //用”bc”和”bc”比较。<br>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？靠，你重修吧！</p><p><strong>2．5 更改内容</strong><br>这在字符串的操作中占了很大一部分。<br>首先讲赋值，第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：<br>s.assign(str); //不说<br>s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串<br>s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给s<br>s.assign(“gaint”); //不说<br>s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘/0’赋给字符串<br>s.assign(5,’x’);//把五个x赋给字符串<br>把字符串清空的方法有三个：s=””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。<br>string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。<br>先说增加字符（这里说的增加是在尾巴上），函数有 +=、append()、push_back()。</p><p>举例如下：<br>s+=str;//加个字符串<br>s+=”my name is jiayp”;//加个C字符串<br>s+=’a’;//加个字符<br>s.append(str);<br>s.append(str,1,3);//不解释了 同前面的函数参数assign的解释<br>s.append(str,2,string::npos)//不解释了<br>s.append(“my name is jiayp”);<br>s.append(“nico”,5);<br>s.append(5,’x’);<br>s.push_back(‘a’);//这个函数只能增加单个字符对STL熟悉的理解起来很简单</p><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。<br>      s.insert(0,”my name”);<br>      s.insert(1,str);<br>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插 入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1, ‘j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指 出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</p><p>删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。</p><p>举例吧：<br>string s=”il8n”;<br>s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_string<br>s.erase(13);//从索引13开始往后全删除<br>s.erase(7,5);//从索引7开始往后删5个</p><p><strong>2．6提取子串和字符串连接</strong><br>题取子串的函数是：substr(),形式如下：<br>s.substr();//返回s的全部内容<br>s.substr(11);//从索引11往后的子串<br>s.substr(5,6);//从索引5开始6个字符<br>把两个字符串结合起来的函数是+。（谁不明白请致电120）</p><p><strong>2．7输入输出操作</strong><br>1．&gt;&gt; 从输入流读取一个string。<br>2．&lt;&lt; 把一个string写入输出流。<br>另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</p><p><strong>2．8搜索与查找</strong><br>查找函数很多，功能也很强大，包括了：<br>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。</p><p>最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)== string::npos)）。</p><p>string类的构造函数：<br>string(const char *s);    //用c字符串s初始化<br>string(int n,char c);     //用n个字符c初始化<br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常</p><p>string类的字符操作：<br>const char &amp;operator[](int n)const;<br>const char &amp;at(int n)const;<br>char &amp;operator[](int n);<br>char &amp;at(int n);<br>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br>const char *data()const;//返回一个非null终止的c字符数组<br>const char *c_str()const;//返回一个以null终止的c字符串<br>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p><p>string的特性描述:<br>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）<br>int max_size()const;    //返回string对象中可存放的最大字符串的长度<br>int size()const;        //返回当前字符串的大小<br>int length()const;       //返回当前字符串的长度<br>bool empty()const;        //当前字符串是否为空<br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p><p>string类的输入输出操作:<br>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p><p>string的赋值：<br>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(const char *s);//用c类型字符串s赋值<br>string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值<br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p><p>string的连接：<br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾<br>string &amp;append(const char *s);            //把c类型字符串s连接到当前字符串结尾<br>string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br>string &amp;append(const string &amp;s);    //同operator+=()<br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c<br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p><p>string的比较：<br>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br>int compare(const string &amp;s) const;//比较当前字符串和s的大小<br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小<br>int compare(const char *s) const;<br>int compare(int pos, int n,const char *s) const;<br>int compare(int pos, int n,const char *s, int pos2) const;<br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0<br>string的子串：<br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p><p>string的交换：<br>void swap(string &amp;s2);    //交换当前字符串与s2的值</p><p>string类的查找函数：<br>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br>int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>//查找成功时返回所在位置，失败返回string::npos的值<br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br>int rfind(const char *s, int pos = npos) const;<br>int rfind(const char *s, int pos, int n = npos) const;<br>int rfind(const string &amp;s,int pos = npos) const;<br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值<br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br>int find_first_of(const char *s, int pos = 0) const;<br>int find_first_of(const char *s, int pos, int n) const;<br>int find_first_of(const string &amp;s,int pos = 0) const;<br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos<br>int find_first_not_of(char c, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos,int n) const;<br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos<br>int find_last_of(char c, int pos = npos) const;<br>int find_last_of(const char *s, int pos = npos) const;<br>int find_last_of(const char *s, int pos, int n = npos) const;<br>int find_last_of(const string &amp;s,int pos = npos) const;<br>int find_last_not_of(char c, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos, int n) const;<br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p><p>string类的替换函数：<br>string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br>string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s<br>string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p><p>string类的插入函数：<br>string &amp;insert(int p0, const char *s);<br>string &amp;insert(int p0, const char *s, int n);<br>string &amp;insert(int p0,const string &amp;s);<br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br>void insert(iterator it, int n, char c);//在it处插入n个字符c</p><p>string类的删除函数<br>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p><p>string类的迭代器处理：<br>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。</p><p>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br>const_iterator begin()const;<br>iterator begin();                //返回string的起始位置<br>const_iterator end()const;<br>iterator end();                    //返回string的最后一个字符后面的位置<br>const_iterator rbegin()const;<br>iterator rbegin();                //返回string的最后一个字符的位置<br>const_iterator rend()const;<br>iterator rend();                    //返回string第一个字符位置的前面<br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p><p>字符串流处理：<br>通过定义ostringstream和istringstream变量实现，<sstream>头文件中<br>例如：<br>string input(“hello,this is a test”);<br>istringstream is(input);<br>string s1,s2,s3,s4;<br>is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br>ostringstream os;<br>os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br>cout&lt;&lt;os.str();</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_07上</title>
    <link href="/2020/02/22/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8A/"/>
    <url>/2020/02/22/USTC%E6%9C%BA%E8%AF%95_07%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>1.编写程序，判断回文数</p><pre><code class="c">#include&lt;iostream&gt;using namespace std;int Reverse(int x){    int result=0;    while(x!=0){        result=result*10+x%10;        x/=10;    }    return result;}int main(){    int n;    while(cin&gt;&gt;n){        if(Reverse(n)==n) cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;    }}</code></pre><p>2.队列的循环报数问题</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){    int n;    cin&gt;&gt;n;    queue&lt;int&gt; q;o    for(int i=1;i&lt;=n;i++) q.push(i);    while(!q.empty()){        cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;;//报号1        q.pop();        if(!q.empty()){            q.push(q.front());//报号2            q.pop();        }    }}</code></pre><p>3.图的最小生成树</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1001;struct Edge{    int from;    int to;    int length;    bool operator&lt; (const Edge&amp; e) const{        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(x!=father[x]) father[x]=Find(father[x]);    return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[y]&lt;height[x]) father[y]=x;        else{            father[y]=x;            height[x]++;        }    }    return ;}int kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //即from与to上溯的根结点不一样        //也即加上edge[i]不会形成环        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        //用于给了两两之间的距离修路的问题        int edgeNumber=n*(n-1)/2;        for(int i=0;i&lt;edgeNumber;i++){            cin&gt;&gt;edge[i].from&gt;&gt;edge[i].to&gt;&gt;edge[i].length;        }        int answer=kruskal(n,edgeNumber);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre><p>4.后序中序得先序</p><pre><code class="c">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct TreeNode{    char data;    TreeNode* left;    TreeNode* right;    TreeNode(char data):data(data){}};string in;string post;TreeNode* postin(int l1,int h1,int l2,int h2){    char data=post[h1];    cout&lt;&lt;data&lt;&lt;endl;    TreeNode* T=new TreeNode(data);    int i;    for(i=l2;data!=in[i];i++);//这里i的开头是l2    int llen=i-l2;    int rlen=h2-i;    if(llen) T-&gt;left=postin(l1,l1+llen-1,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=postin(h1-rlen,h1-1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}void PreOrder(TreeNode* T){    if(T==NULL) return;    cout&lt;&lt;T-&gt;data;    PreOrder(T-&gt;left);    PreOrder(T-&gt;right);}int main(){    cin&gt;&gt;post&gt;&gt;in;    TreeNode* root=postin(0,post.size()-1,0,in.size()-1);    PreOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_06下</title>
    <link href="/2020/02/21/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8B/"/>
    <url>/2020/02/21/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.统计一个字符串当中有多少字母、数字、空格和其它字符；</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int count_zimu=0,count_shuzi=0,count_space=0,count_others=0;void Count(char c){    if(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) count_shuzi++;    else if((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) count_zimu++;    else if(c==&#39; &#39;) count_space++;    else count_others++;}int main(){    string s;3r    getline(cin,s);    for(int i=0;i&lt;s.size();i++){        Count(s[i]);    }    cout&lt;&lt;count_zimu&lt;&lt;&quot; &quot;&lt;&lt;count_shuzi&lt;&lt;&quot; &quot;&lt;&lt;count_space&lt;&lt;&quot; &quot;&lt;&lt;count_others&lt;&lt;endl;}</code></pre><p>2.给你一个 10进制数，要你输出  8进制数；</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(){    int n;    stack&lt;int&gt; result;    cin&gt;&gt;n;    while(n!=0){        result.push(n%8);        n/=8;    }    while(!result.empty()){        cout&lt;&lt;result.top();        result.pop();    }}</code></pre><p>3.给你一个数，要求你求出这个数与其反序数的和相加多少次才可以得到回<br>文字</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int Reverse(int x){//求逆序    int result=0;    while(x!=0){        result=result*10+x%10;        x/=10;    }    return result;}bool ishuiwen(int x){//判断回文    if(Reverse(x)==x) return true;    else return false;}int main(){    int time=0;    int n;    cin&gt;&gt;n;    while(!ishuiwen(n)){        n=n+Reverse(n);        time++;    }    cout&lt;&lt;time&lt;&lt;endl;}</code></pre><p>4.给你一个数列，求出最大子序列之和</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=100;int a[MAXN];int dp[MAXN];int main(){    int n;    cin&gt;&gt;n;    int Max=0;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];    }    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];        else dp[i]=max(a[i],dp[i-1]+a[i]);        if(dp[i]&gt;Max) Max=dp[i];    }    cout&lt;&lt;Max&lt;&lt;endl;}</code></pre><p>5.给你几个整数，求出最大的组合数</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=100;vector&lt;string&gt; v;//使用字典序可以快速解决这道题bool compare(string x,string y){    return x&gt;y;}int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        string num;        cin&gt;&gt;num;        v.push_back(num);    }    sort(v.begin(),v.end(),compare);    for(int i=0;i&lt;n;i++){        cout&lt;&lt;v[i];    }}</code></pre><p>6.关于图的最大连通分量</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;#define maxn 10001using namespace std;vector&lt;int&gt;G[maxn];stack&lt;int&gt;s;int n,m;int dfn[maxn],used[maxn],vis[maxn],low[maxn],color[maxn],num[maxn],colornum=0,cnt=0,ans=0;void paint(int x){    s.pop();    color[x]=colornum;    num[colornum]++;    vis[x]=false;}void tarjan(int x){    dfn[x]=low[x]=++cnt;//依次深搜并且对dfn和low初始化    s.push(x);    vis[x]=used[x]=true;//置访问标记    for(int i=0;i&lt;G[x].size();i++){//遍历当前节点的所有边        int q=G[x][i];        if (!dfn[q]){//如果边没有被访问过，即没有被dfn初始化            tarjan(q);            low[x]=min(low[x],low[q]);        }        else if (vis[q]) low[x]=min(low[x],dfn[q]);//如果    }    if (low[x]==dfn[x]){//满足强连通分量的条件        colornum++;        while(s.top()!=x){            int t=s.top();            paint(t);        }        paint(x);    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        int u,v;        cin&gt;&gt;u&gt;&gt;v;        G[u].push_back(v);    }    for(int i=1;i&lt;=n;i++){        if (!used[i]) tarjan(i);    }    for(int i=1;i&lt;=colornum;i++){        if (num[i]&gt;0) ans++;    }    cout&lt;&lt;ans;    return 0;}</code></pre><p>7.用二叉树，给你先序和中序遍历，输出后续遍历</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;string pre,post;struct TreeNode{    char c;    TreeNode* left;    TreeNode* right;    TreeNode(char c):c(c){}};TreeNode* PreInCreat(int l1,int h1,int l2,int h2){    TreeNode* T=new TreeNode(pre[l1]);//根结点    int i;    for(i=l2;post[i]!=T-&gt;c;i++) ;//根结点在中序序列中的划分    int llen=i-l2;//左子树长度    int rlen=h2-i;//右子树长度    //这里的上下限画个图就清楚了    if(llen) T-&gt;left=PreInCreat(l1+1,l1+llen,l2,l2+llen-1);    else T-&gt;left=NULL;    if(rlen) T-&gt;right=PreInCreat(h1-rlen+1,h1,h2-rlen+1,h2);    else T-&gt;right=NULL;    return T;}void PostOrder(TreeNode* T){    if(T==NULL) return;    else{        PostOrder(T-&gt;left);        PostOrder(T-&gt;right);        cout&lt;&lt;T-&gt;c;    }}int main(){    cin&gt;&gt;pre&gt;&gt;post;    TreeNode* root=PreInCreat(0,pre.size()-1,0,post.size()-1);    PostOrder(root);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法中的常用代码</title>
    <link href="/2020/02/21/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/02/21/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><strong>并查集模板</strong><br>主要用于解决关于连通的一些问题</p><pre><code class="cpp">void Initial(){    for(int i=0;i&lt;MAXN;i++){        father[i]=i;//根结点指向自己        height[i]=0;        //inDegree[i]=0;        //visit[i]=false;    }}int Find(int x){    if(father[x]!=x) father[x]=Find(father[x]);//注意写法，路径压缩    return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;//前面两种情况树高并没有变        else{            father[y]=x;            height[x]++;        }    }    return ;}</code></pre><p><strong>邻接表</strong></p><pre><code class="cpp">struct Edge{    int to;    int length;    Edge(int t,int l):to{t},length(l){}};vector&lt;Edge&gt; graph[MAXN];</code></pre><p><strong>广度优先搜索</strong></p><pre><code class="cpp">struct Status{    int n,t;//t表示起点到n的时间    Status(int n,int t):n(n),t(t){}};bool visit[MAXN];int BFS(int n,int k){    queue&lt;Status&gt; myqueue;    myqueue.push(Status(n,0)); //初始状态    visit[n]=true;   //起始点已被访问    while(!myqueue.empty()){        Status current=myqueue.front();        myqueue.pop();        if(current.n==k) return current.t;  //查找成功        for(int i=0;i&lt;3;i++){       //转入三种不同的状态            Status next(current.n,current.t+1);            if(i==0) next.n+=1;            else if(i==1) next.n-=1;            else next.n*=2;            if(next.n&lt;0||next.n&gt;=MAXN||visit[next.n]) continue;//新状态不合法            myqueue.push(next);            visit[next.n]=true;//置访问标记        }    }}</code></pre><p><strong>深度优先搜索</strong></p><pre><code class="cpp">int side; //边长int m;  //树枝数目int sticks[MAXN];bool visit[MAXN];bool DFS(int sum,int number,int position){    if(number==3) return true;    int sample=0;       //剪枝(3)    for(int i=position;i&lt;m;i++){        if(visit[i]||sum+sticks[i]&gt;side||sticks[i]==sample) continue;        visit[i]=true;        if(sum+sticks[i]==side){    //能凑成一条边            if(DFS(0,number+1,0)) return true;            else sample=sticks[i];  //记录失败的棍子的长度        }        else{            if(DFS(sum+sticks[i],number,i+1)) return true;            else sample=sticks[i];  //记录失败的棍子的长度        }        visit[i]=false;    }    return false;}</code></pre><p><strong>最小生成树</strong></p><pre><code class="cpp">int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}</code></pre><p><strong>最短路径</strong></p><pre><code class="cpp">struct Point{//结点    int number;    int distance;    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; p) const{//重载小于        return distance&gt;p.distance;    }};int dis[MAXN];void Dijkstra(int s){    priority_queue&lt;Point&gt; pqueue;    dis[s]=0;    pqueue.push(Point(s,dis[s]));    while(!pqueue.empty()){        int u=pqueue.top().number;//离源点最近的点        pqueue.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;//u为顶点的编号，i为边的序号            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){                dis[v]=dis[u]+d;                pqueue.push(Point(v,dis[v]));            }        }    }    return ;}</code></pre><p><strong>拓扑排序</strong></p><pre><code class="cpp">int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}</code></pre><p><strong>关键路径</strong><br>基于拓扑顺序去遍历的</p><pre><code class="cpp">void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USTC机试_06上</title>
    <link href="/2020/02/18/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8A/"/>
    <url>/2020/02/18/USTC%E6%9C%BA%E8%AF%95_06%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>2.给出四个[年,月],判断此月有多少天.题目给出了闰年判断方法的伪代码.</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int months[2][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},//平年    {0,31,29,31,30,31,30,31,31,30,31,30,31}//闰年};bool isrein(int year){    return (year%400==0)||(year%4==0&amp;&amp;year%100!=0);}int main(){    int year,month;    while(cin&gt;&gt;year&gt;&gt;month){        if(isrein(year)) cout&lt;&lt;months[1][month];        else cout&lt;&lt;months[0][month];    }}</code></pre><p>3.给出一些标识符,判断合法标识符有多少个.(与 C语言中标识符定义一致.)</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;bool first(char c){    return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)||(c==&#39;_&#39;);}bool others(char c){    return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)||isdigit(c)||(c==&#39;_&#39;);}int main(){    int n;    while(cin&gt;&gt;n){        vector&lt;string&gt; v;        int Count=0;        for(int i=0;i&lt;n;i++){            string s;            cin&gt;&gt;s;            v.push_back(s);        }        for(int i=0;i&lt;v.size();i++){            string s1=v[i];            if(first(s1[0])){                bool flag=true;                for(int j=1;j&lt;s1.size();j++){                    if(!others(s1[j])) flag=false;                }                if(flag) Count++;            }            else continue;        }        cout&lt;&lt;Count&lt;&lt;endl;    }}</code></pre><p>4.第四道,给出无向图连接矩阵,求各个连通分量</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;const int MAXN=1000;int father[MAXN];int height[MAXN];//以该节点为根的树的高度using namespace std;void Initial(){    for(int i=0;i&lt;MAXN;i++){        father[i]=i;        height[i]=0;        //inDegree[i]=0;        //visit[i]=false;    }}int FindRoot(int x){    if(father[x]!=x) father[x]=FindRoot(father[x]);//注意写法    return father[x];}void Union(int x,int y){    x=FindRoot(x);    y=FindRoot(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;//前面两种情况树高并没有变        else{            father[y]=x;            height[x]++;        }    }    return ;}int main(){    FILE *fp1,*fp2;//1.定义指针    fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;);//2.指向文件    fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;);    int n;    fscanf(fp1,&quot;%d&quot;,&amp;n);//3.进行读写    Initial();    while(!feof(fp1)){        int a,b;        fscanf(fp1,&quot;%d&quot;,&amp;a);        fscanf(fp1,&quot;%d&quot;,&amp;b);        Union(a,b);    }    vector&lt;int&gt; roots;    for(int i=1;i&lt;=n;i++){//因为序号是从1开始        if(FindRoot(i)==i){            roots.push_back(i);        }    }}</code></pre><p>5.给出一个整数分解成尽可能多的连续整数的和</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int main(){    int n;    while(cin&gt;&gt;n){        int maxi=0,maxj=0;        bool flag=false;        for(int i=1;i&lt;=n/2;i++){            int sum=0;            for(int j=2;j&lt;n;j++){//j表示从i开始往后连续的长度                sum=(i+i+j-1)*j/2;                if(sum&gt;n) break;                else if(sum==n){                    flag=true;                    if(j&gt;maxj){                        maxi=i;                        maxj=j;                    }                }            }        }        if(flag){            for(int i=maxi;maxj&gt;0;maxj--,i++){                cout&lt;&lt;i&lt;&lt;&quot; &quot;;            }            cout&lt;&lt;endl;        }        else cout&lt;&lt;&quot;分解失败&quot;&lt;&lt;endl;    }}</code></pre><p>6.给出带括号的四则运算表达式,要求给出逆波兰式</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;stack&lt;char&gt; Stack;char output[500];int outLen;int Priority(char c){//判断运算符优先级    if(c==&#39;*&#39;||c==&#39;/&#39;) return 2;    else if(c==&#39;+&#39;||c==&#39;-&#39;) return 1;    else return 0;//&#39;(&#39;}bool isOperator(char op)                //判断是不是操作符{    return (op==&#39;+&#39; || op==&#39;-&#39; || op==&#39;*&#39; || op==&#39;/&#39;);}void rePolish(string s,int len){//输出逆波兰式    memset(output,&#39;\0&#39;,sizeof(output));    outLen=0;    for(int i=0;i&lt;len;++i){        //操作数        if(isdigit(s[i])){            cout&lt;&lt;&quot;shu:&quot;&lt;&lt;s[i]&lt;&lt;endl;            output[outLen++] = s[i];            while (i+1&lt;len&amp;&amp;isdigit(s[i+1])){                output[outLen++] = s[i+1];                ++i;            }            output[outLen++] = &#39; &#39;;        //空格隔开        }        //运算符        else if (isOperator(s[i])){            cout&lt;&lt;&quot;fu:&quot;&lt;&lt;s[i]&lt;&lt;endl;            if(!Stack.empty()&amp;&amp;Priority(Stack.top())&gt;=Priority(s[i])){                while(Priority(Stack.top())&gt;=Priority(s[i])){                    output[outLen++]=Stack.top();                    output[outLen++] = &#39; &#39;;                    Stack.pop();                }            }            else Stack.push(s[i]);//栈为空，或者栈顶优先级更小        }        //&#39;(&#39;        else if (s[i]==&#39;(&#39;){            cout&lt;&lt;&quot;(:&quot;&lt;&lt;s[i]&lt;&lt;endl;            Stack.push(s[i]);        }        //&#39;)&#39;        else if (s[i]==&#39;)&#39;){            cout&lt;&lt;&quot;):&quot;&lt;&lt;s[i]&lt;&lt;endl;            while (Stack.top()!=&#39;(&#39;){                output[outLen++] = Stack.top();                output[outLen++] = &#39; &#39;;                Stack.pop();            }            Stack.pop();// 此时Stack.top()=&#39;(&#39;,跳过)        }        else continue;    }    while (!Stack.empty()){//输入完毕，栈中剩余的所有操作符出栈        output[outLen++] = Stack.top();        output[outLen++] = &#39; &#39;;        Stack.pop();    }}int main(){    string s;    while (getline(cin,s)){        cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;s.size();        Stack.push(&#39;#&#39;);        rePolish(s,s.size());        output[outLen-1] = &#39;\0&#39;;        printf(&quot;%s\n&quot;,output);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>复试真题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划状态转移公式</title>
    <link href="/2020/02/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/02/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>最大连续子序列和</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最大连续子序列和</td><td align="left">在一个给定的序列中，找出一个连续的子序列，使得这个子序列的和最大</td><td align="left">dp[i]表示以A[i]作为末尾的连续序列最大和&#124;dp[i]=max(A[i],dp[i-1]+A[i])</td><td align="left"></td></tr></tbody></table><p>转移情况：<br>①最大和的连续序列只有一个元素，即A[i]本身，为A[i]<br>②最大和的连续序列有多个元素，即从A[j]开始到A[i]，为dp[i-1]+A[i]</p><pre><code class="cpp">int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}</code></pre><p><strong>最长递增子序列</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最长递增子序列</td><td align="left">在一个给定的序列中，找出一个的最长的递增子序列（不必连续）</td><td align="left">dp[i]表示以A[i]作为末尾的最长递增子序列长度</td><td align="left">dp[i]=max(1,dp[j]+1 | j&lt;i&amp;&amp;A[j]&lt;A[i])</td></tr></tbody></table><p>转移情况：<br>①A[i]之前的元素都比A[i]大，即最长递增子序列只有A[i]本身，为dp[i]=1<br>②A[i]之前的元素A[j]比A[i]小此时只需将A[i]添加到以A[j]为末尾的最长递增子序列,而求长度则是通过将i之前的元素逐一遍历，就可以获得dp[i]</p><pre><code class="cpp">  int answer=0;  for(int i=0;i&lt;n;i++){      dp[i]=1;//初始化为1      for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度          if(height[i]&lt;=height[j]){              dp[i]=max(dp[i],dp[j]+1);          }      }      answer=max(answer,dp[i]);  }</code></pre><p><strong>最长公共子序列</strong></p><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">最长公共子序列</td><td align="left">给定字符串s1,s2求一个最长的公共子序列(不一定连续)</td><td align="left">dp[i][j]表示以s1[i]作为末尾和以s2[j]为末尾的最长公共子序列的长度</td><td align="left">dp[i][j]=dp[i-1][j-1]+1(s1[i]=s2[j])___   否则dp[i][j]==max(dp[i-1][j],dp[i][j-1])</td></tr></tbody></table><p>转移情况：<br>①s1[i]=s2[j]，此时比存在一个最长公共子序列以s1[i]和s2[j]结尾，其他部分相当于s1的前i-1和s2的前j-1个字符的最长公共子序列，为dp[i-1][j-1]+1<br>②s1[i]!=s2[j],此时最长公共子序列的长度为<u>s1的前i-1个字符和s2的前j个字符的最长公共子序列</u>与<u>s1的前i个字符和s2中的前j-1个字符的最长公共子串</u>的较大者，为max(dp[i-1][j],dp[i][j-1])</p><p>边界情况：<br>dp[i][0]=0;       dp[0][j]=0;</p><pre><code class="cpp">while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入    int n=strlen(s1+1);    int m=strlen(s2+1);    for(int i=0;i&lt;=n;i++){        for(int j=0;j&lt;=m;j++){            if(i==0||j==0){//边界条件初始化                dp[i][j]=0;                continue;            }            //状态转移方程            if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);        }    }    cout&lt;&lt;dp[n][m]&lt;&lt;endl;}</code></pre><p><strong>背包问题</strong></p><ul><li>0-1背包</li></ul><table><thead><tr><th align="left">题目</th><th align="left">描述</th><th align="left">dp描述</th><th align="left">转移公式</th></tr></thead><tbody><tr><td align="left">0–1背包</td><td align="left">n种物品(<u>一种只取一次</u>),重量分别为w[i],现有容量为m背包,要使装进背包物品价值最大</td><td align="left">dp[i][j]表示前i个物品装进容量为j的背包能获得的最大价值</td><td align="left">dp[j]=max(dp[j],dp[j-w[i]]+v[i])</td></tr></tbody></table><p>转移情况：<br>①对于容量为j的背包，如果不放入第i件物品，问题就转化成了前i-1个物品放入容量为j的背包的问题，为dp[i-1][j]<br>②对于容量为j的背包，如果放入第i件物品，问题就转化成了将前面i-1个物品放入容量为j-w[i]的背包的问题，为dp[i-1][j-w[i]]+v[i]<br>最终转化成了dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])<br>经观察dp[i][j]只与二维数组中本行的上一行有关，根据这个可以将二维数组优化为一维数组：<br>dp[j]=max(dp[j],dp[j-w[i]+v[i])</p><p>边界情况：<br>dp[i][0]=0;       dp[0][j]=0;</p><pre><code class="cpp">for(int i=0;i&lt;=m;i++){    dp[i]=0;//初始化}for(int i=0;i&lt;n;i++){    for(int j=m;j&gt;=w[i];j--){        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);    }}</code></pre><ul><li><del>完全背包</del> ：暂时不是很理解(╯°Д°)╯︵┻━┻</li><li><del>多重背包</del> ：暂时不是很理解ヽ(｀Д´)ﾉ︵ ┻━┻ ┻━┻ </li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小邮票数</title>
    <link href="/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/"/>
    <url>/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。</p><p><strong>输入描述:</strong><br>    有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。</p><p><strong>输出描述:</strong><br>      对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。</p><p><strong>输入</strong></p><blockquote><p>10<br>5<br>1 3 3 3 4</p></blockquote><p><strong>输出</strong></p><blockquote><p>3</p></blockquote><pre><code class="cpp">/*    最少邮票数 &gt;&gt; 01动态规划    状态    集合中数字    dp[i][j]    0   1   2   3   4   5   6   7   8   9   10    1           0   1   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞    1 3         0   1   ∞   1   2   ∞   ∞   ∞   ∞   ∞   ∞    1 3 3       0   1   ∞   1   2   ∞   2   3   ∞   ∞   ∞    1 3 3 3     0   1   ∞   1   2   ∞   2   ∞   ∞   3   4    1 3 3 3 4   0   1   ∞   1   2   2   2   2   3   3   3      状态迁移方程    dp[j] = min{dp[j],dp[j-stamp[i]]+1}    其中dp[j-stamp[i]]+1，表示将第i个邮票加入集合后 凑总量为j的面额 所需要的最少邮票数量*/#include&lt;stdio.h&gt;#define INF 1000int stamp[1000];int dp[1000];// 返回最少数量，num表示邮票的个数，deno表示要凑成的面额int Min_Stamp(int num,int deno){    int i,j;    //将状态全部初始化为最多    for(j=0;j&lt;=deno;++j){        dp[j]= (j==0)?0:INF;           }    for(i=0;i&lt;num;i++){        //从后向前寻找若能凑成，且使数量变少就使用，不能也无所谓因为还是INF        for(j=deno;j&gt;=stamp[i];j--){            if(dp[j-stamp[i]]!=INF)dp[j]=(dp[j] &lt; dp[j-stamp[i]]+1)? dp[j]: dp[j-stamp[i]]+1;        }    }    return dp[deno]==INF?0:dp[deno];}int main(){    int num,deno;    while(scanf(&quot;%d %d&quot;,&amp;deno,&amp;num)!=EOF){        for(int i=0;i&lt;num;i++)scanf(&quot;%d&quot;,stamp+i);        printf(&quot;%d&quot;,Min_Stamp(num,deno));    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点菜问题</title>
    <link href="/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    北大网络实验室经常有活动需要叫外卖，但是每次叫外卖的报销经费的总额最大为C元，有N种菜可以点，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大。     注意：由于需要营养多样化，每种菜只能点一次。</p><p><strong>输入描述:</strong><br>    输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。</p><p><strong>输出描述:</strong><br>    输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。</p><p><strong>输入</strong></p><blockquote><p>90 4<br>20 25<br>30 20<br>40 50<br>10 18<br>40 2<br>25 30<br>10 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>95 38</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//背包问题using namespace std;const int MAXN=1001;int dp[MAXN];int v[MAXN];//物品价值int w[MAXN];//物品重量int main(){    int n,m;    cin&gt;&gt;m&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=0;i&lt;=m;i++){        dp[i]=0;//初始化    }    for(int i=0;i&lt;n;i++){        for(int j=m;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[m]&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/14/Common%20Subsequence/"/>
    <url>/2020/02/14/Common%20Subsequence/</url>
    
    <content type="html"><![CDATA[<p><strong>Description</strong><br>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><p><strong>Input</strong><br>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><p><strong>Output</strong><br>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><p><strong>Sample Input</strong></p><blockquote><p>abcfbc            abfcab<br>programming    contest<br>abcd           mnp</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4<br>2<br>0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//最长公共子序列using namespace std;const int MAXN=1001;char s1[MAXN];char s2[MAXN];int dp[MAXN][MAXN];int main(){    while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入        int n=strlen(s1+1);        int m=strlen(s2+1);        for(int i=0;i&lt;=n;i++){            for(int j=0;j&lt;=m;j++){                if(i==0||j==0){//边界条件初始化                    dp[i][j]=0;                    continue;                }                //状态转移方程                if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK， 则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>输入描述:</strong><br>输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。<br>第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。</p><p><strong>输出描述:</strong><br>可能包括多组测试数据，对于每组数据，<br>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><p><strong>输入</strong></p><blockquote><p>8<br>186 186 150 200 160 130 197 220</p></blockquote><p><strong>输出</strong></p><blockquote><p>4</p></blockquote><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;int num[100];int dp1[100];int dp2[100];//枚举每个位置，从左边找最长上升子序列，从右边开始找最长下降子序列，两个数相加就是题目所说的唱歌的人数。int main(){    int count;    while(cin&gt;&gt;count){        for(int i=0;i&lt;count;i++){            cin&gt;&gt;num[i];        }        for(int i=0;i&lt;count;i++){            dp1[i]=1;            for(int j=0;j&lt;i;j++){                if(num[i]&gt;num[j]){                    dp1[i]=max(dp1[j]+1,dp1[i]);                }            }        }        for(int i=count-1;i&gt;=0;i--){            dp2[i]=1;            for(int j=count-1;j&gt;i;j--){                if(num[i]&gt;num[j]){                    dp2[i]=max(dp2[i],dp2[j]+1);                }            }        }        int total=0;        for(int i=0;i&lt;count;i++){//i此时是作为最中间的一个点            total=max(dp1[i]+dp2[i]-1,total);        }        cout&lt;&lt;count-total&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大上升子序列和</title>
    <link href="/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p><p><strong>输入描述:</strong><br>输入包含多组测试数据。<br>每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</p><p><strong>输出描述:</strong><br>对于每组测试数据，输出其最大上升子序列和。</p><p><strong>输入</strong></p><blockquote><p>7<br>1 7 3 5 9 4 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>18</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1001;int a[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=a[i];//初始化为a[i]            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列                if(a[i]&gt;a[j]){                    dp[i]=max(dp[i],dp[j]+a[i]);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拦截导弹</title>
    <link href="/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/"/>
    <url>/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。 </p><p><strong>输入描述:</strong><br>每组输入有两行，<br>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），<br>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p><p><strong>输出描述:</strong><br>每组输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p><p><strong>输入</strong></p><blockquote><p>8<br>300 207 155 300 299 170 158 65</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//动态规划：最长递增子序列//状态转移方程：dp[i]=max(1,dp[j]+1|j&lt;i&amp;&amp;Aj&gt;Ai)using namespace std;const int MAXN=25;int height[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;height[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=1;//初始化为1            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度                if(height[i]&lt;=height[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。<br><strong>输入描述:</strong><br>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。<br>再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。<br>已知矩阵中整数的范围都在[-127, 127]。<br><strong>输出描述:</strong><br>测试数据可能有多组，对于每组测试数据，输出最大子矩阵的大小。<br>示例1<br><strong>输入</strong></p><blockquote><p>4<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4  1<br>-1 8  0 -2</p></blockquote><p><strong>输出</strong></p><blockquote><p>15</p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN=100;int dp[MAXN];int arr[MAXN];int matrix[MAXN][MAXN];int total[MAXN][MAXN];//total[i][j]表示从这个元素往上的所有元素的和int MaxSubsequence(int n){    int maximum=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=arr[i];        else dp[i]=max(dp[i-1]+arr[i],arr[i]);        maximum=max(maximum,dp[i]);    }    return maximum;}int maxSubmatrix(int n){    int maximal=0;    for(int i=0;i&lt;n;i++){        for(int j=i;j&lt;n;j++){//            for(int k=0;k&lt;n;k++){//获得一维数组                if(i==0) arr[k]=total[j][k];                else arr[k]=total[j][k]-total[i-1][k];            }        int current =MaxSubsequence(n);        maximal = max(maximal,current);        }    }    return maximal;}int main(){    int N;    while(cin&gt;&gt;N){        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                cin&gt;&gt;matrix[i][j];            }        }        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                if(i==0) total[i][j]=matrix[i][j];                else total[i][j]=total[i-1][j]+matrix[i][j];            }        }        int result=maxSubmatrix(N);        cout&lt;&lt;result&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。<br><strong>输入描述:</strong><br>    测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。<br><strong>输出描述:</strong><br>    对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。<br><strong>输入</strong></p><blockquote><p>6<br>-2 11 -4 13 -5 -2 10<br>-10<br>1 2 3 4 -5 -23 3 7 -21<br>6<br>5 -8 3 2 5 0<br>1<br>10<br>3<br>-1 -5 -2<br>3<br>-1 0 -2<br>0</p></blockquote><p><strong>输出</strong></p><blockquote><p>20 11 13<br>10 1 4<br>10 3 5<br>10 10 10<br>0 -1 -2<br>0 0 0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=10000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];void maxSub(int n,int&amp; Max,int&amp; first,int&amp; last){    Max=0,first=0,last=n-1;    //第一次遍历找出最大子序列和    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    //第二次遍历确定最大子序列的两个边界    for(int i=0;i&lt;n;i++){        if(i==0){            dp[i]=a[i];        }        else if(dp[i-1]+a[i]&gt;a[i]){            last=i;//当前子序列继续扩充元素            dp[i]=dp[i-1]+a[i];        }        else{            first=i;//从当前的元素重新往后找，赋值first            dp[i]=a[i];        }        if(dp[i]==Max){            last=i;//此时已经找到最大的子序列，给last赋最终值            return;        }    }}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int Max,first,last;        maxSub(n,Max,first,last);        cout&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;a[first]&lt;&lt;&quot; &quot;&lt;&lt;a[last]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大序列和</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。<br><strong>输入描述</strong>:<br>第一行为一个正整数N，第二行为N个整数，表示序列中的数。<br><strong>输出描述:</strong><br>输入可能包括多组数据，对于每一组输入数据，<br>仅输出一个数，表示最大序列和。<br><strong>输入</strong></p><blockquote><p>5<br>1 5 -3 2 4<br>6<br>1 -2 3 4 -10 6<br>4<br>-3 -1 -2 -5</p></blockquote><p><strong>输出</strong></p><blockquote><p>9<br>7<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        cout&lt;&lt;maxSub(n)&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文</title>
    <link href="/2020/02/11/%E8%AE%BA%E6%96%87/"/>
    <url>/2020/02/11/%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>小H为了完成一篇论文，一共要完成n个实验。其中第i个实验需要ai的时间去完成。小H可以同时进行若干实验，但存在一些实验，只有当它的若干前置实验完成时，才能开始进行该实验。同时我们认为小H在一个实验的前置实验都完成时，就能马上开始该实验。为了让小H尽快完成论文，需要知道在最优的情况下，最后一个完成的实验什么时候完成？小H还想知道，在保证最后一个实验尽快完成的情况下（即保证上一问的答案不变），他想知道每个实验最晚可以什么时候开始。设第i个实验最早可能的开始时间为fi，不影响最后一个实验完成时间的最晚开始时间为gi，请你证明<img src="https://img-blog.csdnimg.cn/20200211171228484.png" srcset="/img/loading.gif" alt="">除以10^9+7所得的余数。题目保证有解。</p><p><strong>输入描述:</strong><br>从标准输入读入数据。<br>第一行输入一个整数n，m。<br>第二行输入n个正整数，a1,a2,…..an,描述每个实验完成所需要的时间。<br>接下来读入m行，每行读入两个整数u,v，表示编号为u的实验是编号为v的实验的前置实验。<br>对于所有的输入数据，都满足1&lt;=n&lt;=10^5,1&lt;=m&lt;=5<em>10^5,1&lt;=ai&lt;=10^6。<br>*</em>输出描述:**<br>输出到标准输出。<br>第一行输出一个整数表示最晚完成的实验的时间。<br>第二行输出一个整数表示除以10^9+7所得的余数。<br>输入输出样例<br><strong>输入样例#:</strong></p><blockquote><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p></blockquote><p><strong>输出样例#:</strong></p><blockquote><p>34<br>7840</p></blockquote><p>提示：<br>第一个点最早开始时间为20，最晚开始时间为23。<br>第二个点最早开始时间为0，最晚开始时间为3。<br>第三个点最早开始时间为17，最晚开始时间为17。<br>第四个点最早开始时间为20，最晚开始时间为24。<br>第五个点最早开始时间为0，最晚开始时间为13。<br>第六个点最早开始时间为0，最晚开始时间为6。<br>第七个点最早开始时间为0，最晚开始时间为0。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1e5+7;const int INF=INT_MAX;const int MOD=1e9+7;vector&lt;int&gt; graph[MAXN];//邻接表long long earliest[MAXN];//最早开始时间long long latest[MAXN];//最晚开始时间long long time[MAXN];//花费时间int inDegree[MAXN];long long CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=1;i&lt;=n;i++){        if(inDegree[i]==0){            node.push(i);        }    }    long long totalTime=0;//总耗时    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i];            earliest[v]=max(earliest[v],earliest[u]+time[u]);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0){                node.push(v);                totalTime=max(totalTime,earliest[v]+time[v]);            }        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=totalTime-time[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j];            latest[u]=min(latest[u],latest[v]-time[u]);//逆向找最小，形成latest        }    }    return totalTime;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        memset(time,0,sizeof(time));        for(int i=1;i&lt;=n;i++){            cin&gt;&gt;time[i];        }        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;        }        long long totalTime=CriticalPath(n);        long long answer=1;        for(int i=1;i&lt;=n;i++){            answer*=latest[i]-earliest[i]+1;            answer%=MOD;        }        cout&lt;&lt;totalTime&lt;&lt;endl;        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction Arrangement</title>
    <link href="/2020/02/11/Instruction%20Arrangement/"/>
    <url>/2020/02/11/Instruction%20Arrangement/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>Ali has taken the Computer Organization and Architecture course this term. He learned that there may be dependence between instructions, like WAR (write after read), WAW, RAW.<br>If the distance between two instructions is less than the Safe Distance, it will result in hazard, which may cause wrong result. So we need to design special circuit to eliminate hazard. However the most simple way to solve this problem is to add bubbles (useless operation), which means wasting time to ensure that the distance between two instructions is not smaller than the Safe Distance.<br>The definition of the distance between two instructions is the difference between their beginning times.<br>Now we have many instructions, and we know the dependent relations and Safe Distances between instructions. We also have a very strong CPU with infinite number of cores, so you can run as many instructions as you want simultaneity, and the CPU is so fast that it just cost 1ns to finish any instruction.<br>Your job is to rearrange the instructions so that the CPU can finish all the instructions using minimum time.<br><strong>Input</strong><br>The input consists several testcases.<br>The first line has two integers N, M (N &lt;= 1000, M &lt;= 10000), means that there are N instructions and M dependent relations.<br>The following M lines, each contains three integers X, Y , Z, means the Safe Distance between X and Y is Z, and Y should run after X. The instructions are numbered from 0 to N - 1.<br><strong>Output</strong><br>Print one integer, the minimum time the CPU needs to run.</p><p><strong>Sample Input</strong></p><blockquote><p>5 2<br>1 2 1<br>3 4 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Hint</strong><br>In the 1st ns, instruction 0, 1 and 3 are executed;<br>In the 2nd ns, instruction 2 and 4 are executed.<br>So the answer should be 2.</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1001;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to(t),length(l){}};vector&lt;Edge&gt; graph[MAXN];//邻接表int earliest[MAXN];//最早开始时间int latest[MAXN];//最晚开始时间int inDegree[MAXN];void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            inDegree[to]++;        }        CriticalPath(n);        int answer=0;        for(int i=0;i&lt;n;i++){            answer=max(answer,earliest[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jungle roads</title>
    <link href="/2020/02/10/Jungle%20roads/"/>
    <url>/2020/02/10/Jungle%20roads/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br><img src="https://img-blog.csdnimg.cn/20200210210056936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.<br><strong>Input</strong><br>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.<br><strong>Output</strong><br>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. </p><p><strong>Sample Input</strong></p><blockquote><p>9<br>A 2 B 12 I 25<br>B 3 C 10 H 40 I 8<br>C 2 D 18 G 55<br>D 1 E 44<br>E 2 F 60 G 38<br>F 0<br>G 1 H 35<br>H 1 I 35<br>3 A 2 B 10 C 40<br>B 1 C 20<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>216<br>30</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;struct Edge{    int from;    int to;    int length;    bool operator&lt;(const Edge&amp; e) const{//жиди&lt;a        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(father[x]!=x) return Find(father[x]);    else return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;        else{            father[y]=x; height[x]++;        }    }}int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        int k=0;        for(int i=0;i&lt;n-1;i++){            char v; int num;            cin&gt;&gt;v&gt;&gt;num;            for(int j=0;j&lt;num;j++){                char v1; int length;                cin&gt;&gt;v1&gt;&gt;length;                edge[k].from=i;                edge[k].to=v1-&#39;A&#39;;                edge[k].length=length;                k++;            }        }        int answer=Kruskal(n,k);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最小生成树</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>畅通工程续</title>
    <link href="/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/"/>
    <url>/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p><p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p><p><strong>Input</strong><br>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p><p><strong>Output</strong><br>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.<br><strong>Sample Input</strong></p><blockquote><p>3 3<br>0 1 1<br>0 2 3<br>1 2 1<br>0 2<br>3 1<br>0 1 1<br>1 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;climits&gt;using namespace std;const int MAXN=200;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to{t},length(l){}};struct Point{    int number;    int distance;    Point(int n,int d):number(n),distance(d){}    bool operator&lt; (const Point&amp; p) const{        return distance&gt;p.distance;    }};vector&lt;Edge&gt; graph[MAXN];   //邻接表实现的图，数组中是点，而每一个点后面都跟了一个vectorint dis[MAXN];void Dijkstra(int s){    priority_queue&lt;Point&gt; pqueue;    dis[s]=0;    pqueue.push(Point(s,dis[s]));    while(!pqueue.empty()){        int u=pqueue.top().number;//离源点最近的点        pqueue.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;//u为顶点的编号，i为边的序号            int d=graph[u][i].length;            if(dis[v]&gt;dis[u]+d){                dis[v]=dis[u]+d;                pqueue.push(Point(v,dis[v]));            }        }    }    return ;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));//图初始化        fill(dis,dis+n,INF);//距离初始化为无穷        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            graph[to].push_back(Edge(from,length));        }        int s,t;        cin&gt;&gt;s&gt;&gt;t;        Dijkstra(s);        if(dis[t]==INF) dis[t]=-1;        cout&lt;&lt;dis[t]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>确定比赛名次</title>
    <link href="/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/"/>
    <url>/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p><p><strong>Input</strong><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p><p><strong>Output</strong><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><p><strong>Sample Input</strong></p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 2 4 3</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];//邻接表的实现int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        if(n==0&amp;&amp;m==0) break;        memset(graph,0,sizeof(graph));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;//在输入时更新入度数组        }        vector&lt;int&gt; answer=TopologicalSort(n);        for(int i=0;i&lt;answer.size();i++){            if(i==0) cout&lt;&lt;answer[i];            else cout&lt;&lt;&quot; &quot;&lt;&lt;answer[i];        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量修改XML中的标签值</title>
    <link href="/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/"/>
    <url>/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>因为用labelimg给图片打标签的时候打错了，本来是water dispenser弄成了drinking_fountain了，尴尬_(:з)∠)_，并且已经标了1500张了，只能自己写程序改，xml文件示例如下：</p><pre><code class="cpp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;us-ascii&#39;?&gt;&lt;annotation verified=&quot;no&quot;&gt;  &lt;folder&gt;drinking_fountain&lt;/folder&gt;  &lt;filename&gt;1&lt;/filename&gt;  &lt;path&gt;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain\1.jpg&lt;/path&gt;  &lt;source&gt;    &lt;database&gt;Unknown&lt;/database&gt;  &lt;/source&gt;  &lt;size&gt;    &lt;width&gt;720&lt;/width&gt;    &lt;height&gt;1280&lt;/height&gt;    &lt;depth&gt;3&lt;/depth&gt;  &lt;/size&gt;  &lt;segmented&gt;0&lt;/segmented&gt;  &lt;object&gt;    &lt;name&gt;drinking_fountain&lt;/name&gt;    &lt;pose&gt;Unspecified&lt;/pose&gt;    &lt;truncated&gt;0&lt;/truncated&gt;    &lt;difficult&gt;0&lt;/difficult&gt;    &lt;bndbox&gt;      &lt;xmin&gt;153&lt;/xmin&gt;      &lt;ymin&gt;6&lt;/ymin&gt;      &lt;xmax&gt;587&lt;/xmax&gt;      &lt;ymax&gt;1157&lt;/ymax&gt;    &lt;/bndbox&gt;  &lt;/object&gt;&lt;/annotation&gt;</code></pre><p>用来修改的python代码的如下：</p><pre><code class="cpp">import osimport os.pathfrom xml.etree.ElementTree import parse, Element#批量修改xml中内容def test():    path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;#xml文件所在的目录    files = os.listdir(path)  # 得到文件夹下所有文件名称    s = []    for xmlFile in files:  # 遍历文件夹        if not os.path.isdir(xmlFile):  # 判断是否是文件夹,不是文件夹才打开            print            xmlFile            pass        path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;        print(xmlFile)        path1 = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;+xmlFile#定位当前处理的文件的路径        newStr = os.path.join(path, xmlFile)        name = &quot;water dispenser&quot;        dom = parse(newStr)  ###最核心的部分,路径拼接,输入的是具体路径        root = dom.getroot()        print(root)        for obj in root.iter(&#39;object&#39;):#获取object节点中的name子节点            obj.find(&#39;name&#39;).text=name            name1 = obj.find(&#39;name&#39;).text#修改            print(name1)        dom.write(path1, xml_declaration=True)#保存到指定文件        passif __name__ == &#39;__main__&#39;:    test()</code></pre>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约瑟夫问题no_2</title>
    <link href="/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/"/>
    <url>/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h4><p>n 个小孩围坐成一圈，并按顺时针编号为1,2,…,n，从编号为 p 的小孩顺时针依次报数，由1报到m ，当报到 m 时，该小孩从圈中出去，然后下一个再从1报数，当报到 m 时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a><strong>Input:</strong></h4><p>每行是用空格分开的三个整数，第一个是n,第二个是p,第三个是m (0 &lt; m,n &lt; 300)。最后一行是: 0 0 0</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>按出圈的顺序输出编号，编号之间以逗号间隔。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><blockquote><p>8 3 4<br>0 0 0</p></blockquote><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h4><blockquote><p>6,2,7,4,3,5,1,8</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;//用循环队列的方式解决约瑟夫问题int main(){    int n,p,m;    while(cin&gt;&gt;n&gt;&gt;p&gt;&gt;m){        queue&lt;int&gt; children;        for(int i=1;i&lt;=n;i++){            children.push(i);        }        //使编号为p的小孩放在队首        for(int i=1;i&lt;p;i++){            //这两句实现了循环队列，将要pop出去的再次放入队尾            children.push(children.front());            children.pop();        }        //m-1个小孩重新入队        while(!children.empty()){            for(int i=1;i&lt;m;i++){                children.push(children.front());                children.pop();            }            //将第m个小孩出队            if(children.size()==1) cout&lt;&lt;children.front()&lt;&lt;endl;            else cout&lt;&lt;children.front();            children.pop();        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>判断两序列是否为同一二叉搜索树序列</p><p><strong>输入描述:</strong><br>开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。<br><strong>输出描述:</strong><br>如果序列相同则输出YES，否则输出NO<br><strong>示例</strong></p><p>输入</p><blockquote><p>2<br>567432<br>543267<br>576342`<br>0 </p></blockquote><p>输出</p><blockquote><p>YES<br>NO</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;//前序遍历和中序遍历可以唯一确定一棵二叉树，//而对二叉排序树而言，相同元素的二叉排序树中//序遍历一定相同，而不同元素二叉排序树使用前//序遍历就可以发现不相同，所以只需要前序遍历//两个二叉树，比较一下就可以判断using namespace std;string pre,in;struct TreeNode{    char data;    TreeNode* leftchild;    TreeNode* rightchild;    TreeNode(char c):data(c),leftchild(NULL),rightchild(NULL){}};TreeNode* Insert(TreeNode* root,char x){    if(root==NULL){        root=new TreeNode(x);    }    else if(x&lt;root-&gt;data){        root-&gt;leftchild=Insert(root-&gt;leftchild,x);    }    else if(x&gt;root-&gt;data){        root-&gt;rightchild=Insert(root-&gt;rightchild,x);    }    return root;}string preorder(TreeNode* root){    if(root==NULL) return &quot;#&quot;;    return root-&gt;data+preorder(root-&gt;leftchild)+preorder(root-&gt;rightchild);}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        string s; TreeNode* root=NULL;        cin&gt;&gt;s;        //构建初始的排序树        for(int i=0;i&lt;s.size();i++){            root=Insert(root,s[i]);        }        string pre=preorder(root);        //构建用来比较的排序树        for(int i=0;i&lt;n;i++){            string str; TreeNode* T=NULL;            cin&gt;&gt;str;            for(int j=0;j&lt;str.size();j++){                T=Insert(T,str[j]);            }            string pre1=preorder(T);        //进行比较            if(pre1==pre) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>二叉排序树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫爬取全国历史天气数据</title>
    <link href="/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>一段很简单的爬虫程序，爬取的网站为<a href="http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据" target="_blank" rel="noopener">http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据</a></p><pre><code class="cpp">from bs4 import BeautifulSoupimport requestsimport pymysqlimport warnings# import pinyin# from pinyin import PinYinfrom pypinyin import pinyin, lazy_pinyinimport pypinyinwarnings.filterwarnings(&quot;ignore&quot;)conn = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, passwd=&#39;root&#39;, db=&#39;test2&#39;, port=3306, charset=&#39;utf8&#39;)cursor = conn.cursor()def get_temperature(url,city):    headers = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,  like Gecko) Chrome/63.0.3239.132 Safari/537.36&#39;}           # 设置头文件信息    response = requests.get(url,  headers=headers).content    # 提交requests get 请求    soup = BeautifulSoup(response,  &quot;lxml&quot;)       # 用Beautifulsoup 进行解析    conmid2 = soup.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    # conmid2 = conmid.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    for info in conmid2:        tr_list = info.find_all(&#39;tr&#39;)[1:]       # 使用切片取到第三个tr标签        for index,  tr in enumerate(tr_list):     # enumerate可以返回元素的位置及内容            td_list = tr.find_all(&#39;td&#39;)            # if index == 0:            date = td_list[0].text.strip().replace(&quot;\n&quot;, &quot;&quot;)  # 取每个标签的text信息，并使用replace()函数将换行符删除            weather = td_list[1].text.strip().replace(&quot;\n&quot;, &quot;&quot;).split(&quot;/&quot;)[0].strip()            temperature = td_list[2].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            wind = td_list[3].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            # else:            #     city_name = td_list[0].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     weather = td_list[4].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     wind = td_list[5].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     max = td_list[3].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     min = td_list[6].text.replace(&#39;\n&#39;,  &#39;&#39;)            print(city,date,  weather,  wind,  temperature)            cursor.execute(&#39;insert into weather(city, date, weather, wind, temp) values(%s, %s, %s, %s, %s)&#39;                           ,  (city,  date,  weather,  wind,  temperature ))if __name__==&#39;__main__&#39;:    # citys1= [&quot;成都市&quot;,&quot;广元市&quot;,&quot;绵阳市&quot;,&quot;德阳市&quot;,&quot;南充市&quot;,&quot;广安市&quot;,&quot;遂宁市&quot;,&quot;内江市&quot;,&quot;乐山市&quot;,&quot;自贡市&quot;,&quot;泸州市&quot;,&quot;宜宾市&quot;,&quot;攀枝花市&quot;,&quot;巴中市&quot;,&quot;达州市&quot;,&quot;资阳市&quot;,&quot;眉山市&quot;,&quot;雅安市&quot;,&quot;崇州市&quot;,&quot;邛崃市&quot;,&quot;都江堰市&quot;,&quot;彭州市&quot;,&quot;江油市&quot;,&quot;什邡市&quot;,&quot;广汉市&quot;,&quot;绵竹市&quot;,&quot;阆中市&quot;,&quot;华蓥市&quot;,&quot;峨眉山市&quot;,&quot;万源市&quot;,&quot;简阳市&quot;,&quot;西昌市&quot;,&quot;康定市&quot;,&quot;马尔康市&quot;,&quot;隆昌市&quot;]    # citys1= [&quot;郑州市&quot;,&quot;开封市&quot;,&quot;洛阳市&quot;,&quot;平顶山市&quot;,&quot;安阳市&quot;,&quot;鹤壁市&quot;,&quot;新乡市&quot;,&quot;焦作市&quot;,&quot;濮阳市&quot;,&quot;许昌市&quot;,&quot;漯河市&quot;,&quot;三门峡市&quot;,&quot;南阳市&quot;,&quot;商丘市&quot;,&quot;周口市&quot;,&quot;驻马店市&quot;,&quot;信阳市&quot;,&quot;荥阳市&quot;,&quot;新郑市&quot;,&quot;登封市&quot;,&quot;新密市&quot;,&quot;偃师市&quot;,&quot;孟州市&quot;,&quot;沁阳市&quot;,&quot;卫辉市&quot;,&quot;辉县市&quot;,&quot;林州市&quot;,&quot;禹州市&quot;,&quot;长葛市&quot;,&quot;舞钢市&quot;,&quot;义马市&quot;,&quot;灵宝市&quot;,&quot;项城市&quot;,&quot;巩义市&quot;,&quot;邓州市&quot;,&quot;永城市&quot;,&quot;汝州市&quot;,&quot;济源市&quot;]    # citys1= [&quot;呼和浩特市&quot;,&quot;包头市&quot;,&quot;乌海市&quot;,&quot;赤峰市&quot;,&quot;通辽市&quot;,&quot;鄂尔多斯市&quot;,&quot;呼伦贝尔市&quot;,&quot;巴彦淖尔市&quot;,&quot;乌兰察布市&quot;,&quot;霍林郭勒市&quot;,&quot;满洲里市&quot;,&quot;牙克石市&quot;,&quot;扎兰屯市&quot;,&quot;额尔古纳市&quot;,&quot;根河市&quot;,&quot;丰镇市&quot;,&quot;乌兰浩特市&quot;,&quot;阿尔山市&quot;,&quot;二连浩特市&quot;,&quot;锡林浩特市&quot;]    # citys1= [&quot;沈阳市&quot;,&quot;大连市&quot;,&quot;鞍山市&quot;,&quot;抚顺市&quot;,&quot;本溪市&quot;,&quot;丹东市&quot;,&quot;锦州市&quot;,&quot;营口市&quot;,&quot;阜新市&quot;,&quot;辽阳市&quot;,&quot;盘锦市&quot;,&quot;铁岭市&quot;,&quot;朝阳市&quot;,&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    # citys1= [&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    citys1= [&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    for city in citys1:        city1 = &#39;&#39;.join(lazy_pinyin(city[:-1]))        print(city1)        urls = [&#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201801.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201802.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201803.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201804.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201805.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201806.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201807.html&#39;]        for url in urls:            get_temperature(url, city)        conn.commit()</code></pre>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
