<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最小邮票数</title>
    <link href="/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/"/>
    <url>/2020/02/15/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。</p><p><strong>输入描述:</strong><br>    有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。</p><p><strong>输出描述:</strong><br>      对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。</p><p><strong>输入</strong></p><blockquote><p>10<br>5<br>1 3 3 3 4</p></blockquote><p><strong>输出</strong></p><blockquote><p>3</p></blockquote><pre><code class="cpp">/*    最少邮票数 &gt;&gt; 01动态规划    状态    集合中数字    dp[i][j]    0   1   2   3   4   5   6   7   8   9   10    1           0   1   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞   ∞    1 3         0   1   ∞   1   2   ∞   ∞   ∞   ∞   ∞   ∞    1 3 3       0   1   ∞   1   2   ∞   2   3   ∞   ∞   ∞    1 3 3 3     0   1   ∞   1   2   ∞   2   ∞   ∞   3   4    1 3 3 3 4   0   1   ∞   1   2   2   2   2   3   3   3      状态迁移方程    dp[j] = min{dp[j],dp[j-stamp[i]]+1}    其中dp[j-stamp[i]]+1，表示将第i个邮票加入集合后 凑总量为j的面额 所需要的最少邮票数量*/#include&lt;stdio.h&gt;#define INF 1000int stamp[1000];int dp[1000];// 返回最少数量，num表示邮票的个数，deno表示要凑成的面额int Min_Stamp(int num,int deno){    int i,j;    //将状态全部初始化为最多    for(j=0;j&lt;=deno;++j){        dp[j]= (j==0)?0:INF;           }    for(i=0;i&lt;num;i++){        //从后向前寻找若能凑成，且使数量变少就使用，不能也无所谓因为还是INF        for(j=deno;j&gt;=stamp[i];j--){            if(dp[j-stamp[i]]!=INF)dp[j]=(dp[j] &lt; dp[j-stamp[i]]+1)? dp[j]: dp[j-stamp[i]]+1;        }    }    return dp[deno]==INF?0:dp[deno];}int main(){    int num,deno;    while(scanf(&quot;%d %d&quot;,&amp;deno,&amp;num)!=EOF){        for(int i=0;i&lt;num;i++)scanf(&quot;%d&quot;,stamp+i);        printf(&quot;%d&quot;,Min_Stamp(num,deno));    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点菜问题</title>
    <link href="/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/15/%E7%82%B9%E8%8F%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    北大网络实验室经常有活动需要叫外卖，但是每次叫外卖的报销经费的总额最大为C元，有N种菜可以点，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大。     注意：由于需要营养多样化，每种菜只能点一次。</p><p><strong>输入描述:</strong><br>    输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。</p><p><strong>输出描述:</strong><br>    输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。</p><p><strong>输入</strong></p><blockquote><p>90 4<br>20 25<br>30 20<br>40 50<br>10 18<br>40 2<br>25 30<br>10 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>95 38</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//背包问题using namespace std;const int MAXN=1001;int dp[MAXN];int v[MAXN];//物品价值int w[MAXN];//物品重量int main(){    int n,m;    cin&gt;&gt;m&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;w[i]&gt;&gt;v[i];    }    for(int i=0;i&lt;=m;i++){        dp[i]=0;//初始化    }    for(int i=0;i&lt;n;i++){        for(int j=m;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[m]&lt;&lt;endl;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/14/Common%20Subsequence/"/>
    <url>/2020/02/14/Common%20Subsequence/</url>
    
    <content type="html"><![CDATA[<p><strong>Description</strong><br>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><p><strong>Input</strong><br>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><p><strong>Output</strong><br>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><p><strong>Sample Input</strong></p><blockquote><p>abcfbc            abfcab<br>programming    contest<br>abcd           mnp</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4<br>2<br>0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//最长公共子序列using namespace std;const int MAXN=1001;char s1[MAXN];char s2[MAXN];int dp[MAXN][MAXN];int main(){    while(scanf(&quot;%s%s&quot;,s1+1,s2+1)!=EOF){//从下标1开始输入        int n=strlen(s1+1);        int m=strlen(s2+1);        for(int i=0;i&lt;=n;i++){            for(int j=0;j&lt;=m;j++){                if(i==0||j==0){//边界条件初始化                    dp[i][j]=0;                    continue;                }                //状态转移方程                if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队列</title>
    <link href="/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/13/%E5%90%88%E5%94%B1%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK， 则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>输入描述:</strong><br>输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。<br>第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。</p><p><strong>输出描述:</strong><br>可能包括多组测试数据，对于每组数据，<br>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><p><strong>输入</strong></p><blockquote><p>8<br>186 186 150 200 160 130 197 220</p></blockquote><p><strong>输出</strong></p><blockquote><p>4</p></blockquote><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;int num[100];int dp1[100];int dp2[100];//枚举每个位置，从左边找最长上升子序列，从右边开始找最长下降子序列，两个数相加就是题目所说的唱歌的人数。int main(){    int count;    while(cin&gt;&gt;count){        for(int i=0;i&lt;count;i++){            cin&gt;&gt;num[i];        }        for(int i=0;i&lt;count;i++){            dp1[i]=1;            for(int j=0;j&lt;i;j++){                if(num[i]&gt;num[j]){                    dp1[i]=max(dp1[j]+1,dp1[i]);                }            }        }        for(int i=count-1;i&gt;=0;i--){            dp2[i]=1;            for(int j=count-1;j&gt;i;j--){                if(num[i]&gt;num[j]){                    dp2[i]=max(dp2[i],dp2[j]+1);                }            }        }        int total=0;        for(int i=0;i&lt;count;i++){//i此时是作为最中间的一个点            total=max(dp1[i]+dp2[i]-1,total);        }        cout&lt;&lt;count-total&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大上升子序列和</title>
    <link href="/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/13/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p><p><strong>输入描述:</strong><br>输入包含多组测试数据。<br>每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</p><p><strong>输出描述:</strong><br>对于每组测试数据，输出其最大上升子序列和。</p><p><strong>输入</strong></p><blockquote><p>7<br>1 7 3 5 9 4 8</p></blockquote><p><strong>输出</strong></p><blockquote><p>18</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1001;int a[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=a[i];//初始化为a[i]            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列                if(a[i]&gt;a[j]){                    dp[i]=max(dp[i],dp[j]+a[i]);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拦截导弹</title>
    <link href="/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/"/>
    <url>/2020/02/13/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。 </p><p><strong>输入描述:</strong><br>每组输入有两行，<br>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），<br>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p><p><strong>输出描述:</strong><br>每组输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p><p><strong>输入</strong></p><blockquote><p>8<br>300 207 155 300 299 170 158 65</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;//动态规划：最长递增子序列//状态转移方程：dp[i]=max(1,dp[j]+1|j&lt;i&amp;&amp;Aj&gt;Ai)using namespace std;const int MAXN=25;int height[MAXN];int dp[MAXN];int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;height[i];        }        int answer=0;        for(int i=0;i&lt;n;i++){            dp[i]=1;//初始化为1            for(int j=0;j&lt;i;j++){//得出以i为最后一个的最大的序列长度                if(height[i]&lt;=height[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            answer=max(answer,dp[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。<br><strong>输入描述:</strong><br>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。<br>再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。<br>已知矩阵中整数的范围都在[-127, 127]。<br><strong>输出描述:</strong><br>测试数据可能有多组，对于每组测试数据，输出最大子矩阵的大小。<br>示例1<br><strong>输入</strong></p><blockquote><p>4<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4  1<br>-1 8  0 -2</p></blockquote><p><strong>输出</strong></p><blockquote><p>15</p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN=100;int dp[MAXN];int arr[MAXN];int matrix[MAXN][MAXN];int total[MAXN][MAXN];//total[i][j]表示从这个元素往上的所有元素的和int MaxSubsequence(int n){    int maximum=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=arr[i];        else dp[i]=max(dp[i-1]+arr[i],arr[i]);        maximum=max(maximum,dp[i]);    }    return maximum;}int maxSubmatrix(int n){    int maximal=0;    for(int i=0;i&lt;n;i++){        for(int j=i;j&lt;n;j++){//            for(int k=0;k&lt;n;k++){//获得一维数组                if(i==0) arr[k]=total[j][k];                else arr[k]=total[j][k]-total[i-1][k];            }        int current =MaxSubsequence(n);        maximal = max(maximal,current);        }    }    return maximal;}int main(){    int N;    while(cin&gt;&gt;N){        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                cin&gt;&gt;matrix[i][j];            }        }        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                if(i==0) total[i][j]=matrix[i][j];                else total[i][j]=total[i-1][j]+matrix[i][j];            }        }        int result=maxSubmatrix(N);        cout&lt;&lt;result&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>    给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。<br><strong>输入描述:</strong><br>    测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。<br><strong>输出描述:</strong><br>    对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。<br><strong>输入</strong></p><blockquote><p>6<br>-2 11 -4 13 -5 -2 10<br>-10<br>1 2 3 4 -5 -23 3 7 -21<br>6<br>5 -8 3 2 5 0<br>1<br>10<br>3<br>-1 -5 -2<br>3<br>-1 0 -2<br>0</p></blockquote><p><strong>输出</strong></p><blockquote><p>20 11 13<br>10 1 4<br>10 3 5<br>10 10 10<br>0 -1 -2<br>0 0 0</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=10000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];void maxSub(int n,int&amp; Max,int&amp; first,int&amp; last){    Max=0,first=0,last=n-1;    //第一次遍历找出最大子序列和    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    //第二次遍历确定最大子序列的两个边界    for(int i=0;i&lt;n;i++){        if(i==0){            dp[i]=a[i];        }        else if(dp[i-1]+a[i]&gt;a[i]){            last=i;//当前子序列继续扩充元素            dp[i]=dp[i-1]+a[i];        }        else{            first=i;//从当前的元素重新往后找，赋值first            dp[i]=a[i];        }        if(dp[i]==Max){            last=i;//此时已经找到最大的子序列，给last赋最终值            return;        }    }}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        int Max,first,last;        maxSub(n,Max,first,last);        cout&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;a[first]&lt;&lt;&quot; &quot;&lt;&lt;a[last]&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大序列和</title>
    <link href="/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2020/02/12/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。<br><strong>输入描述</strong>:<br>第一行为一个正整数N，第二行为N个整数，表示序列中的数。<br><strong>输出描述:</strong><br>输入可能包括多组数据，对于每一组输入数据，<br>仅输出一个数，表示最大序列和。<br><strong>输入</strong></p><blockquote><p>5<br>1 5 -3 2 4<br>6<br>1 -2 3 4 -10 6<br>4<br>-3 -1 -2 -5</p></blockquote><p><strong>输出</strong></p><blockquote><p>9<br>7<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1000000;int dp[MAXN];//dp[i]表示以第i个元素为末尾的连续序列的最大和,只有两种情况，一个或多个int a[MAXN];int maxSub(int n){    int Max=0;    for(int i=0;i&lt;n;i++){        if(i==0) dp[i]=a[i];//初始        else dp[i]=max(dp[i-1]+a[i],a[i]);//多个vs一个        if(dp[i]&gt;Max) Max=dp[i];    }    return Max;}int main(){    int n;    while(cin&gt;&gt;n){        for(int i=0;i&lt;n;i++){            cin&gt;&gt;a[i];        }        cout&lt;&lt;maxSub(n)&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文</title>
    <link href="/2020/02/11/%E8%AE%BA%E6%96%87/"/>
    <url>/2020/02/11/%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>小H为了完成一篇论文，一共要完成n个实验。其中第i个实验需要ai的时间去完成。小H可以同时进行若干实验，但存在一些实验，只有当它的若干前置实验完成时，才能开始进行该实验。同时我们认为小H在一个实验的前置实验都完成时，就能马上开始该实验。为了让小H尽快完成论文，需要知道在最优的情况下，最后一个完成的实验什么时候完成？小H还想知道，在保证最后一个实验尽快完成的情况下（即保证上一问的答案不变），他想知道每个实验最晚可以什么时候开始。设第i个实验最早可能的开始时间为fi，不影响最后一个实验完成时间的最晚开始时间为gi，请你证明<img src="https://img-blog.csdnimg.cn/20200211171228484.png" srcset="/img/loading.gif" alt="">除以10^9+7所得的余数。题目保证有解。</p><p><strong>输入描述:</strong><br>从标准输入读入数据。<br>第一行输入一个整数n，m。<br>第二行输入n个正整数，a1,a2,…..an,描述每个实验完成所需要的时间。<br>接下来读入m行，每行读入两个整数u,v，表示编号为u的实验是编号为v的实验的前置实验。<br>对于所有的输入数据，都满足1&lt;=n&lt;=10^5,1&lt;=m&lt;=5<em>10^5,1&lt;=ai&lt;=10^6。<br>*</em>输出描述:**<br>输出到标准输出。<br>第一行输出一个整数表示最晚完成的实验的时间。<br>第二行输出一个整数表示除以10^9+7所得的余数。<br>输入输出样例<br><strong>输入样例#:</strong></p><blockquote><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p></blockquote><p><strong>输出样例#:</strong></p><blockquote><p>34<br>7840</p></blockquote><p>提示：<br>第一个点最早开始时间为20，最晚开始时间为23。<br>第二个点最早开始时间为0，最晚开始时间为3。<br>第三个点最早开始时间为17，最晚开始时间为17。<br>第四个点最早开始时间为20，最晚开始时间为24。<br>第五个点最早开始时间为0，最晚开始时间为13。<br>第六个点最早开始时间为0，最晚开始时间为6。<br>第七个点最早开始时间为0，最晚开始时间为0。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1e5+7;const int INF=INT_MAX;const int MOD=1e9+7;vector&lt;int&gt; graph[MAXN];//邻接表long long earliest[MAXN];//最早开始时间long long latest[MAXN];//最晚开始时间long long time[MAXN];//花费时间int inDegree[MAXN];long long CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=1;i&lt;=n;i++){        if(inDegree[i]==0){            node.push(i);        }    }    long long totalTime=0;//总耗时    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i];            earliest[v]=max(earliest[v],earliest[u]+time[u]);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0){                node.push(v);                totalTime=max(totalTime,earliest[v]+time[v]);            }        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=totalTime-time[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j];            latest[u]=min(latest[u],latest[v]-time[u]);//逆向找最小，形成latest        }    }    return totalTime;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        memset(time,0,sizeof(time));        for(int i=1;i&lt;=n;i++){            cin&gt;&gt;time[i];        }        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;        }        long long totalTime=CriticalPath(n);        long long answer=1;        for(int i=1;i&lt;=n;i++){            answer*=latest[i]-earliest[i]+1;            answer%=MOD;        }        cout&lt;&lt;totalTime&lt;&lt;endl;        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction Arrangement</title>
    <link href="/2020/02/11/Instruction%20Arrangement/"/>
    <url>/2020/02/11/Instruction%20Arrangement/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>Ali has taken the Computer Organization and Architecture course this term. He learned that there may be dependence between instructions, like WAR (write after read), WAW, RAW.<br>If the distance between two instructions is less than the Safe Distance, it will result in hazard, which may cause wrong result. So we need to design special circuit to eliminate hazard. However the most simple way to solve this problem is to add bubbles (useless operation), which means wasting time to ensure that the distance between two instructions is not smaller than the Safe Distance.<br>The definition of the distance between two instructions is the difference between their beginning times.<br>Now we have many instructions, and we know the dependent relations and Safe Distances between instructions. We also have a very strong CPU with infinite number of cores, so you can run as many instructions as you want simultaneity, and the CPU is so fast that it just cost 1ns to finish any instruction.<br>Your job is to rearrange the instructions so that the CPU can finish all the instructions using minimum time.<br><strong>Input</strong><br>The input consists several testcases.<br>The first line has two integers N, M (N &lt;= 1000, M &lt;= 10000), means that there are N instructions and M dependent relations.<br>The following M lines, each contains three integers X, Y , Z, means the Safe Distance between X and Y is Z, and Y should run after X. The instructions are numbered from 0 to N - 1.<br><strong>Output</strong><br>Print one integer, the minimum time the CPU needs to run.</p><p><strong>Sample Input</strong></p><blockquote><p>5 2<br>1 2 1<br>3 4 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Hint</strong><br>In the 1st ns, instruction 0, 1 and 3 are executed;<br>In the 2nd ns, instruction 2 and 4 are executed.<br>So the answer should be 2.</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;const int MAXN=1001;const int INF=INT_MAX;struct Edge{    int to;    int length;    Edge(int t,int l):to(t),length(l){}};vector&lt;Edge&gt; graph[MAXN];//邻接表int earliest[MAXN];//最早开始时间int latest[MAXN];//最晚开始时间int inDegree[MAXN];void CriticalPath(int n){    vector&lt;int&gt; topology;//拓扑序列    queue&lt;int&gt; node;    for(int i=0;i&lt;n;i++){        if(inDegree[i]==0){            node.push(i);            earliest[i]=1;//初始化为1,题目中的要求：1ns        }    }    while(!node.empty()){        int u=node.front();        topology.push_back(u);        node.pop();        for(int i=0;i&lt;graph[u].size();i++){            int v=graph[u][i].to;            int l=graph[u][i].length;            earliest[v]=max(earliest[v],earliest[u]+l);//正向找最大，形成earliest            inDegree[v]--;            if(inDegree[v]==0) node.push(v);        }    }    for(int i=topology.size()-1;i&gt;=0;i--){        int u=topology[i];        if(graph[u].size()==0) latest[u]=earliest[u];//汇点的最晚开始时间初始化        else latest[u]=INF;//非汇点的最晚开始时间的初始化        for(int j=0;j&lt;graph[u].size();j++){            int v=graph[u][j].to;            int l=graph[u][j].length;            latest[u]=min(latest[u],latest[v]-l);//逆向找最小，形成latest        }    }}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        memset(graph,0,sizeof(graph));        memset(earliest,0,sizeof(earliest));        memset(latest,0,sizeof(latest));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to,length;            cin&gt;&gt;from&gt;&gt;to&gt;&gt;length;            graph[from].push_back(Edge(to,length));            inDegree[to]++;        }        CriticalPath(n);        int answer=0;        for(int i=0;i&lt;n;i++){            answer=max(answer,earliest[i]);        }        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>关键路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jungle roads</title>
    <link href="/2020/02/10/Jungle%20roads/"/>
    <url>/2020/02/10/Jungle%20roads/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br><img src="https://img-blog.csdnimg.cn/20200210210056936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQwODgy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.<br><strong>Input</strong><br>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.<br><strong>Output</strong><br>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. </p><p><strong>Sample Input</strong></p><blockquote><p>9<br>A 2 B 12 I 25<br>B 3 C 10 H 40 I 8<br>C 2 D 18 G 55<br>D 1 E 44<br>E 2 F 60 G 38<br>F 0<br>G 1 H 35<br>H 1 I 35<br>3 A 2 B 10 C 40<br>B 1 C 20<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>216<br>30</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;struct Edge{    int from;    int to;    int length;    bool operator&lt;(const Edge&amp; e) const{//жиди&lt;a        return length&lt;e.length;    }};Edge edge[MAXN*MAXN];int father[MAXN];int height[MAXN];void Initial(int n){    for(int i=0;i&lt;n;i++){        father[i]=i;        height[i]=0;    }}int Find(int x){    if(father[x]!=x) return Find(father[x]);    else return father[x];}void Union(int x,int y){    x=Find(x);    y=Find(y);    if(x!=y){        if(height[x]&lt;height[y]) father[x]=y;        else if(height[x]&gt;height[y]) father[y]=x;        else{            father[y]=x; height[x]++;        }    }}int Kruskal(int n,int edgeNumber){    Initial(n);    sort(edge,edge+edgeNumber);    int sum=0;    for(int i=0;i&lt;edgeNumber;i++){        Edge current=edge[i];        //cout&lt;&lt;current.from&lt;&lt;&quot;-&gt;&quot;&lt;&lt;current.to&lt;&lt;&quot; &quot;&lt;&lt;current.length&lt;&lt;endl;        if(Find(current.from)!=Find(current.to)){            Union(current.from,current.to);            sum+=current.length;        }    }    return sum;}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        int k=0;        for(int i=0;i&lt;n-1;i++){            char v; int num;            cin&gt;&gt;v&gt;&gt;num;            for(int j=0;j&lt;num;j++){                char v1; int length;                cin&gt;&gt;v1&gt;&gt;length;                edge[k].from=i;                edge[k].to=v1-&#39;A&#39;;                edge[k].length=length;                k++;            }        }        int answer=Kruskal(n,k);        cout&lt;&lt;answer&lt;&lt;endl;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>畅通工程续</title>
    <link href="/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/"/>
    <url>/2020/02/10/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p><p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p><p><strong>Input</strong><br>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p><p><strong>Output</strong><br>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.<br><strong>Sample Input</strong></p><blockquote><p>3 3<br>0 1 1<br>0 2 3<br>1 2 1<br>0 2<br>3 1<br>0 1 1<br>1 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>-1</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];//邻接表的实现int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        if(n==0&amp;&amp;m==0) break;        memset(graph,0,sizeof(graph));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;//在输入时更新入度数组        }        vector&lt;int&gt; answer=TopologicalSort(n);        for(int i=0;i&lt;answer.size();i++){            if(i==0) cout&lt;&lt;answer[i];            else cout&lt;&lt;&quot; &quot;&lt;&lt;answer[i];        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>确定比赛名次</title>
    <link href="/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/"/>
    <url>/2020/02/10/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p><p><strong>Input</strong><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p><p><strong>Output</strong><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><p><strong>Sample Input</strong></p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 2 4 3</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int MAXN=500;vector&lt;int&gt; graph[MAXN];//邻接表的实现int inDegree[MAXN];vector&lt;int&gt; TopologicalSort(int n){    vector&lt;int&gt; topology;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;//逆向优先队列，为了实现拓扑序列不唯一时编号小的在前面    for(int i=1;i&lt;=n;i++){//i是从1到n，即结点的编号        if(inDegree[i]==0){//先把初始入度为零的全部放入队列            node.push(i);        }    }//求解拓扑序列时一定先把上一层的所有全部入队后再入队下一层，所以优先队列不会干扰    while(!node.empty()){        int u=node.top();        node.pop();        topology.push_back(u);        for(int i=0;i&lt;graph[u].size();i++){//遍历当前pop出的结点的所有出弧            int v=graph[u][i];            inDegree[v]--;            if(inDegree[v]==0){//u的所有出弧全部去掉后如果有入度为零的则push进队列                node.push(v);            }        }    }    return topology;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m){        if(n==0&amp;&amp;m==0) break;        memset(graph,0,sizeof(graph));        memset(inDegree,0,sizeof(inDegree));        while(m--){            int from,to;            cin&gt;&gt;from&gt;&gt;to;            graph[from].push_back(to);            inDegree[to]++;//在输入时更新入度数组        }        vector&lt;int&gt; answer=TopologicalSort(n);        for(int i=0;i&lt;answer.size();i++){            if(i==0) cout&lt;&lt;answer[i];            else cout&lt;&lt;&quot; &quot;&lt;&lt;answer[i];        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量修改XML中的标签值</title>
    <link href="/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/"/>
    <url>/2020/02/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9XML%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>因为用labelimg给图片打标签的时候打错了，本来是water dispenser弄成了drinking_fountain了，尴尬_(:з)∠)_，并且已经标了1500张了，只能自己写程序改，xml文件示例如下：</p><pre><code class="cpp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;us-ascii&#39;?&gt;&lt;annotation verified=&quot;no&quot;&gt;  &lt;folder&gt;drinking_fountain&lt;/folder&gt;  &lt;filename&gt;1&lt;/filename&gt;  &lt;path&gt;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain\1.jpg&lt;/path&gt;  &lt;source&gt;    &lt;database&gt;Unknown&lt;/database&gt;  &lt;/source&gt;  &lt;size&gt;    &lt;width&gt;720&lt;/width&gt;    &lt;height&gt;1280&lt;/height&gt;    &lt;depth&gt;3&lt;/depth&gt;  &lt;/size&gt;  &lt;segmented&gt;0&lt;/segmented&gt;  &lt;object&gt;    &lt;name&gt;drinking_fountain&lt;/name&gt;    &lt;pose&gt;Unspecified&lt;/pose&gt;    &lt;truncated&gt;0&lt;/truncated&gt;    &lt;difficult&gt;0&lt;/difficult&gt;    &lt;bndbox&gt;      &lt;xmin&gt;153&lt;/xmin&gt;      &lt;ymin&gt;6&lt;/ymin&gt;      &lt;xmax&gt;587&lt;/xmax&gt;      &lt;ymax&gt;1157&lt;/ymax&gt;    &lt;/bndbox&gt;  &lt;/object&gt;&lt;/annotation&gt;</code></pre><p>用来修改的python代码的如下：</p><pre><code class="cpp">import osimport os.pathfrom xml.etree.ElementTree import parse, Element#批量修改xml中内容def test():    path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;#xml文件所在的目录    files = os.listdir(path)  # 得到文件夹下所有文件名称    s = []    for xmlFile in files:  # 遍历文件夹        if not os.path.isdir(xmlFile):  # 判断是否是文件夹,不是文件夹才打开            print            xmlFile            pass        path = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;        print(xmlFile)        path1 = &quot;E:\LabelImgv1.3.3\windows_v1.3.3\drinking_fountain_label/&quot;+xmlFile#定位当前处理的文件的路径        newStr = os.path.join(path, xmlFile)        name = &quot;water dispenser&quot;        dom = parse(newStr)  ###最核心的部分,路径拼接,输入的是具体路径        root = dom.getroot()        print(root)        for obj in root.iter(&#39;object&#39;):#获取object节点中的name子节点            obj.find(&#39;name&#39;).text=name            name1 = obj.find(&#39;name&#39;).text#修改            print(name1)        dom.write(path1, xml_declaration=True)#保存到指定文件        passif __name__ == &#39;__main__&#39;:    test()</code></pre>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约瑟夫问题no_2</title>
    <link href="/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/"/>
    <url>/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h4><p>n 个小孩围坐成一圈，并按顺时针编号为1,2,…,n，从编号为 p 的小孩顺时针依次报数，由1报到m ，当报到 m 时，该小孩从圈中出去，然后下一个再从1报数，当报到 m 时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a><strong>Input:</strong></h4><p>每行是用空格分开的三个整数，第一个是n,第二个是p,第三个是m (0 &lt; m,n &lt; 300)。最后一行是: 0 0 0</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>按出圈的顺序输出编号，编号之间以逗号间隔。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><blockquote><p>8 3 4<br>0 0 0</p></blockquote><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h4><blockquote><p>6,2,7,4,3,5,1,8</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;//用循环队列的方式解决约瑟夫问题int main(){    int n,p,m;    while(cin&gt;&gt;n&gt;&gt;p&gt;&gt;m){        queue&lt;int&gt; children;        for(int i=1;i&lt;=n;i++){            children.push(i);        }        //使编号为p的小孩放在队首        for(int i=1;i&lt;p;i++){            //这两句实现了循环队列，将要pop出去的再次放入队尾            children.push(children.front());            children.pop();        }        //m-1个小孩重新入队        while(!children.empty()){            for(int i=1;i&lt;m;i++){                children.push(children.front());                children.pop();            }            //将第m个小孩出队            if(children.size()==1) cout&lt;&lt;children.front()&lt;&lt;endl;            else cout&lt;&lt;children.front();            children.pop();        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>判断两序列是否为同一二叉搜索树序列</p><p><strong>输入描述:</strong><br>开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。<br><strong>输出描述:</strong><br>如果序列相同则输出YES，否则输出NO<br><strong>示例</strong></p><p>输入</p><blockquote><p>2<br>567432<br>543267<br>576342`<br>0 </p></blockquote><p>输出</p><blockquote><p>YES<br>NO</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;//前序遍历和中序遍历可以唯一确定一棵二叉树，//而对二叉排序树而言，相同元素的二叉排序树中//序遍历一定相同，而不同元素二叉排序树使用前//序遍历就可以发现不相同，所以只需要前序遍历//两个二叉树，比较一下就可以判断using namespace std;string pre,in;struct TreeNode{    char data;    TreeNode* leftchild;    TreeNode* rightchild;    TreeNode(char c):data(c),leftchild(NULL),rightchild(NULL){}};TreeNode* Insert(TreeNode* root,char x){    if(root==NULL){        root=new TreeNode(x);    }    else if(x&lt;root-&gt;data){        root-&gt;leftchild=Insert(root-&gt;leftchild,x);    }    else if(x&gt;root-&gt;data){        root-&gt;rightchild=Insert(root-&gt;rightchild,x);    }    return root;}string preorder(TreeNode* root){    if(root==NULL) return &quot;#&quot;;    return root-&gt;data+preorder(root-&gt;leftchild)+preorder(root-&gt;rightchild);}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        string s; TreeNode* root=NULL;        cin&gt;&gt;s;        //构建初始的排序树        for(int i=0;i&lt;s.size();i++){            root=Insert(root,s[i]);        }        string pre=preorder(root);        //构建用来比较的排序树        for(int i=0;i&lt;n;i++){            string str; TreeNode* T=NULL;            cin&gt;&gt;str;            for(int j=0;j&lt;str.size();j++){                T=Insert(T,str[j]);            }            string pre1=preorder(T);        //进行比较            if(pre1==pre) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>二叉排序树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫爬取全国历史天气数据</title>
    <link href="/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/02/09/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>一段很简单的爬虫程序，爬取的网站为<a href="http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据" target="_blank" rel="noopener">http://www.tianqihoubao.com，可以自己修改爬取城市以及爬取的月份，这里爬取的是1到7月的数据</a></p><pre><code class="cpp">from bs4 import BeautifulSoupimport requestsimport pymysqlimport warnings# import pinyin# from pinyin import PinYinfrom pypinyin import pinyin, lazy_pinyinimport pypinyinwarnings.filterwarnings(&quot;ignore&quot;)conn = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, passwd=&#39;root&#39;, db=&#39;test2&#39;, port=3306, charset=&#39;utf8&#39;)cursor = conn.cursor()def get_temperature(url,city):    headers = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,  like Gecko) Chrome/63.0.3239.132 Safari/537.36&#39;}           # 设置头文件信息    response = requests.get(url,  headers=headers).content    # 提交requests get 请求    soup = BeautifulSoup(response,  &quot;lxml&quot;)       # 用Beautifulsoup 进行解析    conmid2 = soup.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    # conmid2 = conmid.findAll(&#39;div&#39;,  class_=&#39;wdetail&#39;)    for info in conmid2:        tr_list = info.find_all(&#39;tr&#39;)[1:]       # 使用切片取到第三个tr标签        for index,  tr in enumerate(tr_list):     # enumerate可以返回元素的位置及内容            td_list = tr.find_all(&#39;td&#39;)            # if index == 0:            date = td_list[0].text.strip().replace(&quot;\n&quot;, &quot;&quot;)  # 取每个标签的text信息，并使用replace()函数将换行符删除            weather = td_list[1].text.strip().replace(&quot;\n&quot;, &quot;&quot;).split(&quot;/&quot;)[0].strip()            temperature = td_list[2].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            wind = td_list[3].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;/&quot;)[0].strip()            # else:            #     city_name = td_list[0].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     weather = td_list[4].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     wind = td_list[5].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     max = td_list[3].text.replace(&#39;\n&#39;,  &#39;&#39;)            #     min = td_list[6].text.replace(&#39;\n&#39;,  &#39;&#39;)            print(city,date,  weather,  wind,  temperature)            cursor.execute(&#39;insert into weather(city, date, weather, wind, temp) values(%s, %s, %s, %s, %s)&#39;                           ,  (city,  date,  weather,  wind,  temperature ))if __name__==&#39;__main__&#39;:    # citys1= [&quot;成都市&quot;,&quot;广元市&quot;,&quot;绵阳市&quot;,&quot;德阳市&quot;,&quot;南充市&quot;,&quot;广安市&quot;,&quot;遂宁市&quot;,&quot;内江市&quot;,&quot;乐山市&quot;,&quot;自贡市&quot;,&quot;泸州市&quot;,&quot;宜宾市&quot;,&quot;攀枝花市&quot;,&quot;巴中市&quot;,&quot;达州市&quot;,&quot;资阳市&quot;,&quot;眉山市&quot;,&quot;雅安市&quot;,&quot;崇州市&quot;,&quot;邛崃市&quot;,&quot;都江堰市&quot;,&quot;彭州市&quot;,&quot;江油市&quot;,&quot;什邡市&quot;,&quot;广汉市&quot;,&quot;绵竹市&quot;,&quot;阆中市&quot;,&quot;华蓥市&quot;,&quot;峨眉山市&quot;,&quot;万源市&quot;,&quot;简阳市&quot;,&quot;西昌市&quot;,&quot;康定市&quot;,&quot;马尔康市&quot;,&quot;隆昌市&quot;]    # citys1= [&quot;郑州市&quot;,&quot;开封市&quot;,&quot;洛阳市&quot;,&quot;平顶山市&quot;,&quot;安阳市&quot;,&quot;鹤壁市&quot;,&quot;新乡市&quot;,&quot;焦作市&quot;,&quot;濮阳市&quot;,&quot;许昌市&quot;,&quot;漯河市&quot;,&quot;三门峡市&quot;,&quot;南阳市&quot;,&quot;商丘市&quot;,&quot;周口市&quot;,&quot;驻马店市&quot;,&quot;信阳市&quot;,&quot;荥阳市&quot;,&quot;新郑市&quot;,&quot;登封市&quot;,&quot;新密市&quot;,&quot;偃师市&quot;,&quot;孟州市&quot;,&quot;沁阳市&quot;,&quot;卫辉市&quot;,&quot;辉县市&quot;,&quot;林州市&quot;,&quot;禹州市&quot;,&quot;长葛市&quot;,&quot;舞钢市&quot;,&quot;义马市&quot;,&quot;灵宝市&quot;,&quot;项城市&quot;,&quot;巩义市&quot;,&quot;邓州市&quot;,&quot;永城市&quot;,&quot;汝州市&quot;,&quot;济源市&quot;]    # citys1= [&quot;呼和浩特市&quot;,&quot;包头市&quot;,&quot;乌海市&quot;,&quot;赤峰市&quot;,&quot;通辽市&quot;,&quot;鄂尔多斯市&quot;,&quot;呼伦贝尔市&quot;,&quot;巴彦淖尔市&quot;,&quot;乌兰察布市&quot;,&quot;霍林郭勒市&quot;,&quot;满洲里市&quot;,&quot;牙克石市&quot;,&quot;扎兰屯市&quot;,&quot;额尔古纳市&quot;,&quot;根河市&quot;,&quot;丰镇市&quot;,&quot;乌兰浩特市&quot;,&quot;阿尔山市&quot;,&quot;二连浩特市&quot;,&quot;锡林浩特市&quot;]    # citys1= [&quot;沈阳市&quot;,&quot;大连市&quot;,&quot;鞍山市&quot;,&quot;抚顺市&quot;,&quot;本溪市&quot;,&quot;丹东市&quot;,&quot;锦州市&quot;,&quot;营口市&quot;,&quot;阜新市&quot;,&quot;辽阳市&quot;,&quot;盘锦市&quot;,&quot;铁岭市&quot;,&quot;朝阳市&quot;,&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    # citys1= [&quot;葫芦岛市&quot;,&quot;新民市&quot;,&quot;瓦房店市&quot;,&quot;庄河市&quot;,&quot;海城市&quot;,&quot;东港市&quot;,&quot;凤城市&quot;,&quot;凌海市&quot;,&quot;北镇市&quot;,&quot;盖州市&quot;,&quot;大石桥市&quot;,&quot;灯塔市&quot;,&quot;调兵山市&quot;,&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    citys1= [&quot;开原市&quot;,&quot;北票市&quot;,&quot;凌源市&quot;,&quot;兴城市&quot;]    for city in citys1:        city1 = &#39;&#39;.join(lazy_pinyin(city[:-1]))        print(city1)        urls = [&#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201801.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201802.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201803.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201804.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201805.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201806.html&#39;,                &#39;http://www.tianqihoubao.com/lishi/&#39;+city1+&#39;/month/201807.html&#39;]        for url in urls:            get_temperature(url, city)        conn.commit()</code></pre>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
