<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>约瑟夫问题no_2</title>
    <link href="/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/"/>
    <url>/2020/02/09/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98no_2/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h4><p>n 个小孩围坐成一圈，并按顺时针编号为1,2,…,n，从编号为 p 的小孩顺时针依次报数，由1报到m ，当报到 m 时，该小孩从圈中出去，然后下一个再从1报数，当报到 m 时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a><strong>Input:</strong></h4><p>每行是用空格分开的三个整数，第一个是n,第二个是p,第三个是m (0 &lt; m,n &lt; 300)。最后一行是: 0 0 0</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>按出圈的顺序输出编号，编号之间以逗号间隔。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><blockquote><p>8 3 4<br>0 0 0</p></blockquote><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h4><blockquote><p>6,2,7,4,3,5,1,8</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;//用循环队列的方式解决约瑟夫问题int main(){    int n,p,m;    while(cin&gt;&gt;n&gt;&gt;p&gt;&gt;m){        queue&lt;int&gt; children;        for(int i=1;i&lt;=n;i++){            children.push(i);        }        //使编号为p的小孩放在队首        for(int i=1;i&lt;p;i++){            //这两句实现了循环队列，将要pop出去的再次放入队尾            children.push(children.front());            children.pop();        }        //m-1个小孩重新入队        while(!children.empty()){            for(int i=1;i&lt;m;i++){                children.push(children.front());                children.pop();            }            //将第m个小孩出队            if(children.size()==1) cout&lt;&lt;children.front()&lt;&lt;endl;            else cout&lt;&lt;children.front();            children.pop();        }    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/02/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>判断两序列是否为同一二叉搜索树序列</p><p><strong>输入描述:</strong><br>开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。<br><strong>输出描述:</strong><br>如果序列相同则输出YES，否则输出NO<br><strong>示例</strong></p><p>输入</p><blockquote><p>2<br>567432<br>543267<br>576342`<br>0 </p></blockquote><p>输出</p><blockquote><p>YES<br>NO</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;//前序遍历和中序遍历可以唯一确定一棵二叉树，//而对二叉排序树而言，相同元素的二叉排序树中//序遍历一定相同，而不同元素二叉排序树使用前//序遍历就可以发现不相同，所以只需要前序遍历//两个二叉树，比较一下就可以判断using namespace std;string pre,in;struct TreeNode{    char data;    TreeNode* leftchild;    TreeNode* rightchild;    TreeNode(char c):data(c),leftchild(NULL),rightchild(NULL){}};TreeNode* Insert(TreeNode* root,char x){    if(root==NULL){        root=new TreeNode(x);    }    else if(x&lt;root-&gt;data){        root-&gt;leftchild=Insert(root-&gt;leftchild,x);    }    else if(x&gt;root-&gt;data){        root-&gt;rightchild=Insert(root-&gt;rightchild,x);    }    return root;}string preorder(TreeNode* root){    if(root==NULL) return &quot;#&quot;;    return root-&gt;data+preorder(root-&gt;leftchild)+preorder(root-&gt;rightchild);}int main(){    int n;    while(cin&gt;&gt;n){        if(n==0) break;        string s; TreeNode* root=NULL;        cin&gt;&gt;s;        //构建初始的排序树        for(int i=0;i&lt;s.size();i++){            root=Insert(root,s[i]);        }        string pre=preorder(root);        //构建用来比较的排序树        for(int i=0;i&lt;n;i++){            string str; TreeNode* T=NULL;            cin&gt;&gt;str;            for(int j=0;j&lt;str.size();j++){                T=Insert(T,str[j]);            }            string pre1=preorder(T);        //进行比较            if(pre1==pre) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
